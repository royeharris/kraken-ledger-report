<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
  <title>Kraken Ledger Report v0.10</title>
  <script async defer src="https://accounts.google.com/gsi/client"></script>
  <script async defer src="https://apis.google.com/js/api.js"></script>
  <style>
    :root {
      --primary: #2c3e50;
      --accent: #27ae60;
      --danger: #c0392b;
      --bg: #f8f9fa;
      --bridge: #2980b9;
      --cache: #8e44ad;
      --kraken: #5741d9;
      --joy: #27ae60;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      margin: 0;
      padding: 10px;
    }

    .container {
      max-width: 960px;
      margin: auto;
      background: #fff;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .branding-row {
      margin-bottom: 10px;
      font-size: 1.1rem;
      line-height: 1.1;
      color: var(--primary);
    }

    .branding-row b {
      font-weight: 800;
    }

    .branding-row span {
      font-weight: 500;
      font-size: 0.75rem;
      color: #7f8c8d;
      margin-left: 6px;
    }

    .header-wrap {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
      gap: 8px;
    }

    .header-btns {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      width: 100%;
    }

    .btn-lookup {
      padding: 6px;
      font-size: 0.72rem;
      border-radius: 6px;
      border: none;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      flex: 1;
      height: 52px;
      line-height: 1.1;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }

    .btn-pull {
      background: var(--cache);
    }

    .btn-refresh {
      background: var(--bridge);
    }

    .btn-save {
      background: var(--accent);
    }

    .btn-reset {
      background: var(--danger);
    }

    label {
      font-size: 0.7rem;
      font-weight: 800;
      display: block;
      margin-bottom: 2px;
      color: var(--primary);
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      font-size: 16px;
      box-sizing: border-box;
      height: 38px;
      -webkit-text-size-adjust: 100%;
      font-family: inherit;
    }

    .date-input-container {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #fff;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      padding: 0 8px;
      height: 38px;
    }

    .date-input-container input[type="date"] {
      border: none;
      padding: 0;
      height: 100%;
      font-size: 14px;
      flex-grow: 1;
      outline: none;
      background: transparent;
    }

    .date-disp {
      font-size: 0.65rem;
      color: #7f8c8d;
      text-align: center;
      margin-top: 2px;
    }

    .status-row {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      padding: 10px;
      background: #f1f2f6;
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--primary);
    }

    .status-item {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .status-item b {
      font-weight: 800;
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      width: 100%;
      margin-top: 15px;
    }

    button.action-main {
      padding: 8px 10px;
      border: none;
      border-radius: 6px;
      font-weight: 900;
      cursor: pointer;
      color: #fff;
      font-size: 0.72rem;
      -webkit-font-smoothing: antialiased;
      min-height: 52px;
    }

    .preview-wrap {
      width: 100%;
      overflow-x: auto;
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    table {
      min-width: 1800px;
      width: 1800px;
      border-collapse: collapse;
      font-size: 0.58rem;
      table-layout: fixed;
      font-family: inherit;
    }

    th,
    td {
      border: 1px solid #eee;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    th {
      padding: 6px 4px;
    }

    td {
      padding: 2px 3px;
    }

    th {
      background: #f2f2f2;
      font-weight: 900 !important;
      color: var(--primary);
      font-size: 0.58rem !important;
    }

    /* Column widths */
    .w-date {
      width: 9ch;
    }

    .w-recipient {
      width: 30ch;
    }

    .w-asset {
      width: 5ch;
      text-align: center;
    }

    .w-amount {
      width: 9ch;
      text-align: right;
    }

    .w-cur {
      width: 5ch;
      text-align: center;
    }

    .w-gbp {
      width: 8ch;
      text-align: right;
    }

    .w-time {
      width: 8ch;
      text-align: center;
    }

    .w-desttag {
      width: 10ch;
    }

    .w-wallet {
      width: 34ch;
    }

    .w-txid {
      width: 20ch;
    }

    .w-matched {
      width: 5ch;
      text-align: center;
    }

    .w-fee {
      width: 7ch;
      text-align: right;
    }

    .w-balance {
      width: 10ch;
      text-align: right;
    }

    #auth_status {
      font-size: 0.75rem;
      margin-top: 10px;
      text-align: center;
      color: var(--primary);
      font-weight: 800;
    }

    #log_btn {
      margin-top: 15px;
      width: 100%;
      background: var(--primary);
      color: #fff;
      font-size: 0.7rem;
      border-radius: 6px;
      padding: 8px;
      border: none;
      font-weight: 700;
      display: block;
    }

    #trace_log {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background: #2c3e50;
      color: #00ff00;
      font-family: "Courier New", monospace;
      font-size: 0.6rem;
      border-radius: 6px;
      max-height: 170px;
      overflow-y: auto;
      white-space: pre-wrap;
      cursor: pointer;
    }

    .ico {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--primary);
    }

    .cal-svg {
      width: 16px;
      height: 16px;
      display: block;
      fill: currentColor;
    }

    @media (max-width: 430px) {
      .actions {
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }

      button.action-main {
        min-height: 54px;
        padding: 8px 10px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header-wrap">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; position:relative;">
        <div class="branding-row" style="margin-bottom:0; line-height:1.2;">
          <div><b>Kraken Withdrawals Report</b> <span
              style="font-size:0.7rem; color:#7f8c8d; font-weight:600;">v2.26</span></div>
          <div style="font-size:0.65rem; color:#b0b0b0; font-weight:400;">(GBP equivalent for all XRP and USDT transfers
            in Date range)</div>
        </div>
        <div id="auth_status"
          style="position:absolute; left:50%; transform:translateX(-50%); font-size:0.7rem; font-weight:700;">Status:
          Ready</div>
        <div style="display:flex; gap:4px;">
          <button id="resetBtn" onclick="handleReportReset()"
            style="background:var(--danger); padding:4px 8px; height:auto; font-size:0.65rem; border-radius:6px; border:none; color:#fff; cursor:pointer; font-weight:800; box-shadow: 0 0 6px rgba(192,57,43,0.5);">Reset</button>
        </div>
      </div>

      <!-- Date Range -->
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
        <div>
          <label>Start Date</label>
          <div class="date-input-container" onclick="document.getElementById('startDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="startDate" onchange="handleDateChange('startDate')" type="date" />
          </div>
        </div>
        <div>
          <label>End Date</label>
          <div class="date-input-container" onclick="document.getElementById('endDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="endDate" onchange="handleDateChange('endDate')" type="date" />
          </div>
        </div>
      </div>

      <!-- Three Action Buttons -->
      <div style="display:flex; gap:6px; margin-bottom:10px;">
        <button onclick="readLedger()"
          style="flex:1; padding:10px 4px; background:var(--primary); color:#fff; border:none; border-radius:4px; font-size:0.7rem; font-weight:600; cursor:pointer;">Read<br />Ledger</button>
        <button onclick="pullAddresses()"
          style="flex:1; padding:10px 4px; background:var(--kraken); color:#fff; border:none; border-radius:4px; font-size:0.7rem; font-weight:600; cursor:pointer;">Pull
          Addresses<br />‚ú± 2FA</button>
        <button id="generate_btn" onclick="generateReport()"
          style="flex:1; padding:8px 4px; background:var(--joy); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Generate
          Report</button>
      </div>
    </div>

    <!-- API Config Button + Panel (click to close) -->
    <button id="api_btn" onclick="toggleApiConfig()"
      style="width:100%; padding:8px; margin-top:10px; background:#34495e; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">‚öôÔ∏è
      API Config</button>

    <div id="apiConfigSection" onclick="toggleApiConfig()"
      style="display:none; margin-bottom:15px; padding:10px; background:#f1f2f6; border-radius:6px; border:2px solid #34495e; cursor:pointer;">
      <div
        style="font-size:0.85rem; font-weight:700; color:var(--primary); margin-bottom:10px; padding-bottom:6px; border-bottom:1px solid #ddd;">
        ‚öôÔ∏è Kraken API Configuration (click to close)</div>

      <div onclick="event.stopPropagation()">
        <div style="font-size:0.7rem; font-weight:700; color:var(--primary); margin-bottom:4px;">Query API (for Ledger
          data)</div>
        <label>API Key</label>
        <input type="text" id="krakenApiKey" placeholder="API Key with Query permissions" style="margin-bottom:4px;">
        <label>Private Key</label>
        <input type="password" id="krakenPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:10px;">

        <div
          style="font-size:0.7rem; font-weight:700; color:var(--kraken); margin-bottom:4px; padding-top:8px; border-top:1px solid #ddd;">
          Withdraw API (for Addresses - requires 2FA)</div>
        <label>API Key</label>
        <input type="text" id="withdrawApiKey" placeholder="API Key with Withdraw permissions"
          style="margin-bottom:4px;">
        <label>Private Key</label>
        <input type="password" id="withdrawPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:10px;">

        <label>CORS Proxy</label>
        <select id="corsProxySelect" onchange="handleProxyChange()" style="margin-bottom:4px;">
          <option value="">None (direct - may fail in browser)</option>
          <option value="https://cors-anywhere.herokuapp.com/">cors-anywhere (50 req/hr)</option>
          <option value="https://corsproxy.io/?">corsproxy.io</option>
          <option value="https://api.allorigins.win/raw?url=">allorigins.win</option>
          <option value="custom">Custom...</option>
        </select>
        <input type="text" id="corsProxy" placeholder="Custom proxy URL" style="display:none; margin-bottom:4px;">
        <div style="font-size:0.6rem; color:#7f8c8d; margin-top:2px;">Browser CORS blocks direct Kraken calls. Select a
          proxy or use custom.</div>

        <button onclick="saveApiConfig(); event.stopPropagation();"
          style="margin-top:10px; padding:8px 16px; background:var(--accent); color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Save
          API Keys</button>
      </div>
    </div>

    <!-- Display Buttons for Address and Ledger Viewers -->
    <button id="address_btn" onclick="toggleAddressViewer()"
      style="width:100%; padding:8px; margin-top:10px; background:#27ae60; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Saved Addresses</button>

    <!-- Address Viewer Panel (hidden by default) - click to close -->
    <div id="addressViewerSection" onclick="toggleAddressViewer()"
      style="display:none; margin-bottom:15px; padding:10px; background:#e8f5e9; border-radius:6px; max-height:300px; overflow-y:auto; border:2px solid #27ae60; cursor:pointer;">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #a5d6a7;">
        <span style="font-size:0.85rem; font-weight:700; color:#27ae60;">üìã Saved Withdrawal Addresses (click to
          close)</span>
        <button onclick="event.stopPropagation(); copyAddressesToClipboard();"
          style="padding:4px 8px; background:#27ae60; color:#fff; border:none; border-radius:4px; font-size:0.6rem; cursor:pointer;">Copy
          to Clipboard</button>
      </div>
      <table id="addressTable" style="width:100%; font-size:0.6rem; border-collapse:collapse; table-layout:fixed;">
        <thead>
          <tr style="background:#c8e6c9; text-align:left;">
            <th style="padding:4px; border:1px solid #a5d6a7; width:40px;">Asset</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:100px;">Recipient</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:140px;">Key Name</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:200px;">Address</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:60px;">Dest Tag</th>
          </tr>
        </thead>
        <tbody id="addressTableBody">
          <tr>
            <td colspan="5" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded. Click "Pull
              Addresses" first.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <button id="ledger_btn" onclick="toggleLedgerViewer()"
      style="width:100%; padding:8px; margin-top:6px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Raw Ledger Data</button>

    <!-- Ledger Viewer Panel (hidden by default) - click to close -->
    <div id="ledgerViewerSection" onclick="toggleLedgerViewer()"
      style="display:none; margin-bottom:15px; padding:10px; background:#e3f2fd; border-radius:6px; max-height:300px; overflow-y:auto; border:2px solid #16a085; cursor:pointer;">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #90caf9;">
        <span style="font-size:0.85rem; font-weight:700; color:#16a085;">üìä Raw Ledger Data (click to close)</span>
        <button onclick="event.stopPropagation(); copyLedgerToClipboard();"
          style="padding:4px 8px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.6rem; cursor:pointer;">Copy
          to Clipboard</button>
      </div>
      <table id="ledgerTable" style="width:100%; font-size:0.6rem; border-collapse:collapse; table-layout:fixed;">
        <thead>
          <tr style="background:#bbdefb; text-align:left;">
            <th style="padding:4px; border:1px solid #90caf9; width:80px;">Date</th>
            <th style="padding:4px; border:1px solid #90caf9; width:50px;">Asset</th>
            <th style="padding:4px; border:1px solid #90caf9; width:80px;">Amount</th>
            <th style="padding:4px; border:1px solid #90caf9; width:60px;">Fee</th>
            <th style="padding:4px; border:1px solid #90caf9;">RefID</th>
          </tr>
        </thead>
        <tbody id="ledgerTableBody">
          <tr>
            <td colspan="5" style="padding:8px; text-align:center; color:#7f8c8d;">No ledger data loaded. Click "Read
              Ledger" first.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Status Bar -->
    <div class="status-row">
      <div class="status-item"><span>Withdrawals:</span> <b id="withdrawalCount">0</b></div>
      <div class="status-item"><span>Addresses:</span> <b id="addressCount">0</b></div>
      <div class="status-item" id="stagingHint" style="flex:1; text-align:right; font-size:0.65rem; color:#7f8c8d;">
      </div>
    </div>

    <!-- Bottom Actions -->
    <div style="display:flex; gap:6px; margin-top:10px;">
      <button onclick="handleSync()"
        style="flex:1; padding:8px 4px; background:var(--bridge); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Send
        Report<br />to Sheets</button>
      <button onclick="saveLocalData()"
        style="flex:1; padding:8px 4px; background:var(--accent); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Save<br />Local</button>
      <button id="wipeBtn" onclick="handleWipeConfirm()"
        style="flex:1; padding:8px 4px; background:var(--danger); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer; opacity:0.85;">Clear
        Report<br />Staging</button>
      <button onclick="loadLocalData()"
        style="flex:1; padding:8px 4px; background:#8e44ad; color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Load<br />Local</button>
    </div>

    <div style="display:flex; gap:6px; margin-top:10px;">
      <button onclick="copyReportToClipboard()"
        style="flex:1; padding:8px 4px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">üìã
        Copy Report to Clipboard</button>
    </div>

    <button id="report_btn" onclick="toggleReportViewer()"
      style="width:100%; padding:8px; margin-top:10px; background:#e67e22; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Report</button>

    <div class="preview-wrap" id="previewArea" style="display:none;"></div>

    <button id="log_btn" onclick="toggleLog(true)"
      style="width:100%; padding:8px; margin-top:10px; background:#8e44ad; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Trace Log</button>
    <button id="copy_trace_btn" onclick="copyTraceToClipboard()"
      style="width:100%; padding:8px; margin-top:6px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Copy
      Trace to Clipboard</button>
    <div id="trace_log" onclick="toggleLog(false)">Trace: v2.26 Kraken Withdrawals Report initialized.</div>
  </div>

  <script>
    const SHEET_ID = "1Vf0iqthwHv0kFqTRJkYShH_RBpbokLmiEDWGJN3Q0_E";
    const VER = "Kraken Withdrawals Report (v2.26)";
    const KRAKEN_API_URL = "https://api.kraken.com";

    // Default API credentials (enter your own in API Config)
    const DEFAULT_API_KEY = "";
    const DEFAULT_PRIVATE_KEY = "";

    // Cache data structure (v2.0)
    let cacheData = {
      withdrawals: [],        // from Kraken Ledgers API (withdrawals only)
      withdrawalHistory: [],  // from Kraken WithdrawStatus API
      krakenAddresses: [],    // from Kraken WithdrawAddresses API
      ratesCache: {}          // { "2024-11-02": { USDTGBP: 0.79, USDTEUR: 0.92, ... } }
    };

    let stagingRecords = [];
    let tokenClient;
    let resetConfirmed = false;
    let wipeConfirmed = false;
    let isGenerating = false;
    let reportResetConfirmed = false;

    // ---------- Logging ----------
    function logTrace(msg) {
      const log = document.getElementById("trace_log");
      const now = new Date().toLocaleTimeString();
      const base = log.textContent && log.textContent.trim().length
        ? log.textContent
        : "Trace: v2.26 Kraken Withdrawals Report initialized.";
      log.textContent = base + "\n[" + now + "] " + msg;
      log.scrollTop = log.scrollHeight;
      console.log(msg);
    }

    window.onerror = function (message, source, lineno, colno) {
      logTrace("FATAL: " + message + " @ " + (source || "") + ":" + lineno + ":" + colno);
    };
    window.onunhandledrejection = function (ev) {
      logTrace("FATAL PROMISE: " + (ev && ev.reason ? (ev.reason.message || ev.reason) : "unknown"));
    };

    function toggleLog(show) {
      document.getElementById("log_btn").style.display = show ? "none" : "block";
      document.getElementById("trace_log").style.display = show ? "block" : "none";
    }

    // Toggle report preview visibility
    function toggleReportViewer() {
      const btn = document.getElementById("report_btn");
      const area = document.getElementById("previewArea");
      const isHidden = area.style.display === "none";
      btn.innerText = isHidden ? "Hide Report" : "Display Report";
      area.style.display = isHidden ? "block" : "none";
    }

    function copyTraceToClipboard() {
      const log = document.getElementById("trace_log");
      const text = log.textContent || "";
      if (!text.trim() || text.trim() === "Trace: v2.15 Kraken Ledger Report initialized.") {
        alert("There are no trace log records to copy.");
        return;
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Trace log copied to clipboard!");
      });
    }

    function updateStatus(label, state) {
      const el = document.getElementById("auth_status");
      el.innerText = "Sync Status: " + label;
      const colors = { idle: "#7f8c8d", active: "#27ae60", sync: "#e67e22", error: "#c0392b" };
      el.style.color = colors[state] || colors.idle;
    }

    // ---------- Date Handling ----------
    function handleDateChange(id) {
      const dStr = document.getElementById(id).value;
      const dispEl = document.getElementById(id + "Disp");
      if (!dispEl) return; // Element doesn't exist in new design
      if (!dStr) { dispEl.innerText = ""; return; }
      const [y, m, d] = dStr.split("-").map(Number);
      const dt = new Date(y, m - 1, d);
      const day = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][dt.getDay()];
      const mon = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][dt.getMonth()];
      dispEl.innerText = day + " " + dt.getDate() + " " + mon + " '" + String(dt.getFullYear()).slice(-2);
    }

    // ---------- Reset / Wipe ----------
    function handleResetConfirm() {
      const btn = document.getElementById("resetBtn");
      if (!resetConfirmed) {
        resetConfirmed = true;
        btn.innerText = "CONFIRM?";
        setTimeout(() => { resetConfirmed = false; btn.innerText = "Reset"; }, 3000);
        return;
      }
      resetConfirmed = false;
      btn.innerText = "Reset";
      localReset();
    }

    function handleWipeConfirm() {
      const btn = document.getElementById("wipeBtn");
      if (!wipeConfirmed) {
        wipeConfirmed = true;
        btn.innerHTML = "CONFIRM?";
        setTimeout(() => { wipeConfirmed = false; btn.innerHTML = "Clear<br/>Staging"; }, 3000);
        return;
      }
      wipeConfirmed = false;
      btn.innerHTML = "Clear<br/>Staging";
      stagingRecords = [];
      localStorage.removeItem("kraken_staging");
      renderPreview();
      logTrace("Staging cleared manually.");
    }

    // Reset button with two-click confirmation - resets UI state without clearing data
    function handleReportReset() {
      const btn = document.getElementById("resetBtn");
      if (!reportResetConfirmed) {
        reportResetConfirmed = true;
        btn.innerText = "CONFIRM?";
        btn.style.animation = "pulse 0.5s ease-in-out";
        setTimeout(() => {
          reportResetConfirmed = false;
          btn.innerText = "Reset";
          btn.style.animation = "";
        }, 3000);
        return;
      }
      reportResetConfirmed = false;
      btn.innerText = "Reset";
      btn.style.animation = "";

      // Reset UI state (dates, status) but preserve cached data
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";
      stagingRecords = [];
      localStorage.removeItem("kraken_staging");
      renderPreview();
      updateStatus("Ready", "idle");
      updateStatusCounts();
      logTrace("=== APPLICATION RESET ===");
      logTrace("UI reset. Cached data preserved (withdrawals, addresses, rates). Staging cleared.");
    }

    // Copy report to clipboard (tab-separated for spreadsheet paste)
    function copyReportToClipboard() {
      if (!stagingRecords.length) {
        alert("No report records to copy. Generate a report first.");
        return;
      }

      // Build header row - match the report table order
      const headers = ["Date", "Time (UTC)", "Recipient", "GBP", "Asset", "Amount", "Fee", "Orig Cur", "Destination", "Dest Tag", "TX ID", "No match"];

      // Build data rows
      let text = headers.join("\t") + "\n";
      for (const r of stagingRecords) {
        const row = [
          r.dateSent,
          r.timeSent || '',
          r.recipient,
          r.gbpEquivalent,
          r.asset,
          r.amount,
          r.fee,
          r.originalCurrency,
          r.wallet,
          r.destTag,
          r.txId,
          r.matched === 'Yes' ? '' : 'X'
        ];
        text += row.join("\t") + "\n";
      }

      navigator.clipboard.writeText(text).then(() => {
        alert("Report copied to clipboard! (" + stagingRecords.length + " records)");
        logTrace("Copied " + stagingRecords.length + " report records to clipboard");
      }).catch(err => {
        logTrace("ERROR copying to clipboard: " + err);
        alert("Failed to copy. Check browser permissions.");
      });
    }

    function localReset() {
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";
      updateStatusCounts();
      logTrace("UI Reset.");
    }

    // ---------- Status Display ----------
    function updateStatusCounts() {
      document.getElementById("withdrawalCount").innerText = cacheData.withdrawals.length;
      document.getElementById("addressCount").innerText = cacheData.krakenAddresses.length;
    }

    // ---------- CORS Proxy Handling ----------
    function handleProxyChange() {
      const select = document.getElementById("corsProxySelect");
      const customInput = document.getElementById("corsProxy");
      if (select.value === "custom") {
        customInput.style.display = "block";
        customInput.focus();
      } else {
        customInput.style.display = "none";
        customInput.value = "";
      }
    }

    function getSelectedProxy() {
      const select = document.getElementById("corsProxySelect");
      const customInput = document.getElementById("corsProxy");
      if (select.value === "custom") {
        return customInput.value.trim();
      }
      return select.value;
    }

    // ---------- Local Save/Load (v2.0) ----------
    function saveLocalData() {
      if (cacheData.withdrawals.length === 0) {
        alert("Fetch data first before saving.");
        return;
      }
      localStorage.setItem("kraken_v2_withdrawals", JSON.stringify(cacheData.withdrawals));
      localStorage.setItem("kraken_v2_history", JSON.stringify(cacheData.withdrawalHistory));
      localStorage.setItem("kraken_v2_addresses", JSON.stringify(cacheData.krakenAddresses));
      localStorage.setItem("kraken_v2_rates", JSON.stringify(cacheData.ratesCache));
      logTrace("Data saved to localStorage.");
      alert("Data saved to local storage.");
    }

    function loadLocalData() {
      const cached = localStorage.getItem("kraken_v2_withdrawals");
      if (!cached) {
        alert("No saved data found. Use 'Fetch & Generate Report' first.");
        return;
      }
      cacheData.withdrawals = JSON.parse(cached || "[]");
      cacheData.withdrawalHistory = JSON.parse(localStorage.getItem("kraken_v2_history") || "[]");
      cacheData.krakenAddresses = JSON.parse(localStorage.getItem("kraken_v2_addresses") || "[]");
      cacheData.ratesCache = JSON.parse(localStorage.getItem("kraken_v2_rates") || "{}");
      updateStatusCounts();
      logTrace("Loaded from localStorage. Withdrawals=" + cacheData.withdrawals.length);

      // Regenerate report from cached data
      generateReportFromCache();
    }

    function saveApiConfig() {
      const apiKey = document.getElementById("krakenApiKey").value;
      const privateKey = document.getElementById("krakenPrivateKey").value;
      const withdrawKey = document.getElementById("withdrawApiKey").value;
      const withdrawPrivate = document.getElementById("withdrawPrivateKey").value;
      const proxy = getSelectedProxy();

      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      localStorage.setItem("kraken_withdraw_api_key", withdrawKey);
      localStorage.setItem("kraken_withdraw_private_key", withdrawPrivate);
      localStorage.setItem("kraken_cors_proxy", proxy);
      localStorage.setItem("kraken_cors_proxy_type", document.getElementById("corsProxySelect").value);

      logTrace("API credentials saved (Query + Withdraw).");
      alert("API keys saved.");
    }

    // ========== STEP 1: Read Ledger (Query API - no 2FA needed) ==========
    async function readLedger() {
      // Validate date range
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;

      if (!startDate || !endDate) {
        alert("Please select Start Date and End Date first.");
        logTrace("ERROR: Date range not set");
        return;
      }

      const startTime = new Date(startDate).getTime() / 1000;
      const endTime = new Date(endDate + "T23:59:59").getTime() / 1000;

      logTrace("=== READ LEDGER ===");
      logTrace("Date range: " + startDate + " to " + endDate);
      logTrace("Unix range: " + startTime + " to " + endTime);

      try {
        const creds = getApiCredentials();
        logTrace("Using Query API Key: " + creds.apiKey.substring(0, 8) + "...");
        logTrace("Proxy: " + (creds.proxy || "(none)"));

        updateStatus("Reading Ledger...", "sync");

        // Paginate through ALL ledger records
        const allWithdrawals = [];
        let offset = 0;
        let hasMore = true;
        let totalCount = 0;

        while (hasMore) {
          logTrace("Calling Kraken Ledgers API (offset=" + offset + ")...");
          const ledgerResult = await callKrakenPrivateAPI("Ledgers", {
            type: "withdrawal",
            start: Math.floor(startTime),
            end: Math.floor(endTime),
            ofs: offset
          }, creds);

          // Get total count from first response
          if (offset === 0 && ledgerResult.count) {
            totalCount = ledgerResult.count;
            logTrace("Total ledger entries (all types): " + totalCount);
          }

          const ledgerData = ledgerResult.ledger || {};
          const batchSize = Object.keys(ledgerData).length;
          logTrace("Batch " + (Math.floor(offset / 50) + 1) + ": " + batchSize + " records");

          if (batchSize === 0) {
            hasMore = false;
            break;
          }

          // Parse and filter for USDT/XRP
          for (const [ledgerId, entry] of Object.entries(ledgerData)) {
            const asset = (entry.asset || "").toUpperCase();
            if (asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP") {
              allWithdrawals.push({
                ledgerId,
                refid: entry.refid,
                time: entry.time,
                asset: asset,
                amount: parseFloat(entry.amount || 0),
                fee: parseFloat(entry.fee || 0),
                balance: parseFloat(entry.balance || 0)
              });
            }
          }

          offset += batchSize;

          // Stop if we've fetched fewer than 50 records (no more pages)
          if (batchSize < 50) {
            hasMore = false;
          }

          // Add small delay between requests to avoid rate limiting
          if (hasMore) {
            await new Promise(r => setTimeout(r, 200));
          }
        }

        cacheData.withdrawals = allWithdrawals;
        updateStatusCounts();
        renderLedgerTable();

        logTrace("SUCCESS: Fetched " + allWithdrawals.length + " USDT/XRP withdrawals (from " + offset + " total entries)");
        updateStatus("Ledger: " + allWithdrawals.length, "active");

      } catch (e) {
        updateStatus("Ledger Error", "error");
        logTrace("ERROR in readLedger: " + (e.message || e));
        alert("Error reading ledger: " + (e.message || e));
      }
    }

    // ========== STEP 2: Pull Addresses (Withdraw API - requires 2FA) ==========
    async function pullAddresses() {
      logTrace("=== PULL ADDRESSES ===");

      // Prompt for 2FA
      const otp = prompt("Enter your Kraken 2FA code:");
      if (!otp || otp.trim() === "") {
        logTrace("2FA cancelled by user");
        return;
      }

      try {
        const creds = getWithdrawCredentials();
        logTrace("Using Withdraw API Key: " + creds.apiKey.substring(0, 8) + "...");

        updateStatus("Pulling Addresses...", "sync");

        // Call WithdrawAddresses API
        logTrace("Calling Kraken WithdrawAddresses API...");
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, creds);

        cacheData.krakenAddresses = addresses || [];
        logTrace("SUCCESS: Fetched " + cacheData.krakenAddresses.length + " addresses");

        // Also fetch withdrawal history for destination details
        logTrace("Calling WithdrawStatus API...");
        await fetchWithdrawalHistory(otp.trim());

        updateStatusCounts();
        renderAddressTable();

        updateStatus("Addresses: " + cacheData.krakenAddresses.length, "active");

      } catch (e) {
        updateStatus("Address Error", "error");
        logTrace("ERROR in pullAddresses: " + (e.message || e));
        alert("Error pulling addresses: " + (e.message || e));
      }
    }

    // ========== STEP 3: Generate Report (local processing only) ==========
    async function generateReport() {
      // Prevent double-click / concurrent generation
      if (isGenerating) {
        logTrace("Report generation already in progress - ignoring click");
        return;
      }

      const btn = document.getElementById("generate_btn");
      isGenerating = true;
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = "Generating...<br/>Please wait";
        btn.style.opacity = "0.6";
      }

      logTrace("=== GENERATE REPORT ===");

      // Check prerequisites
      if (cacheData.withdrawals.length === 0) {
        alert("No ledger data loaded. Please click 'Read Ledger' first.");
        logTrace("ERROR: No withdrawals loaded");
        resetGenerateButton(btn);
        return;
      }

      if (cacheData.krakenAddresses.length === 0) {
        alert("No addresses loaded. Please click 'Pull Addresses' first (requires 2FA).");
        logTrace("ERROR: No addresses loaded");
        resetGenerateButton(btn);
        return;
      }

      try {
        // Generate report from cached data
        await generateReportFromCache();
      } finally {
        resetGenerateButton(btn);
      }
    }

    function resetGenerateButton(btn) {
      isGenerating = false;
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = "Generate<br/>Report";
        btn.style.opacity = "1";
      }
    }

    // ========== Toggle Ledger Viewer ==========
    function toggleLedgerViewer() {
      const btn = document.getElementById("ledger_btn");
      const section = document.getElementById("ledgerViewerSection");
      const isHidden = section.style.display === "none";
      btn.style.display = isHidden ? "none" : "block";
      section.style.display = isHidden ? "block" : "none";
      if (isHidden) {
        renderLedgerTable();
      }
    }

    // ========== Render Ledger Table ==========
    function renderLedgerTable() {
      const tbody = document.getElementById("ledgerTableBody");
      if (cacheData.withdrawals.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="padding:8px; text-align:center; color:#7f8c8d;">No ledger data loaded.</td></tr>';
        return;
      }

      let html = "";
      for (const w of cacheData.withdrawals) {
        const dateStr = formatTimestamp(w.time);
        html += "<tr>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(dateStr) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(w.asset) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + Math.abs(w.amount).toFixed(4) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + Math.abs(w.fee).toFixed(4) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9; word-break:break-all;">' + escHtml(w.refid || "") + "</td>";
        html += "</tr>";
      }
      tbody.innerHTML = html;
    }

    // ========== Copy to Clipboard Functions ==========
    function copyAddressesToClipboard() {
      if (cacheData.krakenAddresses.length === 0) {
        alert("No addresses to copy.");
        return;
      }
      let text = "Asset\tRecipient\tKey Name\tAddress\tDest Tag\n";
      for (const a of cacheData.krakenAddresses) {
        const recipient = (a.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20)\s*/gi, "").trim();
        text += (a.asset || "") + "\t" + recipient + "\t" + (a.key || "") + "\t" + (a.address || "") + "\t" + (a.tag || a.memo || "") + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Addresses copied to clipboard!");
        logTrace("Copied " + cacheData.krakenAddresses.length + " addresses to clipboard");
      });
    }

    function copyLedgerToClipboard() {
      if (cacheData.withdrawals.length === 0) {
        alert("No ledger data to copy.");
        return;
      }
      let text = "Date\tAsset\tAmount\tFee\tRefID\n";
      for (const w of cacheData.withdrawals) {
        text += formatTimestamp(w.time) + "\t" + w.asset + "\t" + Math.abs(w.amount) + "\t" + Math.abs(w.fee) + "\t" + (w.refid || "") + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Ledger data copied to clipboard!");
        logTrace("Copied " + cacheData.withdrawals.length + " ledger entries to clipboard");
      });
    }

    // ---------- Staging Table Render ----------
    function renderPreview() {
      const area = document.getElementById("previewArea");
      const hint = document.getElementById("stagingHint");
      if (!stagingRecords.length) {
        area.innerHTML = "";
        if (hint) hint.textContent = "No staging records. Click 'Generate Report' after loading data.";
        return;
      }
      if (hint) hint.textContent = stagingRecords.length + " staging record(s)";

      let html = '<table><thead><tr>';
      html += '<th class="w-date">Date</th>';
      html += '<th class="w-time">Time (UTC)</th>';
      html += '<th class="w-recipient">Recipient</th>';
      html += '<th class="w-gbp">GBP</th>';
      html += '<th class="w-asset">Asset</th>';
      html += '<th class="w-amount">Amount</th>';
      html += '<th class="w-fee">Fee</th>';
      html += '<th class="w-cur">Orig Cur</th>';
      html += '<th class="w-wallet">Destination</th>';
      html += '<th class="w-desttag">Dest Tag</th>';
      html += '<th class="w-txid">TX ID</th>';
      html += '<th class="w-matched">No match</th>';
      html += '</tr></thead><tbody>';

      for (const r of stagingRecords) {
        html += '<tr>';
        html += '<td class="w-date">' + escHtml(r.dateSent) + '</td>';
        html += '<td class="w-time">' + escHtml(r.timeSent || '') + '</td>';
        html += '<td class="w-recipient">' + escHtml(r.recipient) + '</td>';
        html += '<td class="w-gbp">' + escHtml(r.gbpEquivalent) + '</td>';
        html += '<td class="w-asset">' + escHtml(r.asset) + '</td>';
        html += '<td class="w-amount">' + escHtml(r.amount) + '</td>';
        html += '<td class="w-fee">' + escHtml(r.fee) + '</td>';
        html += '<td class="w-cur">' + escHtml(r.originalCurrency) + '</td>';
        html += '<td class="w-wallet">' + escHtml(r.wallet) + '</td>';
        html += '<td class="w-desttag">' + escHtml(r.destTag) + '</td>';
        html += '<td class="w-txid">' + escHtml(r.txId) + '</td>';
        // Show X only if no match (missing destination or no address matched)
        const noMatch = r.matched !== 'Yes';
        html += '<td class="w-matched" style="font-weight:800; color:var(--danger); text-align:center;">' + (noMatch ? 'X' : '') + '</td>';
        html += '</tr>';
      }
      html += '</tbody></table>';
      area.innerHTML = html;
    }

    function escHtml(s) {
      if (s === null || s === undefined) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    // Parse Kraken date strings like "2024-11-02 08:42:24" to Unix timestamp
    function parseDateString(dateStr) {
      try {
        if (!dateStr && dateStr !== 0) return 0;

        // If it's already a number, return it directly (Unix timestamp in seconds)
        if (typeof dateStr === "number") {
          if (isNaN(dateStr)) return 0;
          return dateStr;
        }

        // Convert to string for parsing
        const str = String(dateStr).trim();
        if (!str) return 0;

        // If it's a numeric string without dashes, could be Unix timestamp OR Excel serial date
        const numVal = parseFloat(str);
        if (!isNaN(numVal) && str.indexOf("-") === -1) {
          // Excel serial dates are small numbers (days since 1900-01-01)
          // A date in 2024 is around 45000 in Excel format
          // Unix timestamps in seconds for 2024 are around 1700000000
          if (numVal < 100000) {
            // This is likely an Excel serial date, convert to Unix timestamp
            // Excel epoch is 1900-01-01, but Excel incorrectly considers 1900 a leap year
            // So we adjust by subtracting 25569 (days between 1900-01-01 and 1970-01-01)
            // Then multiply by 86400 (seconds per day)
            const excelEpoch = (numVal - 25569) * 86400;
            logTrace("DEBUG: Converted Excel date " + numVal + " to Unix " + excelEpoch);
            return excelEpoch;
          }

          // If number is very large (> year 2100 in seconds), it's likely milliseconds
          if (numVal > 4102444800) {
            return numVal / 1000;
          }
          return numVal;
        }

        // Parse date string like "2024-11-02 08:42:24"
        const dt = new Date(str.replace(" ", "T"));
        const result = dt.getTime() / 1000;

        // Check for invalid date
        if (isNaN(result)) {
          logTrace("WARNING: Could not parse date: '" + str + "'");
          return 0;
        }

        return result;
      } catch (e) {
        logTrace("ERROR parsing date: " + e.message);
        return 0;
      }
    }

    function extractDestTag(refid) {
      // Destination tag often appears as a numeric suffix or can be parsed from description
      // For now, return empty - will need refinement based on actual data format
      const match = String(refid).match(/\d{6,}/);
      return match ? match[0] : "";
    }

    function extractWallet(refid) {
      // Wallet address extraction - placeholder
      return "";
    }

    function extractFiatCurrency(trade) {
      const pair = (trade.pair || "").toUpperCase();
      if (pair.includes("GBP") || pair.includes("ZGBP")) return "GBP";
      if (pair.includes("EUR") || pair.includes("ZEUR")) return "EUR";
      if (pair.includes("USD") || pair.includes("ZUSD")) return "USD";
      return "";
    }

    function calculateGBPEquivalent(trade) {
      const cost = parseFloat(trade.cost || 0);
      const cur = extractFiatCurrency(trade);
      if (cur === "GBP") return cost.toFixed(2);
      if (cur === "EUR") return (cost * 0.86).toFixed(2); // Approximate EUR‚ÜíGBP
      if (cur === "USD") return (cost * 0.79).toFixed(2); // Approximate USD‚ÜíGBP
      return cost.toFixed(2);
    }

    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const d = String(dt.getDate()).padStart(2, "0");
      const m = String(dt.getMonth() + 1).padStart(2, "0");
      const y = dt.getFullYear();
      return d + "/" + m + "/" + y;
    }

    // ---------- Google Auth / Sheets ----------
    function gapiLoaded() {
      gapi.load("client", async () => {
        await gapi.client.init({ apiKey: "AIzaSyDvZ1XZw5bZgWSB9zaU7h9Vtn7MhDGFMSM" });
        await gapi.client.load("sheets", "v4");
        logTrace("GAPI Ready.");
      });
    }

    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: "23231735212-jtgur3sn2ndh798ke00pm2a1d5rkd4eu.apps.googleusercontent.com",
        scope: "https://www.googleapis.com/auth/spreadsheets",
        callback: () => { }
      });
      logTrace("GIS Ready.");
    }

    function initRefresh() {
      requestToken(true, () => fetchAllSheets());
    }

    function requestToken(forcePrompt, onOk) {
      tokenClient.callback = (resp) => {
        if (!resp || !resp.access_token) return;
        const issuedAt = Date.now();
        const expiresIn = resp.expires_in ? Number(resp.expires_in) : 3600;
        localStorage.setItem("g_token", resp.access_token);
        localStorage.setItem("g_token_issued_at", String(issuedAt));
        localStorage.setItem("g_token_expires_in", String(expiresIn));
        gapi.client.setToken({ access_token: resp.access_token });
        onOk();
      };
      const args = forcePrompt ? { prompt: "consent" } : { prompt: "" };
      tokenClient.requestAccessToken(args);
    }

    function ensureTokenThen(onOk) {
      const tok = localStorage.getItem("g_token");
      const issuedAt = Number(localStorage.getItem("g_token_issued_at") || "0");
      const exp = Number(localStorage.getItem("g_token_expires_in") || "0");
      const age = (Date.now() - issuedAt) / 1000;

      if (tok && issuedAt && exp && age < (exp - 60)) {
        gapi.client.setToken({ access_token: tok });
        onOk();
        return;
      }
      requestToken(true, onOk);
    }

    async function handleSync() {
      if (!stagingRecords.length) {
        alert("No staging records to send.");
        return;
      }

      updateStatus("Syncing...", "sync");
      logTrace("Sync started. Rows=" + stagingRecords.length);

      ensureTokenThen(async () => {
        try {
          // Find first empty row in ReportStaging
          const meta = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SHEET_ID,
            range: "'ReportStaging'!A2:A"
          });
          const used = meta.result.values ? meta.result.values.length : 0;
          const startRow = 2 + used;

          // Prepare values
          const headers = [
            "Date", "Time (UTC)", "Recipient", "GBP", "Asset", "Amount", "Fee",
            "Orig Cur", "Orig Amt", "Destination", "Dest Tag", "TX ID", "Match", "Version"
          ];

          const vals = stagingRecords.map(r => [
            r.dateSent,
            r.timeSent,
            r.recipient,
            r.gbpEquivalent,
            r.asset,
            r.amount,
            r.fee,
            r.originalCurrency,
            r.originalAmount,
            r.wallet,
            r.destTag,
            r.txId,
            r.matched,
            VER
          ]);

          // If sheet is empty, add headers first
          if (startRow === 2) {
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: SHEET_ID,
              range: "'ReportStaging'!A1:O1",
              valueInputOption: "USER_ENTERED",
              resource: { values: [headers] }
            });
          }

          await gapi.client.sheets.spreadsheets.values.update({
            spreadsheetId: SHEET_ID,
            range: "'ReportStaging'!A" + startRow + ":O" + (startRow + vals.length - 1),
            valueInputOption: "USER_ENTERED",
            resource: { values: vals }
          });

          updateStatus("Token Active", "active");
          logTrace("Sync complete. StartRow=" + startRow);
          alert("Sync completed. " + vals.length + " records sent to ReportStaging.");

        } catch (e) {
          updateStatus("Sync error", "error");
          logTrace("Sync error: " + (e.message || e));
          alert("Sync failed. Check trace log.");
        }
      });
    }

    // ---------- Address Viewer ----------
    function toggleAddressViewer() {
      const btn = document.getElementById("address_btn");
      const section = document.getElementById("addressViewerSection");
      const isHidden = section.style.display === "none";
      btn.style.display = isHidden ? "none" : "block";
      section.style.display = isHidden ? "block" : "none";
      if (isHidden) {
        renderAddressTable();
      }
    }

    function renderAddressTable() {
      const tbody = document.getElementById("addressTableBody");
      const addresses = cacheData.krakenAddresses || [];

      if (addresses.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded. Click "Fetch Addresses" first.</td></tr>';
        return;
      }

      // Sort by Asset, then Recipient, then Key Name
      const sorted = [...addresses].sort((a, b) => {
        const assetA = (a.asset || "").toUpperCase();
        const assetB = (b.asset || "").toUpperCase();
        if (assetA !== assetB) return assetA.localeCompare(assetB);

        const recipA = (a.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        const recipB = (b.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        if (recipA !== recipB) return recipA.localeCompare(recipB);

        return (a.key || "").localeCompare(b.key || "");
      });

      let html = "";
      for (const addr of sorted) {
        const asset = escHtml(addr.asset || "");
        const keyName = escHtml(addr.key || "");
        const recipient = escHtml((addr.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim());
        const address = escHtml(addr.address || "");
        const destTag = escHtml(addr.tag || addr.memo || "");

        html += '<tr style="border-bottom:1px solid #e0e0e0;">';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:45px; font-size:0.6rem;">' + asset + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:150px; max-width:150px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + recipient + '">' + recipient + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:200px; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + keyName + '">' + keyName + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; font-family:monospace; font-size:0.5rem; word-break:break-all;" title="' + address + '">' + address + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:70px; font-size:0.6rem;">' + destTag + '</td>';
        html += '</tr>';
      }

      tbody.innerHTML = html;
    }

    // ---------- Kraken API ----------
    function toggleApiConfig() {
      const btn = document.getElementById("api_btn");
      const section = document.getElementById("apiConfigSection");
      const isHidden = section.style.display === "none";
      btn.style.display = isHidden ? "none" : "block";
      section.style.display = isHidden ? "block" : "none";

      // Load saved credentials when opening
      if (isHidden) {
        const savedKey = localStorage.getItem("kraken_api_key");
        const savedPrivate = localStorage.getItem("kraken_private_key");
        const savedProxyType = localStorage.getItem("kraken_cors_proxy_type");
        const savedProxy = localStorage.getItem("kraken_cors_proxy");
        const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
        const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
        if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
        if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
        if (savedProxyType) {
          document.getElementById("corsProxySelect").value = savedProxyType;
          if (savedProxyType === "custom" && savedProxy) {
            document.getElementById("corsProxy").value = savedProxy;
            document.getElementById("corsProxy").style.display = "block";
          }
        }
        if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
        if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;
      }
    }

    function getApiCredentials() {
      let apiKey = document.getElementById("krakenApiKey").value.trim();
      let privateKey = document.getElementById("krakenPrivateKey").value.trim();
      if (!apiKey) apiKey = DEFAULT_API_KEY;
      if (!privateKey) privateKey = DEFAULT_PRIVATE_KEY;
      // Save for next time
      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      const proxy = getSelectedProxy();
      return { apiKey, privateKey, proxy };
    }

    // Withdraw API uses separate credentials (requires 2FA permission)
    function getWithdrawCredentials() {
      let apiKey = document.getElementById("withdrawApiKey").value.trim();
      let privateKey = document.getElementById("withdrawPrivateKey").value.trim();
      if (!apiKey || !privateKey) {
        throw new Error("Please enter Withdraw API credentials in API Config (requires 2FA permission)");
      }
      const proxy = getSelectedProxy();
      return { apiKey, privateKey, proxy };
    }

    // Base64 helpers
    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    // Kraken API signature generation using Web Crypto API
    async function createKrakenSignature(urlPath, postData, privateKeyBase64) {
      const encoder = new TextEncoder();

      // Step 1: Get nonce from postData
      const params = new URLSearchParams(postData);
      const nonce = params.get("nonce");

      // Step 2: SHA256 hash of (nonce + postData)
      const sha256Data = encoder.encode(nonce + postData);
      const sha256Hash = await crypto.subtle.digest("SHA-256", sha256Data);

      // Step 3: Concatenate urlPath bytes + sha256Hash bytes
      const pathBytes = encoder.encode(urlPath);
      const combined = new Uint8Array(pathBytes.length + sha256Hash.byteLength);
      combined.set(pathBytes, 0);
      combined.set(new Uint8Array(sha256Hash), pathBytes.length);

      // Step 4: HMAC-SHA512 with decoded private key
      const privateKeyBytes = base64ToArrayBuffer(privateKeyBase64);
      const hmacKey = await crypto.subtle.importKey(
        "raw",
        privateKeyBytes,
        { name: "HMAC", hash: "SHA-512" },
        false,
        ["sign"]
      );

      const signature = await crypto.subtle.sign("HMAC", hmacKey, combined);

      // Step 5: Base64 encode the signature
      return arrayBufferToBase64(signature);
    }

    async function callKrakenPrivateAPI(endpoint, params = {}, credentials = null) {
      const { apiKey, privateKey, proxy } = credentials || getApiCredentials();
      const urlPath = "/0/private/" + endpoint;
      const nonce = Date.now().toString();

      const postParams = new URLSearchParams({ nonce, ...params });
      const postData = postParams.toString();

      try {
        const signature = await createKrakenSignature(urlPath, postData, privateKey);

        const url = (proxy ? proxy : "") + KRAKEN_API_URL + urlPath;

        logTrace("Calling Kraken API: " + endpoint + " (with OTP: " + (params.otp ? "yes" : "no") + ")");
        logTrace("URL: " + url);

        const response = await fetch(url, {
          method: "POST",
          headers: {
            "API-Key": apiKey,
            "API-Sign": signature,
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: postData
        });

        if (!response.ok) {
          // Try to get more details from the response
          let errorDetails = "";
          try {
            const errorText = await response.text();
            errorDetails = errorText.substring(0, 200);
            logTrace("Error response body: " + errorDetails);
          } catch (e) { }

          if (response.status === 403 && proxy && proxy.includes("cors-anywhere")) {
            logTrace("*** CORS-ANYWHERE 403: You may need to visit " + proxy + " and click 'Request temporary access' ***");
            throw new Error("CORS Proxy 403: Visit " + proxy + " to request access first");
          }
          throw new Error("HTTP " + response.status + ": " + response.statusText + (errorDetails ? " - " + errorDetails : ""));
        }

        const data = await response.json();

        if (data.error && data.error.length > 0) {
          throw new Error("Kraken API Error: " + data.error.join(", "));
        }

        return data.result;

      } catch (e) {
        if (e.message.includes("Failed to fetch") || e.message.includes("NetworkError")) {
          logTrace("CORS blocked. Try using a CORS proxy in API Config.");
          throw new Error("CORS blocked. Please configure a CORS proxy in API Config.");
        }
        throw e;
      }
    }

    async function fetchKrakenAddresses() {
      logTrace("Fetching Kraken withdrawal addresses...");

      try {
        // Get withdrawal-specific credentials
        const withdrawCreds = getWithdrawCredentials();

        // Prompt for 2FA code
        const otp = prompt("Enter your 2FA code for Kraken Withdrawal API:");
        if (!otp || otp.trim() === "") {
          logTrace("2FA cancelled by user");
          updateStatus("Cancelled", "idle");
          return;
        }

        updateStatus("Fetching Kraken...", "sync");

        // Fetch all withdrawal addresses using withdrawal API key with 2FA
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, withdrawCreds);

        logTrace("Kraken WithdrawAddresses response: " + JSON.stringify(addresses).substring(0, 500));

        // addresses is an array of address objects
        cacheData.krakenAddresses = addresses || [];

        // Parse into destTags (XRP) and wallets (USDT/others)
        const newDestTags = [];
        const newWallets = [];

        for (const addr of cacheData.krakenAddresses) {
          // addr structure: { address, asset, key, memo, method, new, tag, verified }
          const keyName = addr.key || "";  // This is the saved address name (e.g., "Aleksey XRP")
          const asset = addr.asset || "";
          const address = addr.address || "";
          const destTag = addr.tag || addr.memo || "";  // XRP uses tag, others might use memo

          // Try to extract recipient name from key (e.g., "Aleksey XRP" -> "Aleksey")
          const recipientName = keyName.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim() || keyName;

          if (asset.toUpperCase().includes("XRP") || asset === "XXRP") {
            newDestTags.push({
              recipient: recipientName,
              destTag: destTag,
              address: address,
              keyName: keyName,
              asset: asset
            });
          } else {
            newWallets.push({
              recipient: recipientName,
              asset: asset,
              address: address,
              keyName: keyName
            });
          }
        }

        // Merge with existing data (don't overwrite if already have data)
        if (newDestTags.length > 0) {
          cacheData.destTags = newDestTags;
          logTrace("Found " + newDestTags.length + " XRP addresses with destination tags.");
        }
        if (newWallets.length > 0) {
          cacheData.wallets = newWallets;
          logTrace("Found " + newWallets.length + " other wallet addresses (USDT, etc.).");
        }

        updateStatusCounts();
        updateStatus("Kraken OK", "active");

        const summary = "Fetched " + cacheData.krakenAddresses.length + " addresses.\n" +
          "XRP (with dest tags): " + newDestTags.length + "\n" +
          "Other wallets: " + newWallets.length;
        alert(summary);
        logTrace(summary.replace(/\n/g, " | "));

      } catch (e) {
        updateStatus("Kraken Error", "error");
        logTrace("Kraken API error: " + (e.message || e));
        alert("Kraken API Error:\n" + (e.message || e) + "\n\nCheck trace log for details.");
      }
    }

    // Fetch withdrawal history with destination details
    async function fetchWithdrawalHistory(otp) {
      const withdrawCreds = getWithdrawCredentials();

      // Try both USDT and XRP (common assets for withdrawals)
      const assets = ["USDT", "XXRP", "ZUSD", "ZGBP"];
      const allWithdrawals = [];

      for (const asset of assets) {
        try {
          logTrace("Fetching withdrawal history for " + asset + "...");
          const params = otp ? { asset, otp } : { asset };
          const result = await callKrakenPrivateAPI("WithdrawStatus", params, withdrawCreds);

          if (Array.isArray(result)) {
            for (const w of result) {
              allWithdrawals.push({
                ...w,
                queriedAsset: asset
              });
            }
            logTrace("Found " + result.length + " withdrawals for " + asset);
          }
        } catch (e) {
          logTrace("WithdrawStatus for " + asset + ": " + (e.message || "error"));
        }
      }

      cacheData.withdrawalHistory = allWithdrawals;
      logTrace("Total withdrawal history entries: " + allWithdrawals.length);
      return allWithdrawals;
    }

    // Get historical exchange rate from Kraken public API
    // Returns { gbpRate, eurRate } for the given asset at the given timestamp
    // Strategy: Fetch USD pair (more history) and convert via GBP/USD rate
    async function getKrakenRate(asset, timestamp) {
      // Map Kraken asset names to pair names
      const assetMap = {
        "XXRP": "XRP", "XRP": "XRP",
        "USDT": "USDT", "USDTTRC20": "USDT",
        "XXBT": "XBT", "XBT": "XBT",
        "XETH": "ETH", "ETH": "ETH",
        "ZUSD": "USD", "USD": "USD"
      };

      const baseAsset = assetMap[asset] || asset.replace(/^X|^Z/, "");
      const rates = { gbpRate: null, eurRate: null, usdRate: null };
      const proxy = getSelectedProxy();

      // Use 30 days before to ensure we get historical data
      const thirtyDaysBefore = timestamp - (30 * 24 * 60 * 60);

      // Helper to fetch rate from OHLC
      async function fetchOHLC(pair, since) {
        try {
          const url = proxy + "https://api.kraken.com/0/public/OHLC?pair=" + pair + "&interval=1440&since=" + Math.floor(since);
          const response = await fetch(url);
          const data = await response.json();

          if (data.result && Object.keys(data.result).length > 0) {
            const pairData = Object.values(data.result).find(v => Array.isArray(v));
            if (pairData && pairData.length > 0) {
              // Find the candle closest to our timestamp
              let bestCandle = null;
              let bestDiff = Infinity;

              for (const candle of pairData) {
                const diff = Math.abs(candle[0] - timestamp);
                if (diff < bestDiff) {
                  bestDiff = diff;
                  bestCandle = candle;
                }
              }

              // Accept if within 60 days
              if (bestCandle && bestDiff < 60 * 24 * 60 * 60) {
                return parseFloat(bestCandle[4]); // close price
              }
            }
          }
        } catch (e) {
          // Pair might not exist
        }
        return null;
      }

      // USDT is a USD stablecoin, so USDT/USD rate is always ~1.0
      if (baseAsset === "USDT") {
        rates.usdRate = 1.0;
        // Try direct GBP pair for USDT
        rates.gbpRate = await fetchOHLC("USDTGBP", thirtyDaysBefore);

        // If no direct GBP, use GBP/USD to convert
        if (rates.gbpRate === null) {
          const gbpusdRate = await fetchOHLC("GBPUSD", thirtyDaysBefore);
          if (gbpusdRate !== null) {
            rates.gbpRate = 1.0 / gbpusdRate; // 1 USDT = 1 USD, convert to GBP
          }
        }
      } else {
        // For other assets (XRP, etc.), try USD pair first
        rates.usdRate = await fetchOHLC(baseAsset + "USD", thirtyDaysBefore);

        // If we have USD rate, get GBP/USD to convert
        if (rates.usdRate !== null) {
          const gbpusdRate = await fetchOHLC("GBPUSD", thirtyDaysBefore);
          if (gbpusdRate !== null) {
            rates.gbpRate = rates.usdRate / gbpusdRate;
          }
        }

        // If still no GBP rate, try direct GBP pair
        if (rates.gbpRate === null) {
          rates.gbpRate = await fetchOHLC(baseAsset + "GBP", thirtyDaysBefore);
        }
      }

      // Try EUR pair for eurRate
      if (baseAsset !== "USDT") {
        rates.eurRate = await fetchOHLC(baseAsset + "EUR", thirtyDaysBefore);
      } else {
        rates.eurRate = await fetchOHLC("USDTEUR", thirtyDaysBefore);
      }

      // If still no GBP rate but we have EUR rate, convert via EUR/GBP
      if (rates.gbpRate === null && rates.eurRate !== null) {
        // Try GBPEUR pair (gives EUR per GBP, so we divide)
        let gbpeurRate = await fetchOHLC("GBPEUR", thirtyDaysBefore);
        if (gbpeurRate !== null) {
          rates.gbpRate = rates.eurRate / gbpeurRate;
        } else {
          // Fallback: try EURGBP (gives GBP per EUR, so we multiply)
          const eurgbpRate = await fetchOHLC("EURGBP", thirtyDaysBefore);
          if (eurgbpRate !== null) {
            rates.gbpRate = rates.eurRate * eurgbpRate;
          }
        }
      }

      return rates;
    }

    // ========== MAIN FUNCTION: Fetch & Generate Report (v2.0) ==========
    async function fetchAndGenerateReport() {
      // Step 0: Validate date range
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;

      if (!startDate || !endDate) {
        alert("Please select Start Date and End Date first.");
        return;
      }

      const startTime = new Date(startDate).getTime() / 1000;
      const endTime = new Date(endDate + "T23:59:59").getTime() / 1000;

      logTrace("Date range: " + startDate + " to " + endDate);
      logTrace("Unix range: " + startTime + " to " + endTime);

      // Step 1: Prompt for 2FA
      const otp = prompt("Enter your Kraken 2FA code:");
      if (!otp || otp.trim() === "") {
        logTrace("2FA cancelled by user");
        return;
      }

      try {
        const creds = getApiCredentials();
        updateStatus("Fetching...", "sync");

        // Step 2: Call Kraken Ledgers API for withdrawals
        logTrace("Calling Kraken Ledgers API...");
        const ledgerResult = await callKrakenPrivateAPI("Ledgers", {
          type: "withdrawal",
          start: Math.floor(startTime),
          end: Math.floor(endTime),
          otp: otp.trim()
        }, creds);

        // ledgerResult is { ledger_id: { refid, time, type, subtype, aclass, asset, amount, fee, balance } }
        const allWithdrawals = [];
        for (const [ledgerId, entry] of Object.entries(ledgerResult.ledger || ledgerResult || {})) {
          const asset = (entry.asset || "").toUpperCase();
          // Filter to USDT and XRP only
          if (asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP") {
            allWithdrawals.push({
              ledgerId,
              refid: entry.refid,
              time: entry.time,
              asset: asset,
              amount: parseFloat(entry.amount || 0),
              fee: parseFloat(entry.fee || 0),
              balance: parseFloat(entry.balance || 0)
            });
          }
        }

        cacheData.withdrawals = allWithdrawals;
        logTrace("Fetched " + allWithdrawals.length + " USDT/XRP withdrawals from Ledgers API");

        // Step 3: Call WithdrawStatus for destination details
        logTrace("Fetching withdrawal details...");
        await fetchWithdrawalHistory(otp.trim());

        // Step 4: Call WithdrawAddresses for recipient names
        logTrace("Fetching saved addresses...");
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, creds);
        cacheData.krakenAddresses = addresses || [];
        logTrace("Fetched " + cacheData.krakenAddresses.length + " saved addresses");

        updateStatusCounts();

        // Step 5: Generate report from fetched data
        await generateReportFromCache();

        updateStatus("Ready", "active");

      } catch (e) {
        updateStatus("Error", "error");
        logTrace("Error: " + (e.message || e));
        alert("Error: " + (e.message || e));
      }
    }

    // Generate report from cached data (no API calls except for rates)
    async function generateReportFromCache() {
      if (cacheData.withdrawals.length === 0) {
        alert("No withdrawal data. Please Fetch first.");
        return;
      }

      updateStatus("Generating...", "sync");
      logTrace("Generating report from " + cacheData.withdrawals.length + " withdrawals...");

      stagingRecords = [];

      // Step 1: Collect unique dates for batch rate lookup
      const uniqueDates = new Set();
      for (const w of cacheData.withdrawals) {
        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        uniqueDates.add(dateStr);
      }
      logTrace("Unique dates: " + Array.from(uniqueDates).join(", "));

      // Step 2: Batch fetch rates for each unique date
      const ratesToFetch = [];
      for (const dateStr of uniqueDates) {
        const timestamp = new Date(dateStr).getTime() / 1000 + 43200; // noon
        if (!cacheData.ratesCache[dateStr]) {
          ratesToFetch.push({ dateStr, timestamp });
        }
      }

      if (ratesToFetch.length > 0) {
        logTrace("Fetching rates for " + ratesToFetch.length + " dates...");
        updateStatus("Fetching rates...", "sync");

        for (const { dateStr, timestamp } of ratesToFetch) {
          // Fetch all 4 pairs for this date
          const usdtRates = await getKrakenRate("USDT", timestamp);
          const xrpRates = await getKrakenRate("XRP", timestamp);

          cacheData.ratesCache[dateStr] = {
            USDTGBP: usdtRates.gbpRate,
            USDTEUR: usdtRates.eurRate,
            XRPGBP: xrpRates.gbpRate,
            XRPEUR: xrpRates.eurRate
          };
          logTrace("Rates for " + dateStr + ": USDTGBP=" + usdtRates.gbpRate + ", XRPGBP=" + xrpRates.gbpRate);
        }
      }

      // Step 3: Build records
      for (const w of cacheData.withdrawals) {
        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        const rates = cacheData.ratesCache[dateStr] || {};

        // Find matching withdrawal in history (for address/tag)
        const historyMatch = cacheData.withdrawalHistory.find(h => h.refid === w.refid);

        // Get address and destination tag
        let walletAddr = historyMatch ? (historyMatch.info || historyMatch.address || "") : "";
        let destTag = historyMatch ? (historyMatch.dest || historyMatch.tag || "") : "";

        // Find recipient from krakenAddresses
        let recipient = "";
        const addrMatch = cacheData.krakenAddresses.find(a =>
          a.address === walletAddr || (a.tag && a.tag === destTag)
        );
        if (addrMatch) {
          recipient = (addrMatch.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20)\\s*/gi, "").trim();
        }

        // Calculate GBP equivalent
        let gbpEquivalent = "";
        let eurEquivalent = "";
        const absAmount = Math.abs(w.amount);

        if (w.asset.includes("USDT")) {
          if (rates.USDTGBP) gbpEquivalent = (absAmount * rates.USDTGBP).toFixed(2);
          if (rates.USDTEUR) eurEquivalent = (absAmount * rates.USDTEUR).toFixed(2);
        } else if (w.asset.includes("XRP") || w.asset === "XXRP") {
          if (rates.XRPGBP) gbpEquivalent = (absAmount * rates.XRPGBP).toFixed(2);
          if (rates.XRPEUR) eurEquivalent = (absAmount * rates.XRPEUR).toFixed(2);
        }

        // Normalize asset name (XXRP -> XRP, USDT stays USDT)
        const normalizedAsset = w.asset.includes("XRP") || w.asset === "XXRP" ? "XRP" :
          w.asset.includes("USDT") ? "USDT" : w.asset;

        const record = {
          dateSent: formatTimestamp(w.time),
          timeSent: formatTime(w.time),
          entryDate: "",
          recipient: recipient,
          asset: normalizedAsset,
          amount: Math.abs(w.amount).toFixed(6),
          fee: Math.abs(w.fee).toFixed(6),
          balance: w.balance.toFixed(6),
          originalCurrency: gbpEquivalent ? "GBP" : (eurEquivalent ? "EUR" : ""),
          originalAmount: gbpEquivalent || eurEquivalent || "",
          gbpEquivalent: gbpEquivalent,
          destTag: destTag,
          wallet: walletAddr,
          txId: w.refid,
          matched: addrMatch ? "Yes" : "No"
        };

        stagingRecords.push(record);
      }

      localStorage.setItem("kraken_staging", JSON.stringify(stagingRecords));
      renderPreview();
      updateStatus("Ready", "active");
      logTrace("Report generated: " + stagingRecords.length + " records");
    }

    // Format unix timestamp to DD/MM/YYYY
    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const d = String(dt.getUTCDate()).padStart(2, "0");
      const m = String(dt.getUTCMonth() + 1).padStart(2, "0");
      const y = dt.getUTCFullYear();
      return d + "/" + m + "/" + y;
    }

    // Format unix timestamp to HH:MM:SS (UTC)
    function formatTime(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const h = String(dt.getUTCHours()).padStart(2, "0");
      const m = String(dt.getUTCMinutes()).padStart(2, "0");
      const s = String(dt.getUTCSeconds()).padStart(2, "0");
      return h + ":" + m + ":" + s;
    }

    // ---------- Boot ----------
    async function waitFor(cond, timeoutMs) {
      const t0 = Date.now();
      return new Promise((resolve, reject) => {
        const tick = () => {
          if (cond()) return resolve(true);
          if (Date.now() - t0 > timeoutMs) return reject(new Error("Timeout"));
          setTimeout(tick, 50);
        };
        tick();
      });
    }

    async function boot() {
      // Load saved staging
      const savedStaging = localStorage.getItem("kraken_staging");
      if (savedStaging) {
        try {
          stagingRecords = JSON.parse(savedStaging);
        } catch (e) { }
      }

      // Load cached data from localStorage (so Generate Report works without re-pulling)
      const savedWithdrawals = localStorage.getItem("kraken_v2_withdrawals");
      const savedAddresses = localStorage.getItem("kraken_v2_addresses");
      const savedHistory = localStorage.getItem("kraken_v2_history");
      const savedRates = localStorage.getItem("kraken_v2_rates");
      if (savedWithdrawals) cacheData.withdrawals = JSON.parse(savedWithdrawals);
      if (savedAddresses) cacheData.krakenAddresses = JSON.parse(savedAddresses);
      if (savedHistory) cacheData.withdrawalHistory = JSON.parse(savedHistory);
      if (savedRates) cacheData.ratesCache = JSON.parse(savedRates);

      renderPreview();
      updateStatusCounts();

      // Auto-load API credentials from localStorage
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxyType = localStorage.getItem("kraken_cors_proxy_type");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
      const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedProxyType) {
        document.getElementById("corsProxySelect").value = savedProxyType;
        if (savedProxyType === "custom" && savedProxy) {
          document.getElementById("corsProxy").value = savedProxy;
          document.getElementById("corsProxy").style.display = "block";
        }
      }
      if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
      if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;

      try {
        await waitFor(() => typeof gapi !== "undefined", 8000);
        gapiLoaded();
      } catch (_) {
        logTrace("GAPI not available.");
      }

      try {
        await waitFor(() => typeof google !== "undefined" && google.accounts && google.accounts.oauth2, 8000);
        gisLoaded();
      } catch (_) {
        logTrace("GIS not available.");
      }

      logTrace("v2.0 Ready. Set date range, then click 'Fetch & Generate Report'.");
    }

    window.addEventListener("load", boot);
  </script>
</body>

</html>