<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
  <title>Kraken Ledger Report v0.10</title>
  <script async defer src="https://accounts.google.com/gsi/client"></script>
  <script async defer src="https://apis.google.com/js/api.js"></script>
  <style>
    :root {
      --primary: #2c3e50;
      --accent: #27ae60;
      --danger: #c0392b;
      --bg: #f8f9fa;
      --bridge: #2980b9;
      --cache: #8e44ad;
      --kraken: #5741d9;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      margin: 0;
      padding: 10px;
    }

    .container {
      max-width: 960px;
      margin: auto;
      background: #fff;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .branding-row {
      margin-bottom: 10px;
      font-size: 1.1rem;
      line-height: 1.1;
      color: var(--primary);
    }

    .branding-row b {
      font-weight: 800;
    }

    .branding-row span {
      font-weight: 500;
      font-size: 0.75rem;
      color: #7f8c8d;
      margin-left: 6px;
    }

    .header-wrap {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
      gap: 8px;
    }

    .header-btns {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      width: 100%;
    }

    .btn-lookup {
      padding: 6px;
      font-size: 0.72rem;
      border-radius: 6px;
      border: none;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      flex: 1;
      height: 52px;
      line-height: 1.1;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }

    .btn-pull {
      background: var(--cache);
    }

    .btn-refresh {
      background: var(--bridge);
    }

    .btn-save {
      background: var(--accent);
    }

    .btn-reset {
      background: var(--danger);
    }

    label {
      font-size: 0.7rem;
      font-weight: 800;
      display: block;
      margin-bottom: 2px;
      color: var(--primary);
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      font-size: 16px;
      box-sizing: border-box;
      height: 38px;
      -webkit-text-size-adjust: 100%;
      font-family: inherit;
    }

    .date-input-container {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #fff;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      padding: 0 8px;
      height: 38px;
    }

    .date-input-container input[type="date"] {
      border: none;
      padding: 0;
      height: 100%;
      font-size: 14px;
      flex-grow: 1;
      outline: none;
      background: transparent;
    }

    .date-disp {
      font-size: 0.65rem;
      color: #7f8c8d;
      text-align: center;
      margin-top: 2px;
    }

    .status-row {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      padding: 10px;
      background: #f1f2f6;
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--primary);
    }

    .status-item {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .status-item b {
      font-weight: 800;
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      width: 100%;
      margin-top: 15px;
    }

    button.action-main {
      padding: 8px 10px;
      border: none;
      border-radius: 6px;
      font-weight: 900;
      cursor: pointer;
      color: #fff;
      font-size: 0.72rem;
      -webkit-font-smoothing: antialiased;
      min-height: 52px;
    }

    .preview-wrap {
      width: 100%;
      overflow-x: auto;
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    table {
      min-width: 1800px;
      width: 1800px;
      border-collapse: collapse;
      font-size: 0.58rem;
      table-layout: fixed;
      font-family: inherit;
    }

    th,
    td {
      border: 1px solid #eee;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    th {
      padding: 6px 4px;
    }

    td {
      padding: 2px 3px;
    }

    th {
      background: #f2f2f2;
      font-weight: 900 !important;
      color: var(--primary);
      font-size: 0.58rem !important;
    }

    /* Column widths */
    .w-date {
      width: 9ch;
    }

    .w-recipient {
      width: 14ch;
    }

    .w-asset {
      width: 6ch;
      text-align: center;
    }

    .w-amount {
      width: 10ch;
      text-align: right;
    }

    .w-cur {
      width: 5ch;
      text-align: center;
    }

    .w-gbp {
      width: 10ch;
      text-align: right;
    }

    .w-desttag {
      width: 10ch;
    }

    .w-wallet {
      width: 14ch;
    }

    .w-txid {
      width: 20ch;
    }

    .w-matched {
      width: 5ch;
      text-align: center;
    }

    .w-fee {
      width: 8ch;
      text-align: right;
    }

    .w-balance {
      width: 10ch;
      text-align: right;
    }

    #auth_status {
      font-size: 0.75rem;
      margin-top: 10px;
      text-align: center;
      color: var(--primary);
      font-weight: 800;
    }

    #log_btn {
      margin-top: 15px;
      width: 100%;
      background: var(--primary);
      color: #fff;
      font-size: 0.7rem;
      border-radius: 6px;
      padding: 8px;
      border: none;
      font-weight: 700;
      display: block;
    }

    #trace_log {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background: #2c3e50;
      color: #00ff00;
      font-family: "Courier New", monospace;
      font-size: 0.6rem;
      border-radius: 6px;
      max-height: 170px;
      overflow-y: auto;
      white-space: pre-wrap;
      cursor: pointer;
    }

    .ico {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--primary);
    }

    .cal-svg {
      width: 16px;
      height: 16px;
      display: block;
      fill: currentColor;
    }

    @media (max-width: 430px) {
      .actions {
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }

      button.action-main {
        min-height: 54px;
        padding: 8px 10px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header-wrap">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; position:relative;">
        <div class="branding-row" style="margin-bottom:0;"><b>Kraken Ledger Report</b> <span
            style="font-size:0.7rem; color:#7f8c8d; font-weight:600;">v2.0</span></div>
        <div id="auth_status"
          style="position:absolute; left:50%; transform:translateX(-50%); font-size:0.7rem; font-weight:700;">Status:
          Ready</div>
        <div style="display:flex; gap:4px;">
          <button class="btn-lookup" style="background:#27ae60; padding:4px 8px; height:auto; font-size:0.65rem;"
            onclick="toggleAddressViewer()">View<br />Addresses</button>
          <button class="btn-lookup" style="background:#34495e; padding:4px 8px; height:auto; font-size:0.65rem;"
            onclick="toggleApiConfig()">API<br />Config</button>
        </div>
      </div>

      <!-- Date Range (SET FIRST) -->
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
        <div>
          <label>Start Date</label>
          <div class="date-input-container" onclick="document.getElementById('startDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="startDate" onchange="handleDateChange('startDate')" type="date" />
          </div>
        </div>
        <div>
          <label>End Date</label>
          <div class="date-input-container" onclick="document.getElementById('endDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="endDate" onchange="handleDateChange('endDate')" type="date" />
          </div>
        </div>
      </div>

      <!-- Main Action Button -->
      <div style="margin-bottom:10px;">
        <button class="btn-lookup" style="background:var(--kraken); width:100%; height:52px; font-size:0.85rem;"
          onclick="fetchAndGenerateReport()">Fetch & Generate Report ✱</button>
        <div style="font-size:0.6rem; color:#7f8c8d; text-align:center; margin-top:2px;">✱ Requires 2FA</div>
      </div>
    </div>

    <!-- Kraken API Config (hidden by default) -->
    <div id="apiConfigSection"
      style="display:none; margin-bottom:15px; padding:10px; background:#f1f2f6; border-radius:6px;">
      <div style="font-size:0.7rem; font-weight:700; color:var(--primary); margin-bottom:6px;">Kraken API Credentials
      </div>
      <label>API Key</label>
      <input type="text" id="krakenApiKey" placeholder="API Key" style="margin-bottom:6px;">
      <label>Private Key</label>
      <input type="password" id="krakenPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:10px;">

      <label>CORS Proxy URL (optional)</label>
      <input type="text" id="corsProxy" placeholder="https://cors-anywhere.herokuapp.com/" value="">
      <div style="font-size:0.65rem; color:#7f8c8d; margin-top:4px;">Note: Browser security (CORS) blocks direct Kraken
        API calls. Use a CORS proxy or leave blank to try direct call.</div>

      <button onclick="saveApiConfig()"
        style="margin-top:10px; padding:8px 16px; background:var(--accent); color:#fff; border:none; border-radius:4px; cursor:pointer;">Save
        Credentials</button>
    </div>

    <!-- Address Viewer Panel (hidden by default) -->
    <div id="addressViewerSection"
      style="display:none; margin-bottom:15px; padding:10px; background:#e8f5e9; border-radius:6px; max-height:300px; overflow-y:auto;">
      <div style="font-size:0.75rem; font-weight:700; color:#27ae60; margin-bottom:8px;">Saved Withdrawal Addresses
      </div>
      <table id="addressTable" style="width:100%; font-size:0.65rem; border-collapse:collapse; table-layout:fixed;">
        <thead>
          <tr style="background:#c8e6c9; text-align:left;">
            <th style="padding:4px; border:1px solid #a5d6a7; width:45px;">Asset</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:130px;">Recipient</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:180px;">Key Name</th>
            <th style="padding:4px; border:1px solid #a5d6a7;">Address</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:70px;">Dest Tag</th>
          </tr>
        </thead>
        <tbody id="addressTableBody">
          <tr>
            <td colspan="5" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded yet.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Status Bar -->
    <div class="status-row">
      <div class="status-item"><span>Withdrawals:</span> <b id="withdrawalCount">0</b></div>
      <div class="status-item"><span>Addresses:</span> <b id="addressCount">0</b></div>
      <div class="status-item" id="stagingHint" style="flex:1; text-align:right; font-size:0.65rem; color:#7f8c8d;">
      </div>
    </div>

    <!-- Bottom Actions -->
    <div class="actions">
      <button class="action-main" id="sync_btn" onclick="handleSync()" style="background:var(--bridge);">Send
        Report<br />to Sheets</button>
      <button class="action-main" onclick="saveLocalData()" style="background:var(--accent);">Save<br />Local</button>
      <button class="action-main" onclick="loadLocalData()" style="background:#8e44ad;">Load<br />Local</button>
      <button class="action-main" id="wipeBtn" onclick="handleWipeConfirm()"
        style="background:var(--danger); opacity:0.85;">Clear</button>
    </div>

    <div class="preview-wrap" id="previewArea"></div>

    <button id="log_btn" onclick="toggleLog(true)">Display Trace Log</button>
    <div id="trace_log" onclick="toggleLog(false)">Trace: v2.0 Kraken Ledger Report initialized.</div>
  </div>

  <script>
    const SHEET_ID = "1Vf0iqthwHv0kFqTRJkYShH_RBpbokLmiEDWGJN3Q0_E";
    const VER = "Kraken Ledger Report (v1.03)";
    const KRAKEN_API_URL = "https://api.kraken.com";

    // Default API credentials (enter your own in API Config)
    const DEFAULT_API_KEY = "";
    const DEFAULT_PRIVATE_KEY = "";

    // Cache data structure (v2.0)
    let cacheData = {
      withdrawals: [],        // from Kraken Ledgers API (withdrawals only)
      withdrawalHistory: [],  // from Kraken WithdrawStatus API
      krakenAddresses: [],    // from Kraken WithdrawAddresses API
      ratesCache: {}          // { "2024-11-02": { USDTGBP: 0.79, USDTEUR: 0.92, ... } }
    };

    let stagingRecords = [];
    let tokenClient;
    let resetConfirmed = false;
    let wipeConfirmed = false;

    // ---------- Logging ----------
    function logTrace(msg) {
      const log = document.getElementById("trace_log");
      const now = new Date().toLocaleTimeString();
      const base = log.textContent && log.textContent.trim().length
        ? log.textContent
        : "Trace: v2.0 Kraken Ledger Report initialized.";
      log.textContent = base + "\n[" + now + "] " + msg;
      log.scrollTop = log.scrollHeight;
      console.log(msg);
    }

    window.onerror = function (message, source, lineno, colno) {
      logTrace("FATAL: " + message + " @ " + (source || "") + ":" + lineno + ":" + colno);
    };
    window.onunhandledrejection = function (ev) {
      logTrace("FATAL PROMISE: " + (ev && ev.reason ? (ev.reason.message || ev.reason) : "unknown"));
    };

    function toggleLog(show) {
      document.getElementById("log_btn").style.display = show ? "none" : "block";
      document.getElementById("trace_log").style.display = show ? "block" : "none";
    }

    function updateStatus(label, state) {
      const el = document.getElementById("auth_status");
      el.innerText = "Sync Status: " + label;
      const colors = { idle: "#7f8c8d", active: "#27ae60", sync: "#e67e22", error: "#c0392b" };
      el.style.color = colors[state] || colors.idle;
    }

    // ---------- Date Handling ----------
    function handleDateChange(id) {
      const dStr = document.getElementById(id).value;
      const dispEl = document.getElementById(id + "Disp");
      if (!dStr) { dispEl.innerText = ""; return; }
      const [y, m, d] = dStr.split("-").map(Number);
      const dt = new Date(y, m - 1, d);
      const day = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][dt.getDay()];
      const mon = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][dt.getMonth()];
      dispEl.innerText = day + " " + dt.getDate() + " " + mon + " '" + String(dt.getFullYear()).slice(-2);
    }

    // ---------- Reset / Wipe ----------
    function handleResetConfirm() {
      const btn = document.getElementById("resetBtn");
      if (!resetConfirmed) {
        resetConfirmed = true;
        btn.innerText = "CONFIRM?";
        setTimeout(() => { resetConfirmed = false; btn.innerText = "Reset"; }, 3000);
        return;
      }
      resetConfirmed = false;
      btn.innerText = "Reset";
      localReset();
    }

    function handleWipeConfirm() {
      const btn = document.getElementById("wipeBtn");
      if (!wipeConfirmed) {
        wipeConfirmed = true;
        btn.innerHTML = "CONFIRM?";
        setTimeout(() => { wipeConfirmed = false; btn.innerHTML = "Clear<br/>Staging"; }, 3000);
        return;
      }
      wipeConfirmed = false;
      btn.innerHTML = "Clear<br/>Staging";
      stagingRecords = [];
      localStorage.removeItem("kraken_staging");
      renderPreview();
      logTrace("Staging cleared manually.");
    }

    function localReset() {
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";
      updateStatusCounts();
      logTrace("UI Reset.");
    }

    // ---------- Status Display ----------
    function updateStatusCounts() {
      document.getElementById("withdrawalCount").innerText = cacheData.withdrawals.length;
      document.getElementById("addressCount").innerText = cacheData.krakenAddresses.length;
    }

    // ---------- Local Save/Load (v2.0) ----------
    function saveLocalData() {
      if (cacheData.withdrawals.length === 0) {
        alert("Fetch data first before saving.");
        return;
      }
      localStorage.setItem("kraken_v2_withdrawals", JSON.stringify(cacheData.withdrawals));
      localStorage.setItem("kraken_v2_history", JSON.stringify(cacheData.withdrawalHistory));
      localStorage.setItem("kraken_v2_addresses", JSON.stringify(cacheData.krakenAddresses));
      localStorage.setItem("kraken_v2_rates", JSON.stringify(cacheData.ratesCache));
      logTrace("Data saved to localStorage.");
      alert("Data saved to local storage.");
    }

    function loadLocalData() {
      const cached = localStorage.getItem("kraken_v2_withdrawals");
      if (!cached) {
        alert("No saved data found. Use 'Fetch & Generate Report' first.");
        return;
      }
      cacheData.withdrawals = JSON.parse(cached || "[]");
      cacheData.withdrawalHistory = JSON.parse(localStorage.getItem("kraken_v2_history") || "[]");
      cacheData.krakenAddresses = JSON.parse(localStorage.getItem("kraken_v2_addresses") || "[]");
      cacheData.ratesCache = JSON.parse(localStorage.getItem("kraken_v2_rates") || "{}");
      updateStatusCounts();
      logTrace("Loaded from localStorage. Withdrawals=" + cacheData.withdrawals.length);

      // Regenerate report from cached data
      generateReportFromCache();
    }

    function saveApiConfig() {
      const apiKey = document.getElementById("krakenApiKey").value;
      const privateKey = document.getElementById("krakenPrivateKey").value;
      const proxy = document.getElementById("corsProxy").value;
      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      localStorage.setItem("kraken_cors_proxy", proxy);
      logTrace("API credentials saved.");
      alert("Credentials saved.");
    }

    // ---------- Staging Table Render ----------
    function renderPreview() {
      const area = document.getElementById("previewArea");
      const hint = document.getElementById("stagingHint");
      if (!stagingRecords.length) {
        area.innerHTML = "";
        if (hint) hint.textContent = "No staging records. Click 'Generate Report' after loading data.";
        return;
      }
      if (hint) hint.textContent = stagingRecords.length + " staging record(s)";

      let html = '<table><thead><tr>';
      html += '<th class="w-date">Date</th>';
      html += '<th class="w-recipient">Recipient</th>';
      html += '<th class="w-asset">Asset</th>';
      html += '<th class="w-amount">Amount</th>';
      html += '<th class="w-fee">Fee</th>';
      html += '<th class="w-cur">Orig Cur</th>';
      html += '<th class="w-amount">Orig Amt</th>';
      html += '<th class="w-gbp">GBP Equiv</th>';
      html += '<th class="w-desttag">Dest Tag</th>';
      html += '<th class="w-wallet">Wallet</th>';
      html += '<th class="w-txid">TX ID</th>';
      html += '<th class="w-matched">Match</th>';
      html += '</tr></thead><tbody>';

      for (const r of stagingRecords) {
        html += '<tr>';
        html += '<td class="w-date">' + escHtml(r.dateSent) + '</td>';
        html += '<td class="w-recipient">' + escHtml(r.recipient) + '</td>';
        html += '<td class="w-asset">' + escHtml(r.asset) + '</td>';
        html += '<td class="w-amount">' + escHtml(r.amount) + '</td>';
        html += '<td class="w-fee">' + escHtml(r.fee) + '</td>';
        html += '<td class="w-cur">' + escHtml(r.originalCurrency) + '</td>';
        html += '<td class="w-amount">' + escHtml(r.originalAmount) + '</td>';
        html += '<td class="w-gbp">' + escHtml(r.gbpEquivalent) + '</td>';
        html += '<td class="w-desttag">' + escHtml(r.destTag) + '</td>';
        html += '<td class="w-wallet">' + escHtml(r.wallet) + '</td>';
        html += '<td class="w-txid">' + escHtml(r.txId) + '</td>';
        html += '<td class="w-matched" style="font-weight:800; color:' + (r.matched === 'Yes' ? 'var(--accent)' : 'var(--danger)') + '">' + escHtml(r.matched) + '</td>';
        html += '</tr>';
      }
      html += '</tbody></table>';
      area.innerHTML = html;
    }

    function escHtml(s) {
      if (s === null || s === undefined) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    // ---------- Report Generation ----------
    async function generateReport() {
      const startVal = document.getElementById("startDate").value;
      const endVal = document.getElementById("endDate").value;

      if (!startVal || !endVal) {
        alert("Please select both Start Date and End Date.");
        return;
      }

      if (cacheData.ledger.length === 0) {
        alert("No ledger data. Use 'Pull local Lookups' or 'Refresh Lookups from Sheets' first.");
        return;
      }

      const startTime = new Date(startVal + "T00:00:00").getTime() / 1000;
      const endTime = new Date(endVal + "T23:59:59").getTime() / 1000;
      const tolerance = cacheData.settings.tolerancePercent / 100;

      logTrace("Generating report. Start=" + startVal + " End=" + endVal + " Tolerance=" + (tolerance * 100) + "%");

      // Prompt for 2FA once to fetch withdrawal history
      let otp = null;
      const hasWithdrawCreds = document.getElementById("withdrawApiKey").value.trim() &&
        document.getElementById("withdrawPrivateKey").value.trim();

      if (hasWithdrawCreds) {
        otp = prompt("Enter your 2FA code for Kraken Withdrawal API (or Cancel to skip API lookup):");
        if (otp && otp.trim()) {
          updateStatus("Fetching withdrawal history...", "sync");
          try {
            await fetchWithdrawalHistory(otp.trim());
            logTrace("Withdrawal history fetched for matching.");
          } catch (e) {
            logTrace("Failed to fetch withdrawal history: " + e.message);
          }
        }
      }

      // STEP 1: Get USDT and XRP withdrawals only (exclude fiat GBP/EUR)
      const allWithdrawals = cacheData.ledger.filter(entry => {
        const entryType = (entry.type || "").toLowerCase();
        const asset = (entry.asset || "").toUpperCase();
        // Only include USDT (including TRC20) and XRP
        const isTarget = asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP";
        return entryType === "withdrawal" && isTarget;
      });
      logTrace("STEP 1: Found " + allWithdrawals.length + " USDT/XRP withdrawals in ledger.");

      // STEP 2: Parse times and filter by date range
      const withdrawals = [];
      for (const w of allWithdrawals) {
        const timeRaw = w.time;
        const timeParsed = parseDateString(timeRaw);

        // Show first withdrawal for debugging
        if (withdrawals.length === 0 && allWithdrawals.length > 0) {
          logTrace("STEP 2: First withdrawal - time raw='" + timeRaw + "' (typeof " + typeof timeRaw + ") parsed=" + timeParsed);
          if (timeParsed > 0) {
            logTrace("STEP 2: Parsed to " + new Date(timeParsed * 1000).toISOString());
          }
          logTrace("STEP 2: Date range check: " + startTime + " <= " + timeParsed + " <= " + endTime);
        }

        // Include if date is valid and within range (or if date is 0, include anyway to show in report)
        if (timeParsed === 0 || (timeParsed >= startTime && timeParsed <= endTime)) {
          withdrawals.push({ ...w, _parsedTime: timeParsed });
        }
      }
      logTrace("STEP 2: " + withdrawals.length + " withdrawals in date range (or with unparseable dates).");

      // Debug: show ledger sample BEFORE filtering
      if (cacheData.ledger.length > 0) {
        const sample = cacheData.ledger[0];
        logTrace("DEBUG: Ledger sample entry keys: " + Object.keys(sample).join(", "));
        logTrace("DEBUG: Ledger sample type field: '" + sample.type + "' time field: '" + sample.time + "' (typeof: " + typeof sample.time + ")");

        // Parse and show the sample time
        const sampleParsed = parseDateString(sample.time);
        logTrace("DEBUG: Sample parsed time: " + sampleParsed + " => " + new Date(sampleParsed * 1000).toISOString());

        // Count entries by type
        const typeCounts = {};
        for (const e of cacheData.ledger) {
          const t = (e.type || "unknown").toLowerCase();
          typeCounts[t] = (typeCounts[t] || 0) + 1;
        }
        logTrace("DEBUG: Ledger types: " + JSON.stringify(typeCounts));

        // Find one withdrawal and show its details
        const sampleWithdrawal = cacheData.ledger.find(e => (e.type || "").toLowerCase() === "withdrawal");
        if (sampleWithdrawal) {
          const wTime = parseDateString(sampleWithdrawal.time);
          logTrace("DEBUG: Sample withdrawal - time raw: '" + sampleWithdrawal.time + "' parsed: " + wTime + " => " + new Date(wTime * 1000).toISOString());
          logTrace("DEBUG: Comparison: " + startTime + " <= " + wTime + " <= " + endTime + " = " + (wTime >= startTime && wTime <= endTime));
        }
      }

      // Debug: show date range info
      if (cacheData.ledger.length > 0) {
        const allDates = cacheData.ledger.map(e => e.time || "").filter(t => t).sort();
        logTrace("DEBUG: Ledger date range (raw): " + allDates[0] + " to " + allDates[allDates.length - 1]);
        logTrace("DEBUG: Selected range: startTime=" + startTime + " endTime=" + endTime);
        logTrace("DEBUG: Selected range (ISO): " + new Date(startTime * 1000).toISOString() + " to " + new Date(endTime * 1000).toISOString());
      }

      // Debug: show withdrawal history info
      logTrace("DEBUG: Withdrawal history entries: " + (cacheData.withdrawalHistory || []).length);
      if ((cacheData.withdrawalHistory || []).length > 0) {
        const sample = cacheData.withdrawalHistory[0];
        logTrace("DEBUG: Sample history entry keys: " + Object.keys(sample).join(", "));
      }

      stagingRecords = [];

      for (const w of withdrawals) {
        // Ledger columns: txid, refid, time, type, subtype, aclass, subclass, asset, wallet, amount, fee, balance
        const txid = w.txid || "";
        const refid = w.refid || "";
        const wTime = parseDateString(w.time || "");
        const wType = w.type || "";
        const wAsset = w.asset || "";
        const wAmount = parseFloat(w.amount || 0);
        const wFee = parseFloat(w.fee || 0);
        const wBalance = parseFloat(w.balance || 0);

        // Find recipient - first try withdrawal history from API, then address lookups
        let recipient = "";
        let destTag = "";
        let walletAddr = "";

        // Try to find in withdrawal history from API (matched by refid)
        const historyMatch = (cacheData.withdrawalHistory || []).find(h => h.refid === refid);
        if (historyMatch) {
          walletAddr = historyMatch.info || historyMatch.address || "";
          destTag = historyMatch.dest || historyMatch.tag || "";

          // Find recipient from address lookups
          if (wAsset.includes("XRP") || wAsset === "XXRP") {
            const addrMatch = cacheData.destTags.find(d =>
              String(d.destTag) === destTag || String(d[1]) === destTag ||
              (d.address && d.address === walletAddr)
            );
            recipient = addrMatch ? (addrMatch.recipient || addrMatch[0] || "") : "";
          } else {
            const addrMatch = cacheData.wallets.find(d =>
              (d.address || d[2] || "") === walletAddr
            );
            recipient = addrMatch ? (addrMatch.recipient || addrMatch[0] || "") : "";
          }

          if (!recipient) {
            // Try to find by savedAddress key name in krakenAddresses
            const keyMatch = cacheData.krakenAddresses.find(a =>
              a.address === walletAddr || (a.tag && a.tag === destTag)
            );
            if (keyMatch) {
              recipient = (keyMatch.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim();
            }
          }

          logTrace("Matched refid " + refid.substring(0, 10) + "... to address " + walletAddr.substring(0, 15) + "... recipient: " + recipient);
        } else {
          // Fallback: try extracting from refid (old method - likely won't work)
          if (wAsset.includes("XRP") || wAsset === "XXRP") {
            destTag = extractDestTag(refid);
            const match = cacheData.destTags.find(d => String(d.destTag) === destTag || String(d[1]) === destTag);
            recipient = match ? (match.recipient || match[0] || "") : "";
          } else if (wAsset.includes("USDT")) {
            walletAddr = extractWallet(refid);
            const match = cacheData.wallets.find(d => (d.address || d[2] || "") === walletAddr);
            recipient = match ? (match.recipient || match[0] || "") : "";
          }
        }

        // Find matching trade (fuzzy)
        const trade = findMatchingTrade(wAmount, wTime, wAsset, tolerance);

        // Get exchange rates for GBP/EUR equivalent
        let originalCurrency = "";
        let originalAmount = "";
        let gbpEquivalent = "";

        // If trade matched, use trade data
        if (trade) {
          originalCurrency = extractFiatCurrency(trade);
          originalAmount = (parseFloat(trade.cost || trade[7] || 0)).toFixed(2);
          gbpEquivalent = calculateGBPEquivalent(trade);
        }

        // For fiat withdrawals (GBP, EUR, USD), show directly
        if (wAsset === "ZGBP" || wAsset === "GBP") {
          originalCurrency = "GBP";
          originalAmount = Math.abs(wAmount).toFixed(2);
          gbpEquivalent = Math.abs(wAmount).toFixed(2);
        } else if (wAsset === "ZEUR" || wAsset === "EUR") {
          originalCurrency = "EUR";
          originalAmount = Math.abs(wAmount).toFixed(2);
          gbpEquivalent = (Math.abs(wAmount) * 0.86).toFixed(2);
        } else if (wAsset === "ZUSD" || wAsset === "USD") {
          originalCurrency = "USD";
          originalAmount = Math.abs(wAmount).toFixed(2);
          gbpEquivalent = (Math.abs(wAmount) * 0.79).toFixed(2);
        } else {
          // For crypto (USDT, XRP), look up exchange rate from Kraken API
          try {
            const rates = await getKrakenRate(wAsset, wTime);
            const absAmount = Math.abs(wAmount);

            if (rates.gbpRate) {
              gbpEquivalent = (absAmount * rates.gbpRate).toFixed(2);
              originalCurrency = "GBP";
              originalAmount = gbpEquivalent;
            } else if (rates.eurRate) {
              originalCurrency = "EUR";
              originalAmount = (absAmount * rates.eurRate).toFixed(2);
              // Convert EUR to GBP
              gbpEquivalent = (parseFloat(originalAmount) * 0.86).toFixed(2);
            } else if (rates.usdRate) {
              originalCurrency = "USD";
              originalAmount = (absAmount * rates.usdRate).toFixed(2);
              gbpEquivalent = (parseFloat(originalAmount) * 0.79).toFixed(2);
            }

            logTrace("Rate for " + wAsset + ": GBP=" + rates.gbpRate + " EUR=" + rates.eurRate + " USD=" + rates.usdRate);
          } catch (e) {
            logTrace("Rate lookup failed for " + wAsset + ": " + e.message);
          }
        }

        const record = {
          dateSent: formatTimestamp(wTime),
          entryDate: trade ? formatTimestamp(parseDateString(trade.time || "")) : "",
          recipient: recipient,
          asset: wAsset,
          amount: wAmount.toFixed(6),
          fee: wFee.toFixed(6),
          balance: wBalance.toFixed(6),
          originalCurrency: originalCurrency,
          originalAmount: originalAmount,
          gbpEquivalent: gbpEquivalent,
          destTag: destTag,
          wallet: walletAddr,
          txId: refid,
          matched: trade ? "Yes" : "No"
        };

        stagingRecords.push(record);
      }

      localStorage.setItem("kraken_staging", JSON.stringify(stagingRecords));
      renderPreview();
      logTrace("Report generated. " + stagingRecords.length + " records in staging.");
      alert("Report generated: " + stagingRecords.length + " records.");
    }

    function findMatchingTrade(withdrawalAmount, withdrawalTime, asset, tolerance) {
      const absAmount = Math.abs(withdrawalAmount);

      // Filter trades that are BEFORE the withdrawal and for the same asset
      // Trades columns: txid, ordertxid, pair, aclass, subclass, time, type, ordertype, price, cost, fee, vol
      const candidates = cacheData.trades.filter(trade => {
        const tradeTime = parseDateString(trade.time || "");
        const tradePair = (trade.pair || "").toUpperCase();
        const assetNorm = asset.replace("X", "").replace("Z", "");
        return tradeTime < withdrawalTime && tradePair.includes(assetNorm);
      });

      // Sort by time descending (most recent first)
      candidates.sort((a, b) => {
        const tA = parseDateString(a.time || "");
        const tB = parseDateString(b.time || "");
        return tB - tA;
      });

      // Find first trade where vol ≈ withdrawal amount
      for (const trade of candidates) {
        const tradeVol = Math.abs(parseFloat(trade.vol || 0));
        const diff = Math.abs(tradeVol - absAmount) / absAmount;
        if (diff <= tolerance) {
          return trade;
        }
      }

      return null;
    }

    // Parse Kraken date strings like "2024-11-02 08:42:24" to Unix timestamp
    function parseDateString(dateStr) {
      try {
        if (!dateStr && dateStr !== 0) return 0;

        // If it's already a number, return it directly (Unix timestamp in seconds)
        if (typeof dateStr === "number") {
          if (isNaN(dateStr)) return 0;
          return dateStr;
        }

        // Convert to string for parsing
        const str = String(dateStr).trim();
        if (!str) return 0;

        // If it's a numeric string without dashes, could be Unix timestamp OR Excel serial date
        const numVal = parseFloat(str);
        if (!isNaN(numVal) && str.indexOf("-") === -1) {
          // Excel serial dates are small numbers (days since 1900-01-01)
          // A date in 2024 is around 45000 in Excel format
          // Unix timestamps in seconds for 2024 are around 1700000000
          if (numVal < 100000) {
            // This is likely an Excel serial date, convert to Unix timestamp
            // Excel epoch is 1900-01-01, but Excel incorrectly considers 1900 a leap year
            // So we adjust by subtracting 25569 (days between 1900-01-01 and 1970-01-01)
            // Then multiply by 86400 (seconds per day)
            const excelEpoch = (numVal - 25569) * 86400;
            logTrace("DEBUG: Converted Excel date " + numVal + " to Unix " + excelEpoch);
            return excelEpoch;
          }

          // If number is very large (> year 2100 in seconds), it's likely milliseconds
          if (numVal > 4102444800) {
            return numVal / 1000;
          }
          return numVal;
        }

        // Parse date string like "2024-11-02 08:42:24"
        const dt = new Date(str.replace(" ", "T"));
        const result = dt.getTime() / 1000;

        // Check for invalid date
        if (isNaN(result)) {
          logTrace("WARNING: Could not parse date: '" + str + "'");
          return 0;
        }

        return result;
      } catch (e) {
        logTrace("ERROR parsing date: " + e.message);
        return 0;
      }
    }

    function extractDestTag(refid) {
      // Destination tag often appears as a numeric suffix or can be parsed from description
      // For now, return empty - will need refinement based on actual data format
      const match = String(refid).match(/\d{6,}/);
      return match ? match[0] : "";
    }

    function extractWallet(refid) {
      // Wallet address extraction - placeholder
      return "";
    }

    function extractFiatCurrency(trade) {
      const pair = (trade.pair || "").toUpperCase();
      if (pair.includes("GBP") || pair.includes("ZGBP")) return "GBP";
      if (pair.includes("EUR") || pair.includes("ZEUR")) return "EUR";
      if (pair.includes("USD") || pair.includes("ZUSD")) return "USD";
      return "";
    }

    function calculateGBPEquivalent(trade) {
      const cost = parseFloat(trade.cost || 0);
      const cur = extractFiatCurrency(trade);
      if (cur === "GBP") return cost.toFixed(2);
      if (cur === "EUR") return (cost * 0.86).toFixed(2); // Approximate EUR→GBP
      if (cur === "USD") return (cost * 0.79).toFixed(2); // Approximate USD→GBP
      return cost.toFixed(2);
    }

    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const d = String(dt.getDate()).padStart(2, "0");
      const m = String(dt.getMonth() + 1).padStart(2, "0");
      const y = dt.getFullYear();
      return d + "/" + m + "/" + y;
    }

    // ---------- Google Auth / Sheets ----------
    function gapiLoaded() {
      gapi.load("client", async () => {
        await gapi.client.init({ apiKey: "AIzaSyDvZ1XZw5bZgWSB9zaU7h9Vtn7MhDGFMSM" });
        await gapi.client.load("sheets", "v4");
        logTrace("GAPI Ready.");
      });
    }

    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: "23231735212-jtgur3sn2ndh798ke00pm2a1d5rkd4eu.apps.googleusercontent.com",
        scope: "https://www.googleapis.com/auth/spreadsheets",
        callback: () => { }
      });
      logTrace("GIS Ready.");
    }

    function initRefresh() {
      requestToken(true, () => fetchAllSheets());
    }

    function requestToken(forcePrompt, onOk) {
      tokenClient.callback = (resp) => {
        if (!resp || !resp.access_token) return;
        const issuedAt = Date.now();
        const expiresIn = resp.expires_in ? Number(resp.expires_in) : 3600;
        localStorage.setItem("g_token", resp.access_token);
        localStorage.setItem("g_token_issued_at", String(issuedAt));
        localStorage.setItem("g_token_expires_in", String(expiresIn));
        gapi.client.setToken({ access_token: resp.access_token });
        onOk();
      };
      const args = forcePrompt ? { prompt: "consent" } : { prompt: "" };
      tokenClient.requestAccessToken(args);
    }

    function ensureTokenThen(onOk) {
      const tok = localStorage.getItem("g_token");
      const issuedAt = Number(localStorage.getItem("g_token_issued_at") || "0");
      const exp = Number(localStorage.getItem("g_token_expires_in") || "0");
      const age = (Date.now() - issuedAt) / 1000;

      if (tok && issuedAt && exp && age < (exp - 60)) {
        gapi.client.setToken({ access_token: tok });
        onOk();
        return;
      }
      requestToken(true, onOk);
    }

    async function fetchAllSheets() {
      updateStatus("Fetching data...", "sync");
      try {
        // Fetch Settings
        logTrace("Fetching Settings...");
        const settingsRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "Settings!A2:B10"
        });
        const settingsRows = settingsRes.result.values || [];
        for (const row of settingsRows) {
          if (row[0] === "TolerancePercent") {
            cacheData.settings.tolerancePercent = parseFloat(row[1]) || 2;
          }
        }

        // Fetch DEST_TAG
        logTrace("Fetching DEST_TAG...");
        const destTagRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "DEST_TAG!A2:B500"
        });
        cacheData.destTags = (destTagRes.result.values || []).map(r => ({
          recipient: r[0] || "",
          destTag: r[1] || ""
        }));

        // Fetch WALLET
        logTrace("Fetching WALLET...");
        const walletRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "WALLET!A2:C500"
        });
        cacheData.wallets = (walletRes.result.values || []).map(r => ({
          recipient: r[0] || "",
          asset: r[1] || "",
          address: r[2] || ""
        }));

        // Fetch csv-ledger
        // Columns: A:txid, B:refid, C:time, D:type, E:subtype, F:aclass, G:subclass, H:asset, I:wallet, J:amount, K:fee, L:balance
        logTrace("Fetching csv-ledger...");
        const ledgerRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "'csv-ledger'!A2:L5000"
        });
        cacheData.ledger = (ledgerRes.result.values || []).map(r => ({
          txid: r[0] || "",
          refid: r[1] || "",
          time: r[2] || "",
          type: r[3] || "",
          subtype: r[4] || "",
          aclass: r[5] || "",
          subclass: r[6] || "",
          asset: r[7] || "",
          wallet: r[8] || "",
          amount: r[9] || "",
          fee: r[10] || "",
          balance: r[11] || ""
        }));

        // Fetch csv-trades
        // Columns: A:txid, B:ordertxid, C:pair, D:aclass, E:subclass, F:time, G:type, H:ordertype, I:price, J:cost, K:fee, L:vol, M:margin, N:misc, O:ledgers
        logTrace("Fetching csv-trades...");
        const tradesRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "'csv-trades'!A2:O5000"
        });
        cacheData.trades = (tradesRes.result.values || []).map(r => ({
          txid: r[0] || "",
          ordertxid: r[1] || "",
          pair: r[2] || "",
          aclass: r[3] || "",
          subclass: r[4] || "",
          time: r[5] || "",
          type: r[6] || "",
          ordertype: r[7] || "",
          price: r[8] || "",
          cost: r[9] || "",
          fee: r[10] || "",
          vol: r[11] || "",
          margin: r[12] || "",
          misc: r[13] || "",
          ledgers: r[14] || ""
        }));

        updateStatusCounts();
        updateStatus("Token Active", "active");
        logTrace("Refresh complete. Ledger=" + cacheData.ledger.length + " Trades=" + cacheData.trades.length);
        alert("Refresh complete.\nLedger: " + cacheData.ledger.length + " records\nTrades: " + cacheData.trades.length + " records");

      } catch (e) {
        updateStatus("Error", "error");
        logTrace("Fetch error: " + (e.message || e));
        alert("Error fetching data. Check trace log.");
      }
    }

    async function handleSync() {
      if (!stagingRecords.length) {
        alert("No staging records to send.");
        return;
      }

      updateStatus("Syncing...", "sync");
      logTrace("Sync started. Rows=" + stagingRecords.length);

      ensureTokenThen(async () => {
        try {
          // Find first empty row in ReportStaging
          const meta = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SHEET_ID,
            range: "'ReportStaging'!A2:A"
          });
          const used = meta.result.values ? meta.result.values.length : 0;
          const startRow = 2 + used;

          // Prepare values
          const headers = [
            "Date Sent", "Entry Date", "Recipient", "Asset", "Amount", "Fee", "Balance",
            "Orig Cur", "Orig Amt", "GBP Equiv", "Dest Tag", "Wallet", "TX ID", "Matched", "Version"
          ];

          const vals = stagingRecords.map(r => [
            r.dateSent,
            r.entryDate,
            r.recipient,
            r.asset,
            r.amount,
            r.fee,
            r.balance,
            r.originalCurrency,
            r.originalAmount,
            r.gbpEquivalent,
            r.destTag,
            r.wallet,
            r.txId,
            r.matched,
            VER
          ]);

          // If sheet is empty, add headers first
          if (startRow === 2) {
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: SHEET_ID,
              range: "'ReportStaging'!A1:O1",
              valueInputOption: "USER_ENTERED",
              resource: { values: [headers] }
            });
          }

          await gapi.client.sheets.spreadsheets.values.update({
            spreadsheetId: SHEET_ID,
            range: "'ReportStaging'!A" + startRow + ":O" + (startRow + vals.length - 1),
            valueInputOption: "USER_ENTERED",
            resource: { values: vals }
          });

          updateStatus("Token Active", "active");
          logTrace("Sync complete. StartRow=" + startRow);
          alert("Sync completed. " + vals.length + " records sent to ReportStaging.");

        } catch (e) {
          updateStatus("Sync error", "error");
          logTrace("Sync error: " + (e.message || e));
          alert("Sync failed. Check trace log.");
        }
      });
    }

    // ---------- Address Viewer ----------
    function toggleAddressViewer() {
      const section = document.getElementById("addressViewerSection");
      section.style.display = section.style.display === "none" ? "block" : "none";
      if (section.style.display === "block") {
        renderAddressTable();
      }
    }

    function renderAddressTable() {
      const tbody = document.getElementById("addressTableBody");
      const addresses = cacheData.krakenAddresses || [];

      if (addresses.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded. Click "Fetch Addresses" first.</td></tr>';
        return;
      }

      // Sort by Asset, then Recipient, then Key Name
      const sorted = [...addresses].sort((a, b) => {
        const assetA = (a.asset || "").toUpperCase();
        const assetB = (b.asset || "").toUpperCase();
        if (assetA !== assetB) return assetA.localeCompare(assetB);

        const recipA = (a.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        const recipB = (b.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        if (recipA !== recipB) return recipA.localeCompare(recipB);

        return (a.key || "").localeCompare(b.key || "");
      });

      let html = "";
      for (const addr of sorted) {
        const asset = escHtml(addr.asset || "");
        const keyName = escHtml(addr.key || "");
        const recipient = escHtml((addr.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim());
        const address = escHtml(addr.address || "");
        const destTag = escHtml(addr.tag || addr.memo || "");

        html += '<tr style="border-bottom:1px solid #e0e0e0;">';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:45px; font-size:0.6rem;">' + asset + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:150px; max-width:150px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + recipient + '">' + recipient + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:200px; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + keyName + '">' + keyName + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; font-family:monospace; font-size:0.5rem; word-break:break-all;" title="' + address + '">' + address + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:70px; font-size:0.6rem;">' + destTag + '</td>';
        html += '</tr>';
      }

      tbody.innerHTML = html;
    }

    // ---------- Kraken API ----------
    function toggleApiConfig() {
      const section = document.getElementById("apiConfigSection");
      section.style.display = section.style.display === "none" ? "block" : "none";
      // Load saved credentials
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
      const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedProxy) document.getElementById("corsProxy").value = savedProxy;
      if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
      if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;
    }

    function getApiCredentials() {
      let apiKey = document.getElementById("krakenApiKey").value.trim();
      let privateKey = document.getElementById("krakenPrivateKey").value.trim();
      if (!apiKey) apiKey = DEFAULT_API_KEY;
      if (!privateKey) privateKey = DEFAULT_PRIVATE_KEY;
      // Save for next time
      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      const proxy = document.getElementById("corsProxy").value.trim();
      localStorage.setItem("kraken_cors_proxy", proxy);
      return { apiKey, privateKey, proxy };
    }

    // Use same credentials for all Kraken API calls (v2.0 - single key pair)
    function getWithdrawCredentials() {
      return getApiCredentials();
    }

    // Base64 helpers
    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    // Kraken API signature generation using Web Crypto API
    async function createKrakenSignature(urlPath, postData, privateKeyBase64) {
      const encoder = new TextEncoder();

      // Step 1: Get nonce from postData
      const params = new URLSearchParams(postData);
      const nonce = params.get("nonce");

      // Step 2: SHA256 hash of (nonce + postData)
      const sha256Data = encoder.encode(nonce + postData);
      const sha256Hash = await crypto.subtle.digest("SHA-256", sha256Data);

      // Step 3: Concatenate urlPath bytes + sha256Hash bytes
      const pathBytes = encoder.encode(urlPath);
      const combined = new Uint8Array(pathBytes.length + sha256Hash.byteLength);
      combined.set(pathBytes, 0);
      combined.set(new Uint8Array(sha256Hash), pathBytes.length);

      // Step 4: HMAC-SHA512 with decoded private key
      const privateKeyBytes = base64ToArrayBuffer(privateKeyBase64);
      const hmacKey = await crypto.subtle.importKey(
        "raw",
        privateKeyBytes,
        { name: "HMAC", hash: "SHA-512" },
        false,
        ["sign"]
      );

      const signature = await crypto.subtle.sign("HMAC", hmacKey, combined);

      // Step 5: Base64 encode the signature
      return arrayBufferToBase64(signature);
    }

    async function callKrakenPrivateAPI(endpoint, params = {}, credentials = null) {
      const { apiKey, privateKey, proxy } = credentials || getApiCredentials();
      const urlPath = "/0/private/" + endpoint;
      const nonce = Date.now().toString();

      const postParams = new URLSearchParams({ nonce, ...params });
      const postData = postParams.toString();

      try {
        const signature = await createKrakenSignature(urlPath, postData, privateKey);

        const url = (proxy ? proxy : "") + KRAKEN_API_URL + urlPath;

        logTrace("Calling Kraken API: " + endpoint + " (with OTP: " + (params.otp ? "yes" : "no") + ")");

        const response = await fetch(url, {
          method: "POST",
          headers: {
            "API-Key": apiKey,
            "API-Sign": signature,
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: postData
        });

        if (!response.ok) {
          throw new Error("HTTP " + response.status + ": " + response.statusText);
        }

        const data = await response.json();

        if (data.error && data.error.length > 0) {
          throw new Error("Kraken API Error: " + data.error.join(", "));
        }

        return data.result;

      } catch (e) {
        if (e.message.includes("Failed to fetch") || e.message.includes("NetworkError")) {
          logTrace("CORS blocked. Try using a CORS proxy in API Config.");
          throw new Error("CORS blocked. Please configure a CORS proxy in API Config.");
        }
        throw e;
      }
    }

    async function fetchKrakenAddresses() {
      logTrace("Fetching Kraken withdrawal addresses...");

      try {
        // Get withdrawal-specific credentials
        const withdrawCreds = getWithdrawCredentials();

        // Prompt for 2FA code
        const otp = prompt("Enter your 2FA code for Kraken Withdrawal API:");
        if (!otp || otp.trim() === "") {
          logTrace("2FA cancelled by user");
          updateStatus("Cancelled", "idle");
          return;
        }

        updateStatus("Fetching Kraken...", "sync");

        // Fetch all withdrawal addresses using withdrawal API key with 2FA
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, withdrawCreds);

        logTrace("Kraken WithdrawAddresses response: " + JSON.stringify(addresses).substring(0, 500));

        // addresses is an array of address objects
        cacheData.krakenAddresses = addresses || [];

        // Parse into destTags (XRP) and wallets (USDT/others)
        const newDestTags = [];
        const newWallets = [];

        for (const addr of cacheData.krakenAddresses) {
          // addr structure: { address, asset, key, memo, method, new, tag, verified }
          const keyName = addr.key || "";  // This is the saved address name (e.g., "Aleksey XRP")
          const asset = addr.asset || "";
          const address = addr.address || "";
          const destTag = addr.tag || addr.memo || "";  // XRP uses tag, others might use memo

          // Try to extract recipient name from key (e.g., "Aleksey XRP" -> "Aleksey")
          const recipientName = keyName.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim() || keyName;

          if (asset.toUpperCase().includes("XRP") || asset === "XXRP") {
            newDestTags.push({
              recipient: recipientName,
              destTag: destTag,
              address: address,
              keyName: keyName,
              asset: asset
            });
          } else {
            newWallets.push({
              recipient: recipientName,
              asset: asset,
              address: address,
              keyName: keyName
            });
          }
        }

        // Merge with existing data (don't overwrite if already have data)
        if (newDestTags.length > 0) {
          cacheData.destTags = newDestTags;
          logTrace("Found " + newDestTags.length + " XRP addresses with destination tags.");
        }
        if (newWallets.length > 0) {
          cacheData.wallets = newWallets;
          logTrace("Found " + newWallets.length + " other wallet addresses (USDT, etc.).");
        }

        updateStatusCounts();
        updateStatus("Kraken OK", "active");

        const summary = "Fetched " + cacheData.krakenAddresses.length + " addresses.\n" +
          "XRP (with dest tags): " + newDestTags.length + "\n" +
          "Other wallets: " + newWallets.length;
        alert(summary);
        logTrace(summary.replace(/\n/g, " | "));

      } catch (e) {
        updateStatus("Kraken Error", "error");
        logTrace("Kraken API error: " + (e.message || e));
        alert("Kraken API Error:\n" + (e.message || e) + "\n\nCheck trace log for details.");
      }
    }

    // Fetch withdrawal history with destination details
    async function fetchWithdrawalHistory(otp) {
      const withdrawCreds = getWithdrawCredentials();

      // Try both USDT and XRP (common assets for withdrawals)
      const assets = ["USDT", "XXRP", "ZUSD", "ZGBP"];
      const allWithdrawals = [];

      for (const asset of assets) {
        try {
          logTrace("Fetching withdrawal history for " + asset + "...");
          const params = otp ? { asset, otp } : { asset };
          const result = await callKrakenPrivateAPI("WithdrawStatus", params, withdrawCreds);

          if (Array.isArray(result)) {
            for (const w of result) {
              allWithdrawals.push({
                ...w,
                queriedAsset: asset
              });
            }
            logTrace("Found " + result.length + " withdrawals for " + asset);
          }
        } catch (e) {
          logTrace("WithdrawStatus for " + asset + ": " + (e.message || "error"));
        }
      }

      cacheData.withdrawalHistory = allWithdrawals;
      logTrace("Total withdrawal history entries: " + allWithdrawals.length);
      return allWithdrawals;
    }

    // Get historical exchange rate from Kraken public API
    // Returns { gbpRate, eurRate } for the given asset at the given timestamp
    async function getKrakenRate(asset, timestamp) {
      // Map Kraken asset names to pair names
      const assetMap = {
        "XXRP": "XRP", "XRP": "XRP",
        "USDT": "USDT", "USDTTRC20": "USDT",
        "XXBT": "XBT", "XBT": "XBT",
        "XETH": "ETH", "ETH": "ETH",
        "ZUSD": "USD", "USD": "USD"
      };

      const baseAsset = assetMap[asset] || asset.replace(/^X|^Z/, "");
      const rates = { gbpRate: null, eurRate: null, usdRate: null };

      // Try GBP pair first
      const pairs = [
        { pair: baseAsset + "GBP", target: "gbpRate" },
        { pair: baseAsset + "EUR", target: "eurRate" },
        { pair: baseAsset + "USD", target: "usdRate" }
      ];

      const proxy = document.getElementById("corsProxy").value.trim() || "";
      const ohlcUrl = proxy + "https://api.kraken.com/0/public/OHLC";

      for (const { pair, target } of pairs) {
        try {
          // Get OHLC data for the day (1440 = daily interval)
          const url = ohlcUrl + "?pair=" + pair + "&interval=60&since=" + Math.floor(timestamp - 3600);
          const response = await fetch(url);
          const data = await response.json();

          if (data.result && Object.keys(data.result).length > 0) {
            const pairData = Object.values(data.result).find(v => Array.isArray(v));
            if (pairData && pairData.length > 0) {
              // Find the candle closest to our timestamp
              let closest = pairData[0];
              for (const candle of pairData) {
                if (Math.abs(candle[0] - timestamp) < Math.abs(closest[0] - timestamp)) {
                  closest = candle;
                }
              }
              // Candle format: [time, open, high, low, close, vwap, volume, count]
              rates[target] = parseFloat(closest[4]); // close price
            }
          }
        } catch (e) {
          // Pair might not exist, continue
        }
      }

      return rates;
    }

    // ========== MAIN FUNCTION: Fetch & Generate Report (v2.0) ==========
    async function fetchAndGenerateReport() {
      // Step 0: Validate date range
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;

      if (!startDate || !endDate) {
        alert("Please select Start Date and End Date first.");
        return;
      }

      const startTime = new Date(startDate).getTime() / 1000;
      const endTime = new Date(endDate + "T23:59:59").getTime() / 1000;

      logTrace("Date range: " + startDate + " to " + endDate);
      logTrace("Unix range: " + startTime + " to " + endTime);

      // Step 1: Prompt for 2FA
      const otp = prompt("Enter your Kraken 2FA code:");
      if (!otp || otp.trim() === "") {
        logTrace("2FA cancelled by user");
        return;
      }

      try {
        const creds = getApiCredentials();
        updateStatus("Fetching...", "sync");

        // Step 2: Call Kraken Ledgers API for withdrawals
        logTrace("Calling Kraken Ledgers API...");
        const ledgerResult = await callKrakenPrivateAPI("Ledgers", {
          type: "withdrawal",
          start: Math.floor(startTime),
          end: Math.floor(endTime),
          otp: otp.trim()
        }, creds);

        // ledgerResult is { ledger_id: { refid, time, type, subtype, aclass, asset, amount, fee, balance } }
        const allWithdrawals = [];
        for (const [ledgerId, entry] of Object.entries(ledgerResult.ledger || ledgerResult || {})) {
          const asset = (entry.asset || "").toUpperCase();
          // Filter to USDT and XRP only
          if (asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP") {
            allWithdrawals.push({
              ledgerId,
              refid: entry.refid,
              time: entry.time,
              asset: asset,
              amount: parseFloat(entry.amount || 0),
              fee: parseFloat(entry.fee || 0),
              balance: parseFloat(entry.balance || 0)
            });
          }
        }

        cacheData.withdrawals = allWithdrawals;
        logTrace("Fetched " + allWithdrawals.length + " USDT/XRP withdrawals from Ledgers API");

        // Step 3: Call WithdrawStatus for destination details
        logTrace("Fetching withdrawal details...");
        await fetchWithdrawalHistory(otp.trim());

        // Step 4: Call WithdrawAddresses for recipient names
        logTrace("Fetching saved addresses...");
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, creds);
        cacheData.krakenAddresses = addresses || [];
        logTrace("Fetched " + cacheData.krakenAddresses.length + " saved addresses");

        updateStatusCounts();

        // Step 5: Generate report from fetched data
        await generateReportFromCache();

        updateStatus("Ready", "active");

      } catch (e) {
        updateStatus("Error", "error");
        logTrace("Error: " + (e.message || e));
        alert("Error: " + (e.message || e));
      }
    }

    // Generate report from cached data (no API calls except for rates)
    async function generateReportFromCache() {
      if (cacheData.withdrawals.length === 0) {
        alert("No withdrawal data. Please Fetch first.");
        return;
      }

      updateStatus("Generating...", "sync");
      logTrace("Generating report from " + cacheData.withdrawals.length + " withdrawals...");

      stagingRecords = [];

      // Step 1: Collect unique dates for batch rate lookup
      const uniqueDates = new Set();
      for (const w of cacheData.withdrawals) {
        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        uniqueDates.add(dateStr);
      }
      logTrace("Unique dates: " + Array.from(uniqueDates).join(", "));

      // Step 2: Batch fetch rates for each unique date
      const ratesToFetch = [];
      for (const dateStr of uniqueDates) {
        const timestamp = new Date(dateStr).getTime() / 1000 + 43200; // noon
        if (!cacheData.ratesCache[dateStr]) {
          ratesToFetch.push({ dateStr, timestamp });
        }
      }

      if (ratesToFetch.length > 0) {
        logTrace("Fetching rates for " + ratesToFetch.length + " dates...");
        updateStatus("Fetching rates...", "sync");

        for (const { dateStr, timestamp } of ratesToFetch) {
          // Fetch all 4 pairs for this date
          const usdtRates = await getKrakenRate("USDT", timestamp);
          const xrpRates = await getKrakenRate("XRP", timestamp);

          cacheData.ratesCache[dateStr] = {
            USDTGBP: usdtRates.gbpRate,
            USDTEUR: usdtRates.eurRate,
            XRPGBP: xrpRates.gbpRate,
            XRPEUR: xrpRates.eurRate
          };
          logTrace("Rates for " + dateStr + ": USDTGBP=" + usdtRates.gbpRate + ", XRPGBP=" + xrpRates.gbpRate);
        }
      }

      // Step 3: Build records
      for (const w of cacheData.withdrawals) {
        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        const rates = cacheData.ratesCache[dateStr] || {};

        // Find matching withdrawal in history (for address/tag)
        const historyMatch = cacheData.withdrawalHistory.find(h => h.refid === w.refid);

        // Get address and destination tag
        let walletAddr = historyMatch ? (historyMatch.info || historyMatch.address || "") : "";
        let destTag = historyMatch ? (historyMatch.dest || historyMatch.tag || "") : "";

        // Find recipient from krakenAddresses
        let recipient = "";
        const addrMatch = cacheData.krakenAddresses.find(a =>
          a.address === walletAddr || (a.tag && a.tag === destTag)
        );
        if (addrMatch) {
          recipient = (addrMatch.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20)\\s*/gi, "").trim();
        }

        // Calculate GBP equivalent
        let gbpEquivalent = "";
        let eurEquivalent = "";
        const absAmount = Math.abs(w.amount);

        if (w.asset.includes("USDT")) {
          if (rates.USDTGBP) gbpEquivalent = (absAmount * rates.USDTGBP).toFixed(2);
          if (rates.USDTEUR) eurEquivalent = (absAmount * rates.USDTEUR).toFixed(2);
        } else if (w.asset.includes("XRP") || w.asset === "XXRP") {
          if (rates.XRPGBP) gbpEquivalent = (absAmount * rates.XRPGBP).toFixed(2);
          if (rates.XRPEUR) eurEquivalent = (absAmount * rates.XRPEUR).toFixed(2);
        }

        const record = {
          dateSent: formatTimestamp(w.time),
          entryDate: "",
          recipient: recipient,
          asset: w.asset,
          amount: w.amount.toFixed(6),
          fee: w.fee.toFixed(6),
          balance: w.balance.toFixed(6),
          originalCurrency: gbpEquivalent ? "GBP" : (eurEquivalent ? "EUR" : ""),
          originalAmount: gbpEquivalent || eurEquivalent || "",
          gbpEquivalent: gbpEquivalent,
          destTag: destTag,
          wallet: walletAddr,
          txId: w.refid,
          matched: addrMatch ? "Yes" : "No"
        };

        stagingRecords.push(record);
      }

      localStorage.setItem("kraken_staging", JSON.stringify(stagingRecords));
      renderPreview();
      updateStatus("Ready", "active");
      logTrace("Report generated: " + stagingRecords.length + " records");
    }

    // Format unix timestamp to DD/MM/YYYY
    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const d = String(dt.getDate()).padStart(2, "0");
      const m = String(dt.getMonth() + 1).padStart(2, "0");
      const y = dt.getFullYear();
      return d + "/" + m + "/" + y;
    }

    // ---------- Boot ----------
    async function waitFor(cond, timeoutMs) {
      const t0 = Date.now();
      return new Promise((resolve, reject) => {
        const tick = () => {
          if (cond()) return resolve(true);
          if (Date.now() - t0 > timeoutMs) return reject(new Error("Timeout"));
          setTimeout(tick, 50);
        };
        tick();
      });
    }

    async function boot() {
      // Load saved staging
      const savedStaging = localStorage.getItem("kraken_staging");
      if (savedStaging) {
        try {
          stagingRecords = JSON.parse(savedStaging);
        } catch (e) { }
      }
      renderPreview();
      updateStatusCounts();

      // Auto-load API credentials from localStorage
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedProxy) document.getElementById("corsProxy").value = savedProxy;

      try {
        await waitFor(() => typeof gapi !== "undefined", 8000);
        gapiLoaded();
      } catch (_) {
        logTrace("GAPI not available.");
      }

      try {
        await waitFor(() => typeof google !== "undefined" && google.accounts && google.accounts.oauth2, 8000);
        gisLoaded();
      } catch (_) {
        logTrace("GIS not available.");
      }

      logTrace("v2.0 Ready. Set date range, then click 'Fetch & Generate Report'.");
    }

    window.addEventListener("load", boot);
  </script>
</body>

</html>