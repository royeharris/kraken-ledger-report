<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
  <title>Kraken Ledger Report v0.10</title>
  <script async defer src="https://accounts.google.com/gsi/client"></script>
  <script async defer src="https://apis.google.com/js/api.js"></script>
  <style>
    :root {
      --primary: #2c3e50;
      --accent: #27ae60;
      --danger: #c0392b;
      --bg: #f8f9fa;
      --bridge: #2980b9;
      --cache: #8e44ad;
      --kraken: #5741d9;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      margin: 0;
      padding: 10px;
    }

    .container {
      max-width: 960px;
      margin: auto;
      background: #fff;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .branding-row {
      margin-bottom: 10px;
      font-size: 1.1rem;
      line-height: 1.1;
      color: var(--primary);
    }

    .branding-row b {
      font-weight: 800;
    }

    .branding-row span {
      font-weight: 500;
      font-size: 0.75rem;
      color: #7f8c8d;
      margin-left: 6px;
    }

    .header-wrap {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
      gap: 8px;
    }

    .header-btns {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      width: 100%;
    }

    .btn-lookup {
      padding: 6px;
      font-size: 0.72rem;
      border-radius: 6px;
      border: none;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      flex: 1;
      height: 52px;
      line-height: 1.1;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }

    .btn-pull {
      background: var(--cache);
    }

    .btn-refresh {
      background: var(--bridge);
    }

    .btn-save {
      background: var(--accent);
    }

    .btn-reset {
      background: var(--danger);
    }

    label {
      font-size: 0.7rem;
      font-weight: 800;
      display: block;
      margin-bottom: 2px;
      color: var(--primary);
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      font-size: 16px;
      box-sizing: border-box;
      height: 38px;
      -webkit-text-size-adjust: 100%;
      font-family: inherit;
    }

    .date-input-container {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #fff;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      padding: 0 8px;
      height: 38px;
    }

    .date-input-container input[type="date"] {
      border: none;
      padding: 0;
      height: 100%;
      font-size: 14px;
      flex-grow: 1;
      outline: none;
      background: transparent;
    }

    .date-disp {
      font-size: 0.65rem;
      color: #7f8c8d;
      text-align: center;
      margin-top: 2px;
    }

    .status-row {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      padding: 10px;
      background: #f1f2f6;
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--primary);
    }

    .status-item {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .status-item b {
      font-weight: 800;
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      width: 100%;
      margin-top: 15px;
    }

    button.action-main {
      padding: 8px 10px;
      border: none;
      border-radius: 6px;
      font-weight: 900;
      cursor: pointer;
      color: #fff;
      font-size: 0.72rem;
      -webkit-font-smoothing: antialiased;
      min-height: 52px;
    }

    .preview-wrap {
      width: 100%;
      overflow-x: auto;
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    table {
      min-width: 1800px;
      width: 1800px;
      border-collapse: collapse;
      font-size: 0.58rem;
      table-layout: fixed;
      font-family: inherit;
    }

    th,
    td {
      border: 1px solid #eee;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    th {
      padding: 6px 4px;
    }

    td {
      padding: 2px 3px;
    }

    th {
      background: #f2f2f2;
      font-weight: 900 !important;
      color: var(--primary);
      font-size: 0.58rem !important;
    }

    /* Column widths */
    .w-date {
      width: 9ch;
    }

    .w-recipient {
      width: 14ch;
    }

    .w-asset {
      width: 6ch;
      text-align: center;
    }

    .w-amount {
      width: 10ch;
      text-align: right;
    }

    .w-cur {
      width: 5ch;
      text-align: center;
    }

    .w-gbp {
      width: 10ch;
      text-align: right;
    }

    .w-desttag {
      width: 10ch;
    }

    .w-wallet {
      width: 14ch;
    }

    .w-txid {
      width: 20ch;
    }

    .w-matched {
      width: 5ch;
      text-align: center;
    }

    .w-fee {
      width: 8ch;
      text-align: right;
    }

    .w-balance {
      width: 10ch;
      text-align: right;
    }

    #auth_status {
      font-size: 0.75rem;
      margin-top: 10px;
      text-align: center;
      color: var(--primary);
      font-weight: 800;
    }

    #log_btn {
      margin-top: 15px;
      width: 100%;
      background: var(--primary);
      color: #fff;
      font-size: 0.7rem;
      border-radius: 6px;
      padding: 8px;
      border: none;
      font-weight: 700;
      display: block;
    }

    #trace_log {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background: #2c3e50;
      color: #00ff00;
      font-family: "Courier New", monospace;
      font-size: 0.6rem;
      border-radius: 6px;
      max-height: 170px;
      overflow-y: auto;
      white-space: pre-wrap;
      cursor: pointer;
    }

    .ico {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--primary);
    }

    .cal-svg {
      width: 16px;
      height: 16px;
      display: block;
      fill: currentColor;
    }

    @media (max-width: 430px) {
      .actions {
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }

      button.action-main {
        min-height: 54px;
        padding: 8px 10px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header-wrap">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; position:relative;">
        <div class="branding-row" style="margin-bottom:0;"><b>Kraken Ledger Report</b></div>
        <span
          style="position:absolute; left:50%; transform:translateX(-50%); font-size:0.7rem; color:#7f8c8d; font-weight:600;">v0.11</span>
        <div style="display:flex; gap:4px;">
          <button class="btn-lookup" style="background:var(--kraken); padding:4px 8px; height:auto; font-size:0.65rem;"
            onclick="fetchKrakenAddresses()">Fetch<br />Addresses</button>
          <button class="btn-lookup" style="background:#34495e; padding:4px 8px; height:auto; font-size:0.65rem;"
            onclick="toggleApiConfig()">API<br />Config</button>
        </div>
      </div>
      <div class="header-btns">
        <button class="btn-lookup btn-pull" onclick="cachePull()">Pull local<br />Lookups</button>
        <button class="btn-lookup btn-refresh" id="refresh_btn" onclick="initRefresh()">Refresh<br />Lookups<br />from
          Sheets</button>
        <button class="btn-lookup btn-save" onclick="cacheSave()">Save to<br />local Lookups</button>
        <button class="btn-lookup btn-reset" id="resetBtn" onclick="handleResetConfirm()">Reset</button>
      </div>
    </div>

    <!-- Kraken API Config (hidden by default) -->
    <div id="apiConfigSection"
      style="display:none; margin-bottom:15px; padding:10px; background:#f1f2f6; border-radius:6px;">
      <label>Kraken API Key</label>
      <input type="text" id="krakenApiKey" placeholder="API Key" style="margin-bottom:6px;">
      <label>Kraken Private Key</label>
      <input type="password" id="krakenPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:6px;">
      <label>CORS Proxy URL (optional)</label>
      <input type="text" id="corsProxy" placeholder="https://cors-anywhere.herokuapp.com/" value="">
      <div style="font-size:0.65rem; color:#7f8c8d; margin-top:4px;">Note: Browser security (CORS) blocks direct Kraken
        API calls. Use a CORS proxy or leave blank to try direct call.</div>
    </div>

    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
      <div>
        <label>Start Date</label>
        <div class="date-input-container" onclick="document.getElementById('startDate').showPicker()">
          <span class="ico" aria-hidden="true">
            <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
              </path>
            </svg>
          </span><input id="startDate" onchange="handleDateChange('startDate')" type="date" />
        </div>
        <div id="startDateDisp" class="date-disp"></div>
      </div>
      <div>
        <label>End Date</label>
        <div class="date-input-container" onclick="document.getElementById('endDate').showPicker()">
          <span class="ico" aria-hidden="true">
            <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
              </path>
            </svg>
          </span><input id="endDate" onchange="handleDateChange('endDate')" type="date" />
        </div>
        <div id="endDateDisp" class="date-disp"></div>
      </div>
    </div>

    <div class="status-row">
      <div class="status-item"><span>Ledger:</span> <b id="ledgerCount">0</b> <span>records</span></div>
      <div class="status-item"><span>Trades:</span> <b id="tradesCount">0</b> <span>records</span></div>
      <div class="status-item"><span>Recipients:</span> <b id="recipientCount">0</b></div>
      <div class="status-item"><span>Tolerance:</span> <b id="toleranceDisp">2</b>%</div>
    </div>

    <div class="actions">
      <button class="action-main" onclick="generateReport()" style="background:var(--kraken);">Generate Report</button>
      <button class="action-main" id="sync_btn" onclick="handleSync()" style="background:var(--bridge);">Send
        Report<br />to Sheets</button>
      <button class="action-main" id="wipeBtn" onclick="handleWipeConfirm()"
        style="background:var(--danger); opacity:0.85;">Clear<br />Staging</button>
    </div>

    <div class="preview-wrap" id="previewArea"></div>

    <div id="auth_status">Sync Status: Idle</div>
    <button id="log_btn" onclick="toggleLog(true)">Display Trace Log</button>
    <div id="trace_log" onclick="toggleLog(false)">Trace: v0.10 Kraken Ledger Report initialized.</div>
  </div>

  <script>
    const SHEET_ID = "1Vf0iqthwHv0kFqTRJkYShH_RBpbokLmiEDWGJN3Q0_E";
    const VER = "Kraken Ledger Report (v0.11)";
    const KRAKEN_API_URL = "https://api.kraken.com";

    // Default API credentials (enter your own in API Config)
    const DEFAULT_API_KEY = "";
    const DEFAULT_PRIVATE_KEY = "";

    // Cache data structure
    let cacheData = {
      settings: { tolerancePercent: 2 },
      destTags: [],   // [{recipient, destTag, address}]
      wallets: [],    // [{recipient, asset, address}]
      ledger: [],     // raw ledger rows
      trades: [],     // raw trades rows
      krakenAddresses: [] // from Kraken API WithdrawAddresses
    };

    let stagingRecords = [];
    let tokenClient;
    let resetConfirmed = false;
    let wipeConfirmed = false;

    // ---------- Logging ----------
    function logTrace(msg) {
      const log = document.getElementById("trace_log");
      const now = new Date().toLocaleTimeString();
      const base = log.textContent && log.textContent.trim().length
        ? log.textContent
        : "Trace: v0.10 Kraken Ledger Report initialized.";
      log.textContent = base + "\n[" + now + "] " + msg;
      log.scrollTop = log.scrollHeight;
      console.log(msg);
    }

    window.onerror = function (message, source, lineno, colno) {
      logTrace("FATAL: " + message + " @ " + (source || "") + ":" + lineno + ":" + colno);
    };
    window.onunhandledrejection = function (ev) {
      logTrace("FATAL PROMISE: " + (ev && ev.reason ? (ev.reason.message || ev.reason) : "unknown"));
    };

    function toggleLog(show) {
      document.getElementById("log_btn").style.display = show ? "none" : "block";
      document.getElementById("trace_log").style.display = show ? "block" : "none";
    }

    function updateStatus(label, state) {
      const el = document.getElementById("auth_status");
      el.innerText = "Sync Status: " + label;
      const colors = { idle: "#7f8c8d", active: "#27ae60", sync: "#e67e22", error: "#c0392b" };
      el.style.color = colors[state] || colors.idle;
    }

    // ---------- Date Handling ----------
    function handleDateChange(id) {
      const dStr = document.getElementById(id).value;
      const dispEl = document.getElementById(id + "Disp");
      if (!dStr) { dispEl.innerText = ""; return; }
      const [y, m, d] = dStr.split("-").map(Number);
      const dt = new Date(y, m - 1, d);
      const day = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][dt.getDay()];
      const mon = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][dt.getMonth()];
      dispEl.innerText = day + " " + dt.getDate() + " " + mon + " '" + String(dt.getFullYear()).slice(-2);
    }

    // ---------- Reset / Wipe ----------
    function handleResetConfirm() {
      const btn = document.getElementById("resetBtn");
      if (!resetConfirmed) {
        resetConfirmed = true;
        btn.innerText = "CONFIRM?";
        setTimeout(() => { resetConfirmed = false; btn.innerText = "Reset"; }, 3000);
        return;
      }
      resetConfirmed = false;
      btn.innerText = "Reset";
      localReset();
    }

    function handleWipeConfirm() {
      const btn = document.getElementById("wipeBtn");
      if (!wipeConfirmed) {
        wipeConfirmed = true;
        btn.innerHTML = "CONFIRM?";
        setTimeout(() => { wipeConfirmed = false; btn.innerHTML = "Clear<br/>Staging"; }, 3000);
        return;
      }
      wipeConfirmed = false;
      btn.innerHTML = "Clear<br/>Staging";
      stagingRecords = [];
      localStorage.removeItem("kraken_staging");
      renderPreview();
      logTrace("Staging cleared manually.");
    }

    function localReset() {
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";
      document.getElementById("startDateDisp").innerText = "";
      document.getElementById("endDateDisp").innerText = "";
      updateStatusCounts();
      logTrace("UI Reset.");
    }

    // ---------- Status Display ----------
    function updateStatusCounts() {
      document.getElementById("ledgerCount").innerText = cacheData.ledger.length;
      document.getElementById("tradesCount").innerText = cacheData.trades.length;
      document.getElementById("recipientCount").innerText = cacheData.destTags.length + cacheData.wallets.length;
      document.getElementById("toleranceDisp").innerText = cacheData.settings.tolerancePercent;
    }

    // ---------- Local Cache ----------
    function cacheSave() {
      if (cacheData.ledger.length === 0 && cacheData.destTags.length === 0) {
        alert("Refresh Lookups First");
        return;
      }
      if (!confirm("Snapshot current data to local storage?")) return;
      localStorage.setItem("kraken_cache_settings", JSON.stringify(cacheData.settings));
      localStorage.setItem("kraken_cache_dest_tags", JSON.stringify(cacheData.destTags));
      localStorage.setItem("kraken_cache_wallets", JSON.stringify(cacheData.wallets));
      localStorage.setItem("kraken_cache_ledger", JSON.stringify(cacheData.ledger));
      localStorage.setItem("kraken_cache_trades", JSON.stringify(cacheData.trades));
      logTrace("Cache saved to localStorage.");
      alert("Data saved to local storage.");
    }

    function cachePull() {
      if (!confirm("Load data from local storage?")) return;
      const cached = localStorage.getItem("kraken_cache_ledger");
      if (!cached) {
        alert("No local data found. Use 'Refresh Lookups from Sheets' first.");
        return;
      }
      cacheData.settings = JSON.parse(localStorage.getItem("kraken_cache_settings") || '{"tolerancePercent":2}');
      cacheData.destTags = JSON.parse(localStorage.getItem("kraken_cache_dest_tags") || "[]");
      cacheData.wallets = JSON.parse(localStorage.getItem("kraken_cache_wallets") || "[]");
      cacheData.ledger = JSON.parse(localStorage.getItem("kraken_cache_ledger") || "[]");
      cacheData.trades = JSON.parse(localStorage.getItem("kraken_cache_trades") || "[]");
      updateStatusCounts();
      logTrace("Cache pulled from localStorage. Ledger=" + cacheData.ledger.length + " Trades=" + cacheData.trades.length);
      alert("Data loaded from local storage.");
    }

    // ---------- Staging Table Render ----------
    function renderPreview() {
      const area = document.getElementById("previewArea");
      if (!stagingRecords.length) {
        area.innerHTML = "<div style='padding:15px; text-align:center; color:#7f8c8d; font-size:0.75rem;'>No staging records. Click 'Generate Report' after loading data.</div>";
        return;
      }

      let html = '<table><thead><tr>';
      html += '<th class="w-date">Date</th>';
      html += '<th class="w-recipient">Recipient</th>';
      html += '<th class="w-asset">Asset</th>';
      html += '<th class="w-amount">Amount</th>';
      html += '<th class="w-fee">Fee</th>';
      html += '<th class="w-cur">Orig Cur</th>';
      html += '<th class="w-amount">Orig Amt</th>';
      html += '<th class="w-gbp">GBP Equiv</th>';
      html += '<th class="w-desttag">Dest Tag</th>';
      html += '<th class="w-wallet">Wallet</th>';
      html += '<th class="w-txid">TX ID</th>';
      html += '<th class="w-matched">Match</th>';
      html += '</tr></thead><tbody>';

      for (const r of stagingRecords) {
        html += '<tr>';
        html += '<td class="w-date">' + escHtml(r.dateSent) + '</td>';
        html += '<td class="w-recipient">' + escHtml(r.recipient) + '</td>';
        html += '<td class="w-asset">' + escHtml(r.asset) + '</td>';
        html += '<td class="w-amount">' + escHtml(r.amount) + '</td>';
        html += '<td class="w-fee">' + escHtml(r.fee) + '</td>';
        html += '<td class="w-cur">' + escHtml(r.originalCurrency) + '</td>';
        html += '<td class="w-amount">' + escHtml(r.originalAmount) + '</td>';
        html += '<td class="w-gbp">' + escHtml(r.gbpEquivalent) + '</td>';
        html += '<td class="w-desttag">' + escHtml(r.destTag) + '</td>';
        html += '<td class="w-wallet">' + escHtml(r.wallet) + '</td>';
        html += '<td class="w-txid">' + escHtml(r.txId) + '</td>';
        html += '<td class="w-matched" style="font-weight:800; color:' + (r.matched === 'Yes' ? 'var(--accent)' : 'var(--danger)') + '">' + escHtml(r.matched) + '</td>';
        html += '</tr>';
      }
      html += '</tbody></table>';
      area.innerHTML = html;
    }

    function escHtml(s) {
      if (s === null || s === undefined) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    // ---------- Report Generation ----------
    function generateReport() {
      const startVal = document.getElementById("startDate").value;
      const endVal = document.getElementById("endDate").value;

      if (!startVal || !endVal) {
        alert("Please select both Start Date and End Date.");
        return;
      }

      if (cacheData.ledger.length === 0) {
        alert("No ledger data. Use 'Pull local Lookups' or 'Refresh Lookups from Sheets' first.");
        return;
      }

      const startTime = new Date(startVal + "T00:00:00").getTime() / 1000;
      const endTime = new Date(endVal + "T23:59:59").getTime() / 1000;
      const tolerance = cacheData.settings.tolerancePercent / 100;

      logTrace("Generating report. Start=" + startVal + " End=" + endVal + " Tolerance=" + (tolerance * 100) + "%");

      // Filter withdrawals from ledger
      // Ledger time format: "2024-11-02 08:42:24" - need to parse as date string
      const withdrawals = cacheData.ledger.filter(entry => {
        const entryTimeStr = entry.time || "";
        const entryTime = parseDateString(entryTimeStr);
        const entryType = (entry.type || "").toLowerCase();
        return entryType === "withdrawal" && entryTime >= startTime && entryTime <= endTime;
      });

      logTrace("Found " + withdrawals.length + " withdrawals in date range.");

      stagingRecords = [];

      for (const w of withdrawals) {
        // Ledger columns: txid, refid, time, type, subtype, aclass, subclass, asset, wallet, amount, fee, balance
        const txid = w.txid || "";
        const refid = w.refid || "";
        const wTime = parseDateString(w.time || "");
        const wType = w.type || "";
        const wAsset = w.asset || "";
        const wAmount = parseFloat(w.amount || 0);
        const wFee = parseFloat(w.fee || 0);
        const wBalance = parseFloat(w.balance || 0);

        // Find recipient
        let recipient = "";
        let destTag = "";
        let walletAddr = "";

        if (wAsset.includes("XRP") || wAsset === "XXRP") {
          // Extract destination tag from refid or description
          destTag = extractDestTag(refid);
          const match = cacheData.destTags.find(d => String(d.destTag) === destTag || String(d[1]) === destTag);
          recipient = match ? (match.recipient || match[0] || "") : "";
        } else if (wAsset.includes("USDT")) {
          walletAddr = extractWallet(refid);
          const match = cacheData.wallets.find(d => (d.address || d[2] || "") === walletAddr);
          recipient = match ? (match.recipient || match[0] || "") : "";
        }

        // Find matching trade (fuzzy)
        const trade = findMatchingTrade(wAmount, wTime, wAsset, tolerance);

        const record = {
          dateSent: formatTimestamp(wTime),
          entryDate: trade ? formatTimestamp(parseDateString(trade.time || "")) : "",
          recipient: recipient,
          asset: wAsset,
          amount: wAmount.toFixed(6),
          fee: wFee.toFixed(6),
          balance: wBalance.toFixed(6),
          originalCurrency: trade ? extractFiatCurrency(trade) : "",
          originalAmount: trade ? (parseFloat(trade.cost || trade[7] || 0)).toFixed(2) : "",
          gbpEquivalent: trade ? calculateGBPEquivalent(trade) : "",
          destTag: destTag,
          wallet: walletAddr,
          txId: refid,
          matched: trade ? "Yes" : "No"
        };

        stagingRecords.push(record);
      }

      localStorage.setItem("kraken_staging", JSON.stringify(stagingRecords));
      renderPreview();
      logTrace("Report generated. " + stagingRecords.length + " records in staging.");
      alert("Report generated: " + stagingRecords.length + " records.");
    }

    function findMatchingTrade(withdrawalAmount, withdrawalTime, asset, tolerance) {
      const absAmount = Math.abs(withdrawalAmount);

      // Filter trades that are BEFORE the withdrawal and for the same asset
      // Trades columns: txid, ordertxid, pair, aclass, subclass, time, type, ordertype, price, cost, fee, vol
      const candidates = cacheData.trades.filter(trade => {
        const tradeTime = parseDateString(trade.time || "");
        const tradePair = (trade.pair || "").toUpperCase();
        const assetNorm = asset.replace("X", "").replace("Z", "");
        return tradeTime < withdrawalTime && tradePair.includes(assetNorm);
      });

      // Sort by time descending (most recent first)
      candidates.sort((a, b) => {
        const tA = parseDateString(a.time || "");
        const tB = parseDateString(b.time || "");
        return tB - tA;
      });

      // Find first trade where vol ≈ withdrawal amount
      for (const trade of candidates) {
        const tradeVol = Math.abs(parseFloat(trade.vol || 0));
        const diff = Math.abs(tradeVol - absAmount) / absAmount;
        if (diff <= tolerance) {
          return trade;
        }
      }

      return null;
    }

    // Parse Kraken date strings like "2024-11-02 08:42:24" to Unix timestamp
    function parseDateString(dateStr) {
      if (!dateStr) return 0;
      // Handle both "2024-11-02 08:42:24" and Unix timestamp formats
      if (!isNaN(parseFloat(dateStr)) && dateStr.indexOf("-") === -1) {
        return parseFloat(dateStr);
      }
      const dt = new Date(dateStr.replace(" ", "T"));
      return dt.getTime() / 1000;
    }

    function extractDestTag(refid) {
      // Destination tag often appears as a numeric suffix or can be parsed from description
      // For now, return empty - will need refinement based on actual data format
      const match = String(refid).match(/\d{6,}/);
      return match ? match[0] : "";
    }

    function extractWallet(refid) {
      // Wallet address extraction - placeholder
      return "";
    }

    function extractFiatCurrency(trade) {
      const pair = (trade.pair || "").toUpperCase();
      if (pair.includes("GBP") || pair.includes("ZGBP")) return "GBP";
      if (pair.includes("EUR") || pair.includes("ZEUR")) return "EUR";
      if (pair.includes("USD") || pair.includes("ZUSD")) return "USD";
      return "";
    }

    function calculateGBPEquivalent(trade) {
      const cost = parseFloat(trade.cost || 0);
      const cur = extractFiatCurrency(trade);
      if (cur === "GBP") return cost.toFixed(2);
      if (cur === "EUR") return (cost * 0.86).toFixed(2); // Approximate EUR→GBP
      if (cur === "USD") return (cost * 0.79).toFixed(2); // Approximate USD→GBP
      return cost.toFixed(2);
    }

    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const d = String(dt.getDate()).padStart(2, "0");
      const m = String(dt.getMonth() + 1).padStart(2, "0");
      const y = dt.getFullYear();
      return d + "/" + m + "/" + y;
    }

    // ---------- Google Auth / Sheets ----------
    function gapiLoaded() {
      gapi.load("client", async () => {
        await gapi.client.init({ apiKey: "AIzaSyDvZ1XZw5bZgWSB9zaU7h9Vtn7MhDGFMSM" });
        await gapi.client.load("sheets", "v4");
        logTrace("GAPI Ready.");
      });
    }

    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: "23231735212-jtgur3sn2ndh798ke00pm2a1d5rkd4eu.apps.googleusercontent.com",
        scope: "https://www.googleapis.com/auth/spreadsheets",
        callback: () => { }
      });
      logTrace("GIS Ready.");
    }

    function initRefresh() {
      requestToken(true, () => fetchAllSheets());
    }

    function requestToken(forcePrompt, onOk) {
      tokenClient.callback = (resp) => {
        if (!resp || !resp.access_token) return;
        const issuedAt = Date.now();
        const expiresIn = resp.expires_in ? Number(resp.expires_in) : 3600;
        localStorage.setItem("g_token", resp.access_token);
        localStorage.setItem("g_token_issued_at", String(issuedAt));
        localStorage.setItem("g_token_expires_in", String(expiresIn));
        gapi.client.setToken({ access_token: resp.access_token });
        onOk();
      };
      const args = forcePrompt ? { prompt: "consent" } : { prompt: "" };
      tokenClient.requestAccessToken(args);
    }

    function ensureTokenThen(onOk) {
      const tok = localStorage.getItem("g_token");
      const issuedAt = Number(localStorage.getItem("g_token_issued_at") || "0");
      const exp = Number(localStorage.getItem("g_token_expires_in") || "0");
      const age = (Date.now() - issuedAt) / 1000;

      if (tok && issuedAt && exp && age < (exp - 60)) {
        gapi.client.setToken({ access_token: tok });
        onOk();
        return;
      }
      requestToken(true, onOk);
    }

    async function fetchAllSheets() {
      updateStatus("Fetching data...", "sync");
      try {
        // Fetch Settings
        logTrace("Fetching Settings...");
        const settingsRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "Settings!A2:B10"
        });
        const settingsRows = settingsRes.result.values || [];
        for (const row of settingsRows) {
          if (row[0] === "TolerancePercent") {
            cacheData.settings.tolerancePercent = parseFloat(row[1]) || 2;
          }
        }

        // Fetch DEST_TAG
        logTrace("Fetching DEST_TAG...");
        const destTagRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "DEST_TAG!A2:B500"
        });
        cacheData.destTags = (destTagRes.result.values || []).map(r => ({
          recipient: r[0] || "",
          destTag: r[1] || ""
        }));

        // Fetch WALLET
        logTrace("Fetching WALLET...");
        const walletRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "WALLET!A2:C500"
        });
        cacheData.wallets = (walletRes.result.values || []).map(r => ({
          recipient: r[0] || "",
          asset: r[1] || "",
          address: r[2] || ""
        }));

        // Fetch csv-ledger
        // Columns: A:txid, B:refid, C:time, D:type, E:subtype, F:aclass, G:subclass, H:asset, I:wallet, J:amount, K:fee, L:balance
        logTrace("Fetching csv-ledger...");
        const ledgerRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "'csv-ledger'!A2:L5000"
        });
        cacheData.ledger = (ledgerRes.result.values || []).map(r => ({
          txid: r[0] || "",
          refid: r[1] || "",
          time: r[2] || "",
          type: r[3] || "",
          subtype: r[4] || "",
          aclass: r[5] || "",
          subclass: r[6] || "",
          asset: r[7] || "",
          wallet: r[8] || "",
          amount: r[9] || "",
          fee: r[10] || "",
          balance: r[11] || ""
        }));

        // Fetch csv-trades
        // Columns: A:txid, B:ordertxid, C:pair, D:aclass, E:subclass, F:time, G:type, H:ordertype, I:price, J:cost, K:fee, L:vol, M:margin, N:misc, O:ledgers
        logTrace("Fetching csv-trades...");
        const tradesRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SHEET_ID,
          range: "'csv-trades'!A2:O5000"
        });
        cacheData.trades = (tradesRes.result.values || []).map(r => ({
          txid: r[0] || "",
          ordertxid: r[1] || "",
          pair: r[2] || "",
          aclass: r[3] || "",
          subclass: r[4] || "",
          time: r[5] || "",
          type: r[6] || "",
          ordertype: r[7] || "",
          price: r[8] || "",
          cost: r[9] || "",
          fee: r[10] || "",
          vol: r[11] || "",
          margin: r[12] || "",
          misc: r[13] || "",
          ledgers: r[14] || ""
        }));

        updateStatusCounts();
        updateStatus("Token Active", "active");
        logTrace("Refresh complete. Ledger=" + cacheData.ledger.length + " Trades=" + cacheData.trades.length);
        alert("Refresh complete.\nLedger: " + cacheData.ledger.length + " records\nTrades: " + cacheData.trades.length + " records");

      } catch (e) {
        updateStatus("Error", "error");
        logTrace("Fetch error: " + (e.message || e));
        alert("Error fetching data. Check trace log.");
      }
    }

    async function handleSync() {
      if (!stagingRecords.length) {
        alert("No staging records to send.");
        return;
      }

      updateStatus("Syncing...", "sync");
      logTrace("Sync started. Rows=" + stagingRecords.length);

      ensureTokenThen(async () => {
        try {
          // Find first empty row in ReportStaging
          const meta = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SHEET_ID,
            range: "'ReportStaging'!A2:A"
          });
          const used = meta.result.values ? meta.result.values.length : 0;
          const startRow = 2 + used;

          // Prepare values
          const vals = stagingRecords.map(r => [
            r.dateSent,
            r.entryDate,
            r.recipient,
            r.asset,
            r.amount,
            r.fee,
            r.balance,
            r.originalCurrency,
            r.originalAmount,
            r.gbpEquivalent,
            r.destTag,
            r.wallet,
            r.txId,
            r.matched,
            VER
          ]);

          await gapi.client.sheets.spreadsheets.values.update({
            spreadsheetId: SHEET_ID,
            range: "'ReportStaging'!A" + startRow + ":O" + (startRow + vals.length - 1),
            valueInputOption: "USER_ENTERED",
            resource: { values: vals }
          });

          updateStatus("Token Active", "active");
          logTrace("Sync complete. StartRow=" + startRow);
          alert("Sync completed. " + vals.length + " records sent to ReportStaging.");

        } catch (e) {
          updateStatus("Sync error", "error");
          logTrace("Sync error: " + (e.message || e));
          alert("Sync failed. Check trace log.");
        }
      });
    }

    // ---------- Kraken API ----------
    function toggleApiConfig() {
      const section = document.getElementById("apiConfigSection");
      section.style.display = section.style.display === "none" ? "block" : "none";
      // Load saved credentials
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedProxy) document.getElementById("corsProxy").value = savedProxy;
    }

    function getApiCredentials() {
      let apiKey = document.getElementById("krakenApiKey").value.trim();
      let privateKey = document.getElementById("krakenPrivateKey").value.trim();
      if (!apiKey) apiKey = DEFAULT_API_KEY;
      if (!privateKey) privateKey = DEFAULT_PRIVATE_KEY;
      // Save for next time
      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      const proxy = document.getElementById("corsProxy").value.trim();
      localStorage.setItem("kraken_cors_proxy", proxy);
      return { apiKey, privateKey, proxy };
    }

    // Base64 helpers
    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    // Kraken API signature generation using Web Crypto API
    async function createKrakenSignature(urlPath, postData, privateKeyBase64) {
      const encoder = new TextEncoder();

      // Step 1: Get nonce from postData
      const params = new URLSearchParams(postData);
      const nonce = params.get("nonce");

      // Step 2: SHA256 hash of (nonce + postData)
      const sha256Data = encoder.encode(nonce + postData);
      const sha256Hash = await crypto.subtle.digest("SHA-256", sha256Data);

      // Step 3: Concatenate urlPath bytes + sha256Hash bytes
      const pathBytes = encoder.encode(urlPath);
      const combined = new Uint8Array(pathBytes.length + sha256Hash.byteLength);
      combined.set(pathBytes, 0);
      combined.set(new Uint8Array(sha256Hash), pathBytes.length);

      // Step 4: HMAC-SHA512 with decoded private key
      const privateKeyBytes = base64ToArrayBuffer(privateKeyBase64);
      const hmacKey = await crypto.subtle.importKey(
        "raw",
        privateKeyBytes,
        { name: "HMAC", hash: "SHA-512" },
        false,
        ["sign"]
      );

      const signature = await crypto.subtle.sign("HMAC", hmacKey, combined);

      // Step 5: Base64 encode the signature
      return arrayBufferToBase64(signature);
    }

    async function callKrakenPrivateAPI(endpoint, params = {}) {
      const { apiKey, privateKey, proxy } = getApiCredentials();
      const urlPath = "/0/private/" + endpoint;
      const nonce = Date.now().toString();

      const postParams = new URLSearchParams({ nonce, ...params });
      const postData = postParams.toString();

      try {
        const signature = await createKrakenSignature(urlPath, postData, privateKey);

        const url = (proxy ? proxy : "") + KRAKEN_API_URL + urlPath;

        logTrace("Calling Kraken API: " + endpoint);

        const response = await fetch(url, {
          method: "POST",
          headers: {
            "API-Key": apiKey,
            "API-Sign": signature,
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: postData
        });

        if (!response.ok) {
          throw new Error("HTTP " + response.status + ": " + response.statusText);
        }

        const data = await response.json();

        if (data.error && data.error.length > 0) {
          throw new Error("Kraken API Error: " + data.error.join(", "));
        }

        return data.result;

      } catch (e) {
        if (e.message.includes("Failed to fetch") || e.message.includes("NetworkError")) {
          logTrace("CORS blocked. Try using a CORS proxy in API Config.");
          throw new Error("CORS blocked. Please configure a CORS proxy in API Config.");
        }
        throw e;
      }
    }

    async function fetchKrakenAddresses() {
      logTrace("Fetching Kraken withdrawal addresses...");
      updateStatus("Fetching Kraken...", "sync");

      try {
        // Fetch all withdrawal addresses
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses");

        logTrace("Kraken WithdrawAddresses response: " + JSON.stringify(addresses).substring(0, 500));

        // addresses is an array of address objects
        cacheData.krakenAddresses = addresses || [];

        // Parse into destTags (XRP) and wallets (USDT/others)
        const newDestTags = [];
        const newWallets = [];

        for (const addr of cacheData.krakenAddresses) {
          // addr structure: { address, asset, key, memo, method, new, tag, verified }
          const keyName = addr.key || "";  // This is the saved address name (e.g., "Aleksey XRP")
          const asset = addr.asset || "";
          const address = addr.address || "";
          const destTag = addr.tag || addr.memo || "";  // XRP uses tag, others might use memo

          // Try to extract recipient name from key (e.g., "Aleksey XRP" -> "Aleksey")
          const recipientName = keyName.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim() || keyName;

          if (asset.toUpperCase().includes("XRP") || asset === "XXRP") {
            newDestTags.push({
              recipient: recipientName,
              destTag: destTag,
              address: address,
              keyName: keyName,
              asset: asset
            });
          } else {
            newWallets.push({
              recipient: recipientName,
              asset: asset,
              address: address,
              keyName: keyName
            });
          }
        }

        // Merge with existing data (don't overwrite if already have data)
        if (newDestTags.length > 0) {
          cacheData.destTags = newDestTags;
          logTrace("Found " + newDestTags.length + " XRP addresses with destination tags.");
        }
        if (newWallets.length > 0) {
          cacheData.wallets = newWallets;
          logTrace("Found " + newWallets.length + " other wallet addresses (USDT, etc.).");
        }

        updateStatusCounts();
        updateStatus("Kraken OK", "active");

        const summary = "Fetched " + cacheData.krakenAddresses.length + " addresses.\n" +
          "XRP (with dest tags): " + newDestTags.length + "\n" +
          "Other wallets: " + newWallets.length;
        alert(summary);
        logTrace(summary.replace(/\n/g, " | "));

      } catch (e) {
        updateStatus("Kraken Error", "error");
        logTrace("Kraken API error: " + (e.message || e));
        alert("Kraken API Error:\n" + (e.message || e) + "\n\nCheck trace log for details.");
      }
    }

    // ---------- Boot ----------
    async function waitFor(cond, timeoutMs) {
      const t0 = Date.now();
      return new Promise((resolve, reject) => {
        const tick = () => {
          if (cond()) return resolve(true);
          if (Date.now() - t0 > timeoutMs) return reject(new Error("Timeout"));
          setTimeout(tick, 50);
        };
        tick();
      });
    }

    async function boot() {
      // Load saved staging
      const savedStaging = localStorage.getItem("kraken_staging");
      if (savedStaging) {
        try {
          stagingRecords = JSON.parse(savedStaging);
        } catch (e) { }
      }
      renderPreview();
      updateStatusCounts();

      try {
        await waitFor(() => typeof gapi !== "undefined", 8000);
        gapiLoaded();
      } catch (_) {
        logTrace("GAPI not available.");
      }

      try {
        await waitFor(() => typeof google !== "undefined" && google.accounts && google.accounts.oauth2, 8000);
        gisLoaded();
      } catch (_) {
        logTrace("GIS not available.");
      }
    }

    window.addEventListener("load", boot);
  </script>
</body>

</html>