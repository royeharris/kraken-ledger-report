<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Kraken Ledger Report v3.043</title>
  <script async defer src="https://accounts.google.com/gsi/client"></script>
  <script async defer src="https://apis.google.com/js/api.js"></script>
  <style>
    :root {
      --primary: #2c3e50;
      --accent: #27ae60;
      --danger: #c0392b;
      --bg: #f8f9fa;
      --bridge: #2980b9;
      --cache: #8e44ad;
      --kraken: #5741d9;
      --joy: #27ae60;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      margin: 0;
      padding: 10px;
    }

    .container {
      max-width: 960px;
      margin: auto;
      background: #fff;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .branding-row {
      margin-bottom: 10px;
      font-size: 1.1rem;
      line-height: 1.1;
      color: var(--primary);
    }

    .branding-row b {
      font-weight: 800;
    }

    .branding-row span {
      font-weight: 500;
      font-size: 0.75rem;
      color: #7f8c8d;
      margin-left: 6px;
    }

    .header-wrap {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
      gap: 8px;
    }

    .header-btns {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      width: 100%;
    }

    .btn-lookup {
      padding: 6px;
      font-size: 0.72rem;
      border-radius: 6px;
      border: none;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      flex: 1;
      height: 52px;
      line-height: 1.1;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }

    .btn-pull {
      background: var(--cache);
    }

    .btn-refresh {
      background: var(--bridge);
    }

    .btn-save {
      background: var(--accent);
    }

    .btn-reset {
      background: var(--danger);
    }

    label {
      font-size: 0.7rem;
      font-weight: 800;
      display: block;
      margin-bottom: 2px;
      color: var(--primary);
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      font-size: 16px;
      box-sizing: border-box;
      height: 38px;
      -webkit-text-size-adjust: 100%;
      font-family: inherit;
    }

    .date-input-container {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #fff;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      padding: 0 8px;
      height: 38px;
    }

    .date-input-container input[type="date"] {
      border: none;
      padding: 0;
      height: 100%;
      font-size: 14px;
      flex-grow: 1;
      outline: none;
      background: transparent;
    }

    .date-input-container:hover,
    .date-input-container:focus-within {
      border: 1px solid var(--primary);
      box-shadow: 0 0 0 1px var(--primary);
    }

    .date-disp {
      font-size: 0.65rem;
      color: #7f8c8d;
      text-align: center;
      margin-top: 2px;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
      padding: 10px;
      background: #f1f2f6;
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--primary);
    }

    .status-item {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .status-item b {
      font-weight: 800;
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      width: 100%;
      margin-top: 15px;
    }

    button.action-main {
      padding: 8px 10px;
      border: none;
      border-radius: 6px;
      font-weight: 900;
      cursor: pointer;
      color: #fff;
      font-size: 0.72rem;
      -webkit-font-smoothing: antialiased;
      min-height: 52px;
    }

    .preview-wrap {
      width: 100%;
      overflow-x: auto;
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.58rem;
      table-layout: auto;
      /* Allow columns to adapt */
      font-family: inherit;
    }

    th,
    td {
      border: 1px solid #eee;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    th {
      padding: 6px 4px;
    }

    td {
      padding: 2px 3px;
    }

    th {
      background: #f2f2f2;
      font-weight: 900 !important;
      color: var(--primary);
      font-size: 0.58rem !important;
    }

    /* Fixed header enhancement */
    thead tr th {
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* Column widths - optimized for screen fit */
    .w-date {
      width: 50px;
    }

    .w-type {
      width: 70px;
    }

    .w-time {
      width: 45px;
      text-align: center;
    }

    .w-recipient {
      width: 80px;
    }

    .w-sentto {
      width: 90px;
    }

    .w-asset {
      width: 30px;
      text-align: center;
    }

    .w-amount,
    .w-balance,
    .w-fee,
    .w-gbp,
    .w-gbpfee {
      text-align: right;
      white-space: nowrap;
    }

    .w-rate {
      width: 60px;
      text-align: right;
    }

    .w-cur {
      width: 50px;
      text-align: center;
    }

    .w-desttag {
      width: 60px;
    }

    .w-txid {
      width: 80px;
    }

    .w-source {
      width: 60px;
    }

    .w-wallet {
      width: 120px;
    }

    /* Bank Report specific columns */
    .w-bank-datetime {
      min-width: 14ch;
      width: 14ch;
    }

    .w-bank-details {
      min-width: 25ch;
      width: 25ch;
      /* Sticky Description Column */
      position: sticky;
      left: 0;
      background-color: inherit;
      /* will inherit row background */
      z-index: 2;
      /* higher than normal cells */
    }

    /* Filter Input Optimization */
    #typeFilterInput,
    #descFilterInput {
      width: 90%;
      font-size: 0.55rem;
      padding: 1px;
      margin-top: 1px;
      height: 18px;
      /* Reduced fixed height */
    }

    .w-bank-val {
      min-width: 11ch;
      width: 11ch;
      text-align: right;
    }

    .w-bank-bal {
      min-width: 11ch;
      width: 11ch;
      text-align: right;
      /* font-weight: 700; removed per user request */
      background: #f8f9fa;
    }

    .section-border-left {
      border-left: 2px solid #bdc3c7 !important;
    }




    #auth_status {
      font-size: 0.75rem;
      margin-top: 10px;
      text-align: center;
      color: var(--primary);
      font-weight: 800;
    }

    #log_btn {
      margin-top: 15px;
      width: 100%;
      background: var(--primary);
      color: #fff;
      font-size: 0.7rem;
      border-radius: 6px;
      padding: 8px;
      border: none;
      font-weight: 700;
      display: block;
    }

    #trace_log {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background: #2c3e50;
      color: #00ff00;
      font-family: "Courier New", monospace;
      font-size: 0.6rem;
      border-radius: 6px;
      max-height: 170px;
      overflow-y: auto;
      white-space: pre-wrap;
      cursor: pointer;
    }

    .ico {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--primary);
    }

    .cal-svg {
      width: 16px;
      height: 16px;
      display: block;
      fill: currentColor;
    }

    @media (max-width: 430px) {
      .actions {
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }

      button.action-main {
        min-height: 54px;
        padding: 8px 10px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header-wrap">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; position:relative;">
        <div class="branding-row" style="margin-bottom:0; line-height:1.2;">
          <div><b>Kraken Reports</b> <span style="font-size:0.7rem; color:#7f8c8d; font-weight:600;">v3.043</span></div>
          <div style="font-size:0.65rem; color:#b0b0b0; font-weight:400;">GBP | EUR | USDT | XRP | transactions in Date
            range</div>
        </div>
        <div id="auth_status"
          style="position:absolute; left:50%; transform:translateX(-50%); font-size:0.7rem; font-weight:700;">Status:
          Ready</div>
        <div style="display:flex; gap:4px;">
          <button onclick="copyTraceToClipboard()"
            style="background:#16a085; padding:4px 8px; height:auto; font-size:0.65rem; border-radius:6px; border:none; color:#fff; cursor:pointer; font-weight:800;">Copy
            Trace</button>
          <button id="resetBtn" onclick="handleReportReset()"
            style="background:var(--danger); padding:4px 8px; height:auto; font-size:0.65rem; border-radius:6px; border:none; color:#fff; cursor:pointer; font-weight:800; box-shadow: 0 0 6px rgba(192,57,43,0.5);">Reset</button>
        </div>
      </div>

      <!-- Date Range -->
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
        <div>
          <label>Start Date</label>
          <div class="date-input-container" onclick="document.getElementById('startDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="startDate" onchange="handleDateChange('startDate')" type="date" />
          </div>
        </div>
        <div>
          <label>End Date</label>
          <div class="date-input-container" onclick="document.getElementById('endDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="endDate" onchange="handleDateChange('endDate')" type="date" />
          </div>
        </div>
      </div>

      <!-- Three Action Buttons -->
      <div style="display:flex; gap:6px; margin-bottom:10px;">
        <button onclick="readLedger()"
          style="flex:1; padding:10px 4px; background:var(--primary); color:#fff; border:none; border-radius:4px; font-size:0.7rem; font-weight:600; cursor:pointer;">Read<br />Ledger</button>
        <button onclick="pullAddresses()"
          style="flex:1; padding:10px 4px; background:var(--kraken); color:#fff; border:none; border-radius:4px; font-size:0.7rem; font-weight:600; cursor:pointer;">Pull
          Addresses<br />‚ú± 2FA</button>
        <button id="generate_btn" onclick="generateReport()"
          style="flex:1; padding:8px 4px; background:var(--joy); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Generate
          Report</button>
      </div>
    </div>

    <!-- API Config Button + Panel (click to close) -->
    <button id="api_btn" onclick="toggleApiConfig()"
      style="width:100%; padding:8px; margin-top:10px; background:#34495e; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">‚öôÔ∏è
      API Config</button>

    <div id="apiConfigSection" onclick="toggleApiConfig()"
      style="display:none; margin-bottom:15px; padding:10px; background:#f1f2f6; border-radius:6px; border:2px solid #34495e; cursor:pointer;">
      <div
        style="font-size:0.85rem; font-weight:700; color:var(--primary); margin-bottom:10px; padding-bottom:6px; border-bottom:1px solid #ddd;">
        ‚öôÔ∏è Kraken API Configuration (click to close)</div>

      <div onclick="event.stopPropagation()">
        <div style="font-size:0.7rem; font-weight:700; color:var(--primary); margin-bottom:4px;">Query API (for Ledger
          data)</div>
        <label>API Key</label>
        <input type="text" id="krakenApiKey" placeholder="API Key with Query permissions" style="margin-bottom:4px;">
        <label>Private Key</label>
        <input type="password" id="krakenPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:10px;">

        <div
          style="font-size:0.7rem; font-weight:700; color:#e67e22; margin-bottom:4px; padding-top:8px; border-top:1px solid #ddd;">
          Google Sheets (for Sync)</div>
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <label>Sheet ID</label>
          <a href="https://docs.google.com/spreadsheets" target="_blank"
            style="font-size:0.6rem; color:#2980b9; text-decoration:none;">Open Google Sheets ‚Üó</a>
        </div>
        <input type="text" id="googleSheetId" placeholder="e.g. 1Vf0iqthwHv0kFqTRJkYShH..." style="margin-bottom:2px;">
        <div style="font-size:0.6rem; color:#95a5a6; margin-bottom:10px; line-height:1.2;">
          Found in URL: .../spreadsheets/d/<b>ID_IS_HERE</b>/edit
        </div>

        <div
          style="font-size:0.7rem; font-weight:700; color:var(--kraken); margin-bottom:4px; padding-top:8px; border-top:1px solid #ddd;">
          Withdraw API (for Addresses - requires 2FA)</div>
        <label>API Key</label>
        <input type="text" id="withdrawApiKey" placeholder="API Key with Withdraw permissions"
          style="margin-bottom:4px;">
        <label>Private Key</label>
        <input type="password" id="withdrawPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:10px;">

        <label>CORS Proxy</label>
        <select id="corsProxySelect" onchange="handleProxyChange()" style="margin-bottom:4px;">
          <option value="">None (direct - may fail in browser)</option>
          <option value="https://cors-anywhere.herokuapp.com/">cors-anywhere (50 req/hr)</option>
          <option value="https://corsproxy.io/?">corsproxy.io</option>
          <option value="https://api.allorigins.win/raw?url=">allorigins.win</option>
          <option value="custom">Custom...</option>
        </select>
        <input type="text" id="corsProxy" placeholder="Custom proxy URL" style="display:none; margin-bottom:4px;">
        <div style="font-size:0.6rem; color:#7f8c8d; margin-top:2px;">Browser CORS blocks direct Kraken calls. Select a
          proxy or use custom.</div>

        <button onclick="saveApiConfig(); event.stopPropagation();"
          style="margin-top:10px; padding:8px 16px; background:var(--accent); color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Save
          API Keys</button>
      </div>
    </div>

    <!-- Display Buttons for Address and Ledger Viewers -->
    <button id="address_btn" onclick="toggleAddressViewer()"
      style="width:100%; padding:8px; margin-top:10px; background:#27ae60; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Addresses</button>

    <!-- Address Viewer Panel (hidden by default) - click to close -->
    <div id="addressViewerSection" onclick="toggleAddressViewer()"
      style="display:none; margin-bottom:15px; padding:10px; background:#e8f5e9; border-radius:6px; max-height:300px; overflow-y:auto; border:2px solid #27ae60; cursor:pointer;">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #a5d6a7;">
        <span style="font-size:0.85rem; font-weight:700; color:#27ae60;">üìã Withdrawal Addresses (click to
          close)</span>
        <button onclick="event.stopPropagation(); copyAddressesToClipboard();"
          style="padding:4px 8px; background:#27ae60; color:#fff; border:none; border-radius:4px; font-size:0.6rem; cursor:pointer;">Copy
          to Clipboard</button>
      </div>
      <table id="addressTable" style="width:100%; font-size:0.6rem; border-collapse:collapse; table-layout:auto;">
        <thead style="position:sticky; top:0; z-index:1;">
          <tr style="background:#c8e6c9; text-align:left;">
            <th style="padding:2px; border:1px solid #a5d6a7; width:40px;">Asset</th>
            <th style="padding:2px; border:1px solid #a5d6a7;">Recipient</th>
            <th style="padding:2px; border:1px solid #a5d6a7;">Key Name</th>
            <th style="padding:2px; border:1px solid #a5d6a7;">Address</th>
            <th style="padding:2px; border:1px solid #a5d6a7; width:60px;">Dest Tag</th>
            <th style="padding:2px; border:1px solid #a5d6a7;">Info / Bank Details</th>
          </tr>
        </thead>
        <tbody id="addressTableBody">
          <tr>
            <td colspan="6" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded. Click "Pull
              Addresses" first.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <button id="ledger_btn" onclick="toggleLedgerViewer()"
      style="width:100%; padding:8px; margin-top:6px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Ledger</button>

    <!-- Ledger Viewer Panel (hidden by default) - click to close -->
    <div id="ledgerViewerSection" onclick="toggleLedgerViewer()"
      style="display:none; margin-bottom:15px; padding:10px; background:#e3f2fd; border-radius:6px; max-height:300px; overflow-y:auto; border:2px solid #16a085; cursor:pointer;">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #90caf9;">
        <span style="font-size:0.85rem; font-weight:700; color:#16a085;">üìä Ledger Data (click to close)</span>
        <button onclick="event.stopPropagation(); copyLedgerToClipboard();"
          style="padding:4px 8px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.6rem; cursor:pointer;">Copy
          to Clipboard</button>
      </div>
      <table id="ledgerTable" style="width:100%; font-size:0.6rem; border-collapse:collapse; table-layout:fixed;">
        <thead style="position:sticky; top:0; z-index:1;">
          <tr style="background:#bbdefb; text-align:left;">
            <th style="padding:4px; border:1px solid #90caf9; width:70px;">Date</th>
            <th style="padding:4px; border:1px solid #90caf9; width:70px;">Type</th>
            <th style="padding:4px; border:1px solid #90caf9; width:70px;">Time</th>
            <th style="padding:4px; border:1px solid #90caf9; width:80px;">Amount</th>
            <th style="padding:4px; border:1px solid #90caf9; width:60px;">Fee</th>
            <th style="padding:4px; border:1px solid #90caf9; width:50px;">Asset</th>
            <th style="padding:4px; border:1px solid #90caf9; width:80px;">Balance</th>
            <th style="padding:4px; border:1px solid #90caf9; width:140px;">Ledger ID</th>
            <th style="padding:4px; border:1px solid #90caf9;">Ref ID</th>
          </tr>
        </thead>
        <tbody id="ledgerTableBody">
          <tr>
            <td colspan="9" style="padding:8px; text-align:center; color:#7f8c8d;">No ledger data loaded. Click "Read
              Ledger" first.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Status Bar -->
    <div class="status-row">
      <div id="statusSummary" style="flex:4; display:flex; flex-wrap:wrap; gap:12px; font-size:0.7rem;">
        <div>Ref: <b id="withdrawalCount">0</b></div>
      </div>
      <div class="status-item" id="stagingHint" style="flex:1; text-align:right; font-size:0.65rem; color:#7f8c8d;">
      </div>
    </div>

    <!-- Bottom Actions -->
    <div style="display:flex; gap:6px; margin-top:10px;">
      <button onclick="handleSync()"
        style="flex:1; padding:8px 4px; background:var(--bridge); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Send
        Reports<br />to Sheets</button>
      <button onclick="saveLocalData()"
        style="flex:1; padding:8px 4px; background:var(--accent); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Save<br />Local</button>
      <button id="wipeBtn" onclick="handleWipeConfirm()"
        style="flex:1; padding:8px 4px; background:var(--danger); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer; opacity:0.85;">Clear
        Report<br />Staging</button>
      <button onclick="loadLocalData()"
        style="flex:1; padding:8px 4px; background:#8e44ad; color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Load<br />Local</button>
    </div>

    <!-- Copy Button moved inside Report -->

    <button id="report_btn" onclick="toggleReportViewer()"
      style="width:100%; padding:8px; margin-top:10px; background:#e67e22; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Trade/Withdrawal Report</button>

    <div class="preview-wrap" id="previewArea" style="display:none;"></div>

    <button id="btn_bank_statement" onclick="toggleBankReport()"
      style="width:100%; padding:8px; margin-top:10px; background:#2980b9; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">
      Kraken Statement (Select Dates)</button>

    <div class="preview-wrap" id="bankReportArea" style="display:none; margin-top:10px;"></div>

    <button id="btn_statement_summary" onclick="toggleSummaryReport()"
      style="width:100%; padding:8px; margin-top:5px; background:#2980b9; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer; display:none;">
      Statement Summary</button>

    <div class="preview-wrap" id="summaryReportArea" style="display:none; margin-top:10px;"></div>

    <button id="log_btn" onclick="toggleLog()"
      style="width:100%; padding:8px; margin-top:10px; background:#8e44ad; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Progress Log</button>
    <div id="trace_log" onclick="toggleLog()">Trace: v3.030 Kraken Withdrawals Report initialized.</div>
  </div>

  <script>
    window.onerror = function (message, source, lineno, colno) {
      logTrace("FATAL: " + message + " @ " + (source || "") + ":" + lineno + ":" + colno);
      updateStatus("Error Occurred", "error");
    };
    window.onunhandledrejection = function (ev) {
      logTrace("FATAL PROMISE: " + (ev && ev.reason ? (ev.reason.message || ev.reason) : "unknown"));
      updateStatus("Error Occurred", "error");
    };
  </script>

  <script>

    const SHEET_ID = "1Vf0iqthwHv0kFqTRJkYShH_RBpbokLmiEDWGJN3Q_E";
    const VER = "Kraken Withdrawals Report (v3.043)";
    const KRAKEN_API_URL = "https://api.kraken.com";

    // Default API credentials (enter your own in API Config)
    const DEFAULT_API_KEY = "";
    const DEFAULT_PRIVATE_KEY = "";

    // Cache data structure (v2.0)
    let cacheData = {
      withdrawals: [],        // from Kraken Ledgers API (withdrawals only)
      withdrawalHistory: [],  // from Kraken WithdrawStatus API
      krakenAddresses: [],    // from Kraken WithdrawAddresses API
      ratesCache: {},         // { "2024-11-02": { USDTGBP: 0.79, USDTEUR: 0.92, ... } }
      withdrawalCache: []     // v2.90: Store calculated withdrawal rows (with GBP) for reuse
    };

    let stagingRecords = [];
    let tokenClient;
    let resetConfirmed = false;
    let wipeConfirmed = false;
    let isGenerating = false;
    let reportResetConfirmed = false;

    // ---------- Logging ----------
    function logTrace(msg) {
      const log = document.getElementById("trace_log");
      const now = new Date().toLocaleTimeString();
      const base = log.textContent && log.textContent.trim().length
        ? log.textContent
        : "Trace: v3.025 Kraken Ledger Report initialized.";
      log.textContent = base + "\n[" + now + "] " + msg;
      log.scrollTop = log.scrollHeight;
      console.log(msg);
    }

    window.onerror = function (message, source, lineno, colno) {
      logTrace("FATAL: " + message + " @ " + (source || "") + ":" + lineno + ":" + colno);
      updateStatus("Error Occurred", "error");
    };
    window.onunhandledrejection = function (ev) {
      logTrace("FATAL PROMISE: " + (ev && ev.reason ? (ev.reason.message || ev.reason) : "unknown"));
      updateStatus("Error Occurred", "error");
    };

    function toggleLog() {
      const btn = document.getElementById("log_btn");
      const log = document.getElementById("trace_log");
      // Fix double-click issue: initially style.display is "" but CSS is "none"
      const isHidden = (log.style.display === "none" || log.style.display === "");
      // Keep button visible, just change label
      if (isHidden) {
        btn.textContent = "Display Progress Log (click to close)";
        log.style.display = "block";
      } else {
        btn.textContent = "Display Progress Log";
        log.style.display = "none";
      }
    }

    // Toggle report preview visibility
    function toggleReportViewer() {
      const btn = document.getElementById("report_btn");
      const area = document.getElementById("previewArea");
      const isHidden = area.style.display === "none";
      btn.innerText = isHidden ? "Hide Trade/Withdrawal Report" : "Display Trade/Withdrawal Report";
      area.style.display = isHidden ? "block" : "none";
    }

    function copyTraceToClipboard() {
      const log = document.getElementById("trace_log");
      const text = log.textContent || "";
      if (!text.trim() || text.trim() === "Trace: v2.15 Kraken Ledger Report initialized.") {
        alert("There are no trace log records to copy.");
        return;
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Trace log copied to clipboard!");
      });
    }

    function updateStatus(label, state) {
      const el = document.getElementById("auth_status");
      el.innerText = "Status: " + label;
      const colors = { idle: "#7f8c8d", active: "#27ae60", sync: "#e67e22", error: "#c0392b" };
      el.style.color = colors[state] || colors.idle;
    }

    // ---------- Date Handling ----------
    // ---------- Date Handling ----------
    function handleDateChange(id) {
      // Update Bank Report Button Label (Always run this)
      updateBankButtonLabel();

      const dStr = document.getElementById(id).value;
      const dispEl = document.getElementById(id + "Disp");
      if (!dispEl) return; // Element doesn't exist in new design, safe to exit if we only needed to update it

      if (!dStr) { dispEl.innerText = ""; return; }
      const [y, m, d] = dStr.split("-").map(Number);
      const dt = new Date(y, m - 1, d);
      const day = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][dt.getDay()];
      const mon = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][dt.getMonth()];
      dispEl.innerText = day + " " + dt.getDate() + " " + mon + " '" + String(dt.getFullYear()).slice(-2);
    }

    function updateBankButtonLabel() {
      const s = document.getElementById("startDate").value;
      const e = document.getElementById("endDate").value;
      const btn = document.getElementById("btn_bank_statement");

      if (s && e) {
        // Format dates nicely e.g. 01 Nov 2024
        const fmt = (dStr) => {
          const [y, m, d] = dStr.split("-");
          if (!m) return dStr;
          const mon = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][parseInt(m) - 1];
          return `${d} ${mon} ${y}`;
        };
        btn.textContent = `Kraken Statement ${fmt(s)} to ${fmt(e)}`;

        // Also show Summary Button
        const sumBtn = document.getElementById("btn_statement_summary");
        if (sumBtn) sumBtn.style.display = "block";
      } else {
        btn.textContent = "Kraken Statement (Select Dates)";
        const sumBtn = document.getElementById("btn_statement_summary");
        if (sumBtn) sumBtn.style.display = "none";
      }
    }

    // ---------- Reset / Wipe ----------
    function handleResetConfirm() {
      const btn = document.getElementById("resetBtn");
      if (!resetConfirmed) {
        resetConfirmed = true;
        btn.innerText = "CONFIRM?";
        setTimeout(() => { resetConfirmed = false; btn.innerText = "Reset"; }, 3000);
        return;
      }
      resetConfirmed = false;
      btn.innerText = "Reset";
      localReset();
    }

    function handleWipeConfirm() {
      const btn = document.getElementById("wipeBtn");
      if (!wipeConfirmed) {
        wipeConfirmed = true;
        btn.innerHTML = "CONFIRM?";
        setTimeout(() => { wipeConfirmed = false; btn.innerHTML = "Clear<br/>Staging"; }, 3000);
        return;
      }
      wipeConfirmed = false;
      btn.innerHTML = "Clear<br/>Staging";
      stagingRecords = [];
      localStorage.removeItem("kraken_staging");
      renderPreview();
      logTrace("Staging cleared manually.");
    }

    // Reset button with two-click confirmation - resets UI state without clearing data
    function handleReportReset() {
      const btn = document.getElementById("resetBtn");
      if (!reportResetConfirmed) {
        reportResetConfirmed = true;
        btn.innerText = "CONFIRM?";
        btn.style.animation = "pulse 0.5s ease-in-out";
        setTimeout(() => {
          reportResetConfirmed = false;
          btn.innerText = "Reset";
          btn.style.animation = "";
        }, 3000);
        return;
      }
      reportResetConfirmed = false;
      btn.innerText = "Reset";
      btn.style.animation = "";

      // Reset UI state and Clear ALL Data (Ledger, Reports, Cache)
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";

      // Clear Memory Variables
      stagingRecords = [];
      cacheData.withdrawals = [];
      cacheData.ratesCache = {};
      cacheData.withdrawalCache = [];
      if (typeof bankRecords !== 'undefined') bankRecords = [];
      if (typeof summaryRecords !== 'undefined') summaryRecords = { crypto: [], fiat: [], deposits: [], fees: [] };

      // Clear LocalStorage
      localStorage.removeItem("kraken_staging");
      localStorage.removeItem("kraken_v2_withdrawals");
      localStorage.removeItem("kraken_v2_rates");
      localStorage.removeItem("kraken_summary_staging");

      // Clear Views
      renderPreview();
      renderLedgerTable();
      const bankArea = document.getElementById("bankReportArea");
      if (bankArea) bankArea.style.display = 'none'; // Hide bank area
      const summaryArea = document.getElementById("summaryReportArea");
      if (summaryArea) summaryArea.style.display = 'none'; // Hide summary area

      updateStatus("Ready", "idle");
      updateStatusCounts(); // This calls updateGlobalRecordCounts internally now
      logTrace("=== APPLICATION RESET ===\nUI reset. Ledger cleared. Reports cleared.");
    }


    // Copy report to clipboard (tab-separated for spreadsheet paste)
    function copyReportToClipboard() {
      if (!stagingRecords.length) {
        alert("No report records to copy. Generate a report first.");
        return;
      }

      // Build header row - match the report table order
      const headers = ["Date", "Type", "Time (UTC)", "Recipient", "Sent to", "GBP Sent", "Amount", "Fee", "Asset", "GBP Fee", "Conv Rate", "Conv Currency", "Source", "Destination", "Dest Tag", "Transaction ID"];

      // Build data rows
      let text = headers.join("\t") + "\n";
      for (const r of stagingRecords) {
        const row = [
          r.dateSent,
          r.type || '',
          r.timeSent || '',
          r.recipient,
          r.sentTo || '',
          r.gbpSent || '',
          r.amount,
          r.fee,
          r.asset,
          r.gbpFee || '',
          r.conversionRate || '',
          r.conversionCurrency || '',
          r.rateSource || '',
          r.wallet,
          r.destTag,
          r.txId
        ];
        text += row.join("\t") + "\n";
      }




      navigator.clipboard.writeText(text).then(() => {
        alert("Report copied to clipboard! (" + stagingRecords.length + " records)");
        logTrace("Copied " + stagingRecords.length + " report records to clipboard");
      }).catch(err => {
        logTrace("ERROR copying to clipboard: " + err);
        alert("Failed to copy. Check browser permissions.");
      });
    }

    function localReset() {
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";
      updateStatusCounts();
      logTrace("UI Reset.");
    }

    // ---------- Status Display ----------
    function updateStatusCounts() {
      // Calculate categorized counts
      let wCrypto = 0, wFiat = 0, dFiat = 0;
      let tradesFiatToCrypto = 0, tradesCryptoToFiat = 0, tradesFiatToFiat = 0;

      for (const w of cacheData.withdrawals) {
        const type = (w.type || "").toLowerCase();
        const asset = (w.asset || "").toUpperCase();

        // Fix v2.80: Strict Fiat Check (Exclude USDT)
        // USDT contains "USD", so we must explicitly check.
        // Known Fiat: GBP, EUR, USD, ZGBP, ZEUR, ZUSD.
        // Known Crypto: USDT, XRP, XXRP, ETH, BTC, etc.
        const isUSDT = asset.includes("USDT");
        const isFiat = !isUSDT && (asset.includes("GBP") || asset.includes("EUR") || asset.includes("USD") || asset === "ZGBP" || asset === "ZEUR" || asset === "ZUSD");

        if (type === "withdrawal") {
          if (isFiat) wFiat++; else wCrypto++;
        } else if (type === "deposit") {
          if (isFiat) dFiat++;
        } else if (type === "trade") {
          // Count based on SPEND side (amount < 0) to avoid double counting pairs
          // Fiat -> Crypto (Buy): Spend Fiat (Amount < 0, Asset Fiat)
          // Crypto -> Fiat (Sell): Spend Crypto (Amount < 0, Asset Crypto)
          if (w.amount < 0) {
            // Find the "Buy" side (positive amount, same refid) to check its asset
            const buySide = cacheData.withdrawals.find(b => b.refid === w.refid && b.amount > 0);

            if (buySide) {
              const buyAsset = (buySide.asset || "").toUpperCase();
              const isBuyFiat = (buyAsset.includes("GBP") || buyAsset.includes("EUR") || buyAsset.includes("USD") || buyAsset === "ZGBP" || buyAsset === "ZEUR" || buyAsset === "ZUSD");

              if (isFiat && isBuyFiat) {
                tradesFiatToFiat++;
              } else if (isFiat) {
                tradesFiatToCrypto++;
              } else {
                tradesCryptoToFiat++;
              }
            } else {
              // Fallback if unmatched (shouldn't happen often)
              if (isFiat) tradesFiatToCrypto++;
              else tradesCryptoToFiat++;
            }
          }
        }
      }

      const totalTrades = tradesFiatToCrypto + tradesCryptoToFiat;

      const summaryHtml = `
        <div style="display:flex; flex-direction:column; gap:4px; align-items:flex-start;">
          <div class="status-item" style="width:100%;"><span style="color:#d35400;">Addresses:</span> <b id="addressCount">${cacheData.krakenAddresses.length}</b></div>
          <div class="status-item" style="width:100%;"><span style="color:#27ae60;">Withdrawals:</span> <b>${wCrypto}</b> Crypto / <b>${wFiat}</b> Fiat <span style="color:#bbb; margin:0 8px;">|</span> <span style="color:#2980b9;">Deposits:</span> <b>${dFiat}</b> Fiat</div>
          <div class="status-item" style="width:100%;"><span style="color:#8e44ad;">Trades:</span> <b>${tradesFiatToCrypto}</b> fiat&gt;crypto / <b>${tradesCryptoToFiat}</b> crypto&gt;fiat / <b>${tradesFiatToFiat}</b> fiat&gt;fiat</div>
        </div>
      `;

      const el = document.getElementById("statusSummary");
      if (el) el.innerHTML = summaryHtml;

      // Keep legacy IDs updated just in case
      const wCount = document.getElementById("withdrawalCount");
      if (wCount) wCount.innerText = cacheData.withdrawals.length;

      const aCount = document.getElementById("addressCount");
      if (aCount) aCount.innerText = cacheData.krakenAddresses.length;

      updateGlobalRecordCounts(); // Ensure detailed counts are updated
    }

    // ---------- CORS Proxy Handling ----------
    function handleProxyChange() {
      const select = document.getElementById("corsProxySelect");
      const customInput = document.getElementById("corsProxy");
      if (select.value === "custom") {
        customInput.style.display = "block";
        customInput.focus();
      } else {
        customInput.style.display = "none";
        customInput.value = "";
      }
    }

    function getSelectedProxy() {
      const select = document.getElementById("corsProxySelect");
      const customInput = document.getElementById("corsProxy");
      if (select.value === "custom") {
        return customInput.value.trim();
      }
      return select.value;
    }

    // ---------- Local Save/Load (v2.0) ----------
    function saveLocalData() {
      if (cacheData.withdrawals.length === 0) {
        alert("Fetch data first before saving.");
        return;
      }
      localStorage.setItem("kraken_v2_withdrawals", JSON.stringify(cacheData.withdrawals));
      localStorage.setItem("kraken_v2_history", JSON.stringify(cacheData.withdrawalHistory));
      localStorage.setItem("kraken_v2_addresses", JSON.stringify(cacheData.krakenAddresses));
      localStorage.setItem("kraken_v2_rates", JSON.stringify(cacheData.ratesCache));
      logTrace("Data saved to localStorage.");
      alert("Data saved to local storage.");
    }

    function loadLocalData() {
      const cached = localStorage.getItem("kraken_v2_withdrawals");
      if (!cached) {
        alert("No saved data found. Use 'Fetch & Generate Report' first.");
        return;
      }
      cacheData.withdrawals = JSON.parse(cached || "[]");
      cacheData.withdrawalHistory = JSON.parse(localStorage.getItem("kraken_v2_history") || "[]");
      cacheData.krakenAddresses = JSON.parse(localStorage.getItem("kraken_v2_addresses") || "[]");
      cacheData.ratesCache = JSON.parse(localStorage.getItem("kraken_v2_rates") || "{}");
      updateStatusCounts();
      logTrace("Loaded from localStorage. Withdrawals=" + cacheData.withdrawals.length);

      // Regenerate report from cached data
      generateReportFromCache();
    }

    function saveApiConfig() {
      const apiKey = document.getElementById("krakenApiKey").value;
      const privateKey = document.getElementById("krakenPrivateKey").value;
      const withdrawKey = document.getElementById("withdrawApiKey").value;
      const withdrawPrivate = document.getElementById("withdrawPrivateKey").value;
      const sheetId = document.getElementById("googleSheetId").value;
      const proxy = getSelectedProxy();

      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      localStorage.setItem("kraken_withdraw_api_key", withdrawKey);
      localStorage.setItem("kraken_withdraw_private_key", withdrawPrivate);
      localStorage.setItem("kraken_sheet_id", sheetId);
      localStorage.setItem("kraken_cors_proxy", proxy);
      localStorage.setItem("kraken_cors_proxy_type", document.getElementById("corsProxySelect").value);

      logTrace("API credentials saved (Query + Withdraw).");
      alert("API keys saved.");
    }

    // ========== STEP 1: Read Ledger (Query API - no 2FA needed) ==========
    async function readLedger() {
      // Validate date range
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;

      if (!startDate || !endDate) {
        // alert("Please select Start Date and End Date first.");
        logTrace("WARNING: User attempted to read ledger without setting dates.");
        updateStatus("Set Date Range", "error");
        logTrace("ERROR: Date range not set");
        return;
      }

      const startTime = new Date(startDate).getTime() / 1000;
      const endTime = new Date(endDate + "T23:59:59").getTime() / 1000;

      logTrace("=== READ LEDGER ===");
      logTrace("Date range: " + startDate + " to " + endDate);
      logTrace("Unix range: " + startTime + " to " + endTime);

      try {
        const creds = getApiCredentials();
        logTrace("Using Query API Key: " + creds.apiKey.substring(0, 8) + "...");
        logTrace("Proxy: " + (creds.proxy || "(none)"));

        updateStatus("Reading Ledger...", "sync");

        // Paginate through ALL ledger records (all types)
        const allLedgerEntries = [];
        let offset = 0;
        let hasMore = true;
        let totalCount = 0;

        while (hasMore) {
          logTrace("Calling Kraken Ledgers API (offset=" + offset + ")...");
          const ledgerResult = await callKrakenPrivateAPI("Ledgers", {
            // No type filter - get all types: withdrawal, deposit, trade, etc.
            start: Math.floor(startTime),
            end: Math.floor(endTime),
            ofs: offset
          }, creds);

          // Get total count from first response
          if (offset === 0 && ledgerResult.count) {
            totalCount = ledgerResult.count;
            logTrace("Total ledger entries (all types): " + totalCount);
          }

          const ledgerData = ledgerResult.ledger || {};
          const batchSize = Object.keys(ledgerData).length;
          logTrace("Batch " + (Math.floor(offset / 50) + 1) + ": " + batchSize + " records");

          if (batchSize === 0) {
            hasMore = false;
            break;
          }

          // Parse and filter for USDT/XRP
          for (const [ledgerId, entry] of Object.entries(ledgerData)) {
            const asset = (entry.asset || "").toUpperCase();
            // Include USDT, XRP. Also include Fiat assets (GBP, EUR, USD) to detect Fiat Deposits
            const isCrypto = asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP";
            const isFiat = asset.includes("GBP") || asset.includes("EUR") || asset.includes("USD") ||
              asset === "ZGBP" || asset === "ZEUR" || asset === "ZUSD";

            if (isCrypto || isFiat) {
              allLedgerEntries.push({
                ledgerId,
                refid: entry.refid,
                time: entry.time,
                type: entry.type || "unknown",  // withdrawal, deposit, trade, etc.
                asset: asset,
                amount: parseFloat(entry.amount || 0),
                fee: parseFloat(entry.fee || 0),
                balance: parseFloat(entry.balance || 0)
              });
            }
          }

          offset += batchSize;

          // Stop if we've fetched fewer than 50 records (no more pages)
          if (batchSize < 50) {
            hasMore = false;
          }

          // Add delay between requests to avoid rate limiting (1 second)
          if (hasMore) {
            await new Promise(r => setTimeout(r, 1000));
          }
        }

        // --- CLASSIFY TRADES (One-Time Pass) ---
        // Group by RefID to analyze the full context of each trade (Trade Pairs)
        const tradeGroups = {};
        for (const entry of allLedgerEntries) {
          if (entry.type === 'trade') {
            if (!tradeGroups[entry.refid]) tradeGroups[entry.refid] = [];
            tradeGroups[entry.refid].push(entry);
          }
        }

        for (const [refid, group] of Object.entries(tradeGroups)) {
          // Identify assets involved in this trade
          let hasFiat = false;
          let hasCrypto = false;

          group.forEach(t => {
            const a = t.asset.toUpperCase();
            const isFiat = a.includes("GBP") || a.includes("EUR") || a.includes("USD") || a === "ZGBP" || a === "ZEUR";
            if (isFiat) hasFiat = true;
            else hasCrypto = true; // Assumption: if not fiat, it's crypto (USDT, XRP, ETH etc)
          });

          let typeLabel = "unknown";
          if (hasFiat && hasCrypto) {
            // Determine direction? 
            // Spend Fiat -> Buy Crypto (Fiat -> Crypto)
            // Spend Crypto -> Buy Fiat (Crypto -> Fiat)
            // We check the SPEND side (negative amount)
            const spendSide = group.find(t => t.amount < 0);
            if (spendSide) {
              const a = spendSide.asset.toUpperCase();
              const spendIsFiat = a.includes("GBP") || a.includes("EUR") || a.includes("USD") || a === "ZGBP" || a === "ZEUR";
              typeLabel = spendIsFiat ? "fiat-crypto" : "crypto-fiat";
            } else {
              typeLabel = "fiat-crypto"; // Fallback/Mixed
            }
          } else if (hasFiat && !hasCrypto) {
            typeLabel = "fiat-fiat";
          } else if (!hasFiat && hasCrypto) {
            typeLabel = "crypto-crypto";
          }

          // TAG EVERY ROW IN THIS GROUP with the global classification
          group.forEach(t => t.tradeScope = typeLabel);
        }

        cacheData.withdrawals = allLedgerEntries;  // Still use withdrawals key for compatibility
        updateStatusCounts();
        renderLedgerTable();

        logTrace("SUCCESS: Fetched " + allLedgerEntries.length + " USDT/XRP entries (from " + offset + " total entries)");
        updateStatus("Ledger: " + allLedgerEntries.length, "active");


      } catch (e) {
        updateStatus("Ledger Error", "error");
        logTrace("ERROR in readLedger: " + (e.message || e));
        // alert("Error reading ledger: " + (e.message || e));
      }
    }

    // ========== STEP 2: Pull Addresses (Withdraw API - requires 2FA) ==========
    async function pullAddresses() {
      logTrace("=== PULL ADDRESSES ===");

      // Prompt for 2FA
      const otp = prompt("Enter your Kraken 2FA code:");
      if (!otp || otp.trim() === "") {
        logTrace("2FA cancelled by user");
        return;
      }

      try {
        const creds = getWithdrawCredentials();
        logTrace("Using Withdraw API Key: " + creds.apiKey.substring(0, 8) + "...");

        updateStatus("Pulling Addresses...", "sync");

        // Call WithdrawAddresses API
        logTrace("Calling Kraken WithdrawAddresses API...");
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, creds);

        cacheData.krakenAddresses = addresses || [];
        logTrace("SUCCESS: Fetched " + cacheData.krakenAddresses.length + " addresses");

        // Also fetch withdrawal history for destination details
        logTrace("Calling WithdrawStatus API...");
        await fetchWithdrawalHistory(otp.trim());

        updateStatusCounts();

        // Log structure of first address to inspect fields (User Request v2.48)
        if (cacheData.krakenAddresses.length > 0) {
          logTrace("DEBUG: First address structure keys: " + Object.keys(cacheData.krakenAddresses[0]).join(", "));
          logTrace("DEBUG: First address sample: " + JSON.stringify(cacheData.krakenAddresses[0]));
        }

        renderAddressTable();

        updateStatus("Addresses: " + cacheData.krakenAddresses.length, "active");

      } catch (e) {
        updateStatus("Address Error", "error");
        logTrace("ERROR in pullAddresses: " + (e.message || e));
        // alert("Error pulling addresses: " + (e.message || e));
      }
    }

    // ========== STEP 3: Generate Report (local processing only) ==========
    async function generateReport() {
      // Prevent double-click / concurrent generation
      if (isGenerating) {
        logTrace("Report generation already in progress - ignoring click");
        return;
      }

      const btn = document.getElementById("generate_btn");
      isGenerating = true;
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = "Generating...<br/>Please wait";
        btn.style.opacity = "0.6";
      }

      logTrace("=== GENERATE REPORT ===");

      // Auto-Clear other reports to prevent stale data
      bankRecords = [];
      summaryRecords = { withdrawals: [], deposits: [] };
      localStorage.removeItem("kraken_bank_staging");
      localStorage.removeItem("kraken_summary_staging");

      const bankArea = document.getElementById("bankReportArea");
      if (bankArea) bankArea.style.display = "none";
      const summArea = document.getElementById("summaryReportArea");
      if (summArea) summArea.style.display = "none";

      const sBtn = document.getElementById("btn_bank_statement");
      if (sBtn) {
        // Reset button text checks and force update based on current dates
        if (sBtn.textContent === "Generating...") sBtn.textContent = "Kraken Statement (Select Dates)";

        // Force update of label and Summary button visibility based on dates
        updateBankButtonLabel();
      }

      // Check prerequisites
      if (cacheData.withdrawals.length === 0) {
        logTrace("Action Required: Please click 'Read Ledger' before generating a report.");
        updateStatus("No Ledger Data", "idle");
        resetGenerateButton(btn);
        return;
      }

      if (cacheData.krakenAddresses.length === 0) {
        logTrace("Action Required: Please click 'Pull Addresses' to enrich the report with recipient names.");
        updateStatus("No Addresses", "idle");
        resetGenerateButton(btn);
        return;
      }

      try {
        // Generate report from cached data
        await generateReportFromCache();
      } finally {
        resetGenerateButton(btn);
      }
    }

    function resetGenerateButton(btn) {
      isGenerating = false;
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = "Generate<br/>Report";
        btn.style.opacity = "1";
      }
    }

    // ========== Toggle Ledger Viewer ==========
    function toggleLedgerViewer() {
      const btn = document.getElementById("ledger_btn");
      const section = document.getElementById("ledgerViewerSection");
      const isHidden = section.style.display === "none";
      // Keep button visible, just change label
      if (isHidden) {
        btn.textContent = "Display Ledger (click to close)";
        section.style.display = "block";
        renderLedgerTable();
      } else {
        btn.textContent = "Display Ledger";
        section.style.display = "none";
      }
    }

    // ========== Render Ledger Table ==========
    function renderLedgerTable() {
      const tbody = document.getElementById("ledgerTableBody");
      if (cacheData.withdrawals.length === 0) {
        tbody.innerHTML = '<tr><td colspan="9" style="padding:8px; text-align:center; color:#7f8c8d;">No ledger data loaded.</td></tr>';
        return;
      }

      let html = "";
      for (const w of cacheData.withdrawals) {
        const dateStr = formatTimestamp(w.time);
        const timeStr = formatTime(w.time);
        html += "<tr>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(dateStr) + "</td>";
        html += '<td style="padding:4px 4px 4px 1px; border:1px solid #90caf9;">' + escHtml(w.type || "") + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(timeStr) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + w.amount.toFixed(6) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + Math.abs(w.fee).toFixed(6) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(w.asset) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + w.balance.toFixed(6) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9; word-break:break-all;">' + escHtml(w.ledgerId || "") + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9; word-break:break-all;">' + escHtml(w.refid || "") + "</td>";
        html += "</tr>";
      }
      tbody.innerHTML = html;
      updateGlobalRecordCounts();
    }

    // ========== Copy to Clipboard Functions ==========
    function copyAddressesToClipboard() {
      if (cacheData.krakenAddresses.length === 0) {
        alert("No addresses to copy.");
        return;
      }
      let text = "Asset\tRecipient\tKey Name\tAddress\tDest Tag\tInfo\n";
      for (const a of cacheData.krakenAddresses) {
        const recipient = (a.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20)\s*/gi, "").trim();
        text += (a.asset || "") + "\t" + recipient + "\t" + (a.key || "") + "\t" + (a.address || "") + "\t" + (a.tag || a.memo || "") + "\t" + (a.info || "") + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Addresses copied to clipboard!");
        logTrace("Copied " + cacheData.krakenAddresses.length + " addresses to clipboard");
      });
    }

    function copyReportToClipboard() {
      if (!stagingRecords || stagingRecords.length === 0) {
        alert("No report data to copy.");
        return;
      }

      let text = "Date\tType\tTime\tRecipient\tSentTo\tGBPSent\tAmount\tFee\tAsset\tGBPFee\tRate\tCurrency\tSource\tDest\tTag\tTxID\n";

      for (const r of stagingRecords) {
        text += `${r.dateSent}\t${r.type}\t${r.timeSent}\t${r.recipient}\t${r.sentTo}\t${r.gbpSent}\t${r.amount}\t${r.fee}\t${r.asset}\t${r.gbpFee}\t${r.conversionRate}\t${r.conversionCurrency}\t${r.rateSource}\t${r.wallet}\t${r.destTag}\t${r.txId}\n`;
      }

      navigator.clipboard.writeText(text).then(() => {
        alert("Report copied to clipboard! Ready to paste into Excel/Sheets.");
      });
    }

    function copyLedgerToClipboard() {
      if (cacheData.withdrawals.length === 0) {
        alert("No ledger data to copy.");
        return;
      }
      let text = "Date\tAsset\tAmount\tFee\tRefID\n";
      for (const w of cacheData.withdrawals) {
        text += formatTimestamp(w.time) + "\t" + w.asset + "\t" + Math.abs(w.amount) + "\t" + Math.abs(w.fee) + "\t" + (w.refid || "") + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Ledger data copied to clipboard!");
        logTrace("Copied " + cacheData.withdrawals.length + " ledger entries to clipboard");
      });
    }

    // Helper for detailed record counts (User Requested Format)
    function updateGlobalRecordCounts() {
      const hint = document.getElementById("stagingHint");
      if (!hint) return;

      const ledgerCount = (cacheData.withdrawals && Array.isArray(cacheData.withdrawals)) ? cacheData.withdrawals.length : 0;
      const reportCount = (stagingRecords && Array.isArray(stagingRecords)) ? stagingRecords.length : 0;
      const bankCount = (typeof bankRecords !== 'undefined' && Array.isArray(bankRecords)) ? bankRecords.length : 0;

      // Calculate Reconciliations for Tooltip
      const depositCount = cacheData.withdrawals.filter(w => w.type === 'deposit').length;


      const tooltipText = `Logic Breakdown:\n` +
        `1. Ledger (${ledgerCount}): All raw records.\n` +
        `2. T/W Report (${reportCount}): Detailed list (Should match Ledger).\n` +
        `3. Statement (${bankCount}): Low count expected (Merges 2x Trade lines into 1).`;

      // Flex layout for vertical stacking: Label | Ledger | Trade/Withdraw Report | Statement Report
      hint.innerHTML = `
        <div style="display:flex; gap:15px; align-items:center; flex-wrap:wrap;">
          <!-- Col 1: Label -->
          <div style="display:flex; flex-direction:column; align-items:flex-start; line-height:1.2; color:#333; font-weight:600;" title="${tooltipText}">
            <span>Number of</span>
            <span>Records</span>
          </div>

          <!-- Col 2: Ledger -->
          <div style="display:flex; flex-direction:column; align-items:flex-start; line-height:1.2; color:#16a085; min-width:50px;">
            <span style="font-size:0.6rem;">Ledger</span>
            <span style="font-weight:800; font-size:0.9rem;">${ledgerCount}</span>
          </div>

          <!-- Col 3: Trade/Withdraw Report -->
          <div style="display:flex; flex-direction:column; align-items:flex-start; line-height:1.2; color:#d35400; min-width:50px;">
            <span style="font-size:0.6rem;">T/W Report</span>
            <span style="font-weight:800; font-size:0.9rem;">${reportCount}</span>
          </div>

          <!-- Col 4: Statement Report -->
          <div style="display:flex; flex-direction:column; align-items:flex-start; line-height:1.2; color:#2980b9; min-width:50px;">
            <span style="font-size:0.6rem;">Statement</span>
            <span style="font-weight:800; font-size:0.9rem;">${bankCount}</span>
          </div>
        </div>
      `;
    }

    // ---------- Staging Table Render ----------
    function renderPreview() {
      const area = document.getElementById("previewArea");

      updateGlobalRecordCounts(); // Update counts on render

      if (!stagingRecords.length) {
        area.innerHTML = "";
        return;
      }

      // Header for Preview
      let html = '<div onclick="toggleReportViewer()" style="cursor:pointer; background:#d35400; color:#fff; padding:6px 10px; font-size:0.75rem; font-weight:bold; border-radius:4px 4px 0 0; display:flex; justify-content:space-between; align-items:center;" title="Click to close report">';
      html += '<span>Trades, Withdrawals, Deposits</span>';
      html += '<button onclick="event.stopPropagation(); copyReportToClipboard()" title="Copy Table" style="padding:2px 8px; background:#fff; color:#d35400; border:none; border-radius:3px; font-size:0.65rem; font-weight:600; cursor:pointer;">&#x2398; Copy Table</button>';
      html += '</div>';

      html += '<div style="overflow-x:auto;">';
      html += '<table style="width:100%; min-width:1200px; border-collapse:collapse;"><thead><tr>';
      html += '<th class="w-date">Date</th>';
      html += '<th class="w-type">Type</th>';
      html += '<th class="w-time">Time (UTC)</th>';
      html += '<th class="w-recipient">Recipient</th>';
      html += '<th class="w-sentto">Sent to</th>';
      html += '<th class="w-gbp">GBP Sent</th>';
      html += '<th class="w-amount">Amount (Asset)</th>';
      html += '<th class="w-fee">Fee (Asset)</th>';
      html += '<th class="w-asset">Asset</th>';
      html += '<th class="w-gbpfee">GBP Fee</th>';
      html += '<th class="w-rate">Conv Rate</th>';
      html += '<th class="w-cur">Conv Currency</th>';
      html += '<th class="w-source">Source</th>';
      html += '<th class="w-wallet">Destination</th>';
      html += '<th class="w-desttag">Dest Tag</th>';
      html += '<th class="w-txid">Transaction ID</th>';
      html += '</tr></thead><tbody>';

      for (const r of stagingRecords) {
        html += '<tr>';
        html += '<td class="w-date">' + escHtml(r.dateSent) + '</td>';
        html += '<td class="w-type">' + escHtml(r.type || '') + '</td>';
        html += '<td class="w-time">' + escHtml(r.timeSent || '') + '</td>';
        html += '<td class="w-recipient">' + escHtml(r.recipient) + '</td>';
        html += '<td class="w-sentto">' + escHtml(r.sentTo || '') + '</td>';
        html += '<td class="w-gbp">' + escHtml(r.gbpSent || '') + '</td>';
        html += '<td class="w-amount">' + escHtml(r.amount) + '</td>';
        html += '<td class="w-fee">' + escHtml(r.fee) + '</td>';
        html += '<td class="w-asset">' + escHtml(r.asset) + '</td>';
        html += '<td class="w-gbpfee">' + escHtml(r.gbpFee || '') + '</td>';
        html += '<td class="w-rate">' + escHtml(r.conversionRate || '') + '</td>';
        html += '<td class="w-cur">' + escHtml(r.conversionCurrency || '') + '</td>';
        html += '<td class="w-source">' + escHtml(r.rateSource || '') + '</td>';
        html += '<td class="w-wallet">' + escHtml(r.wallet) + '</td>';
        html += '<td class="w-desttag">' + escHtml(r.destTag) + '</td>';
        html += '<td class="w-txid">' + escHtml(r.txId) + '</td>';
        html += '</tr>';
      }

      html += '</tbody></table>';
      area.innerHTML = html;
    }


    function escHtml(s) {
      if (s === null || s === undefined) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    // Parse Kraken date strings like "2024-11-02 08:42:24" to Unix timestamp
    function parseDateString(dateStr) {
      try {
        if (!dateStr && dateStr !== 0) return 0;

        // If it's already a number, return it directly (Unix timestamp in seconds)
        if (typeof dateStr === "number") {
          if (isNaN(dateStr)) return 0;
          return dateStr;
        }

        // Convert to string for parsing
        const str = String(dateStr).trim();
        if (!str) return 0;

        // If it's a numeric string without dashes, could be Unix timestamp OR Excel serial date
        const numVal = parseFloat(str);
        if (!isNaN(numVal) && str.indexOf("-") === -1) {
          // Excel serial dates are small numbers (days since 1900-01-01)
          // A date in 2024 is around 45000 in Excel format
          // Unix timestamps in seconds for 2024 are around 1700000000
          if (numVal < 100000) {
            // This is likely an Excel serial date, convert to Unix timestamp
            // Excel epoch is 1900-01-01, but Excel incorrectly considers 1900 a leap year
            // So we adjust by subtracting 25569 (days between 1900-01-01 and 1970-01-01)
            // Then multiply by 86400 (seconds per day)
            const excelEpoch = (numVal - 25569) * 86400;
            logTrace("DEBUG: Converted Excel date " + numVal + " to Unix " + excelEpoch);
            return excelEpoch;
          }

          // If number is very large (> year 2100 in seconds), it's likely milliseconds
          if (numVal > 4102444800) {
            return numVal / 1000;
          }
          return numVal;
        }

        // Parse date string like "2024-11-02 08:42:24"
        const dt = new Date(str.replace(" ", "T"));
        const result = dt.getTime() / 1000;

        // Check for invalid date
        if (isNaN(result)) {
          logTrace("WARNING: Could not parse date: '" + str + "'");
          return 0;
        }

        return result;
      } catch (e) {
        logTrace("ERROR parsing date: " + e.message);
        return 0;
      }
    }

    function extractDestTag(refid) {
      // Destination tag often appears as a numeric suffix or can be parsed from description
      // For now, return empty - will need refinement based on actual data format
      const match = String(refid).match(/\d{6,}/);
      return match ? match[0] : "";
    }

    function extractWallet(refid) {
      // Wallet address extraction - placeholder
      return "";
    }

    function extractFiatCurrency(trade) {
      const pair = (trade.pair || "").toUpperCase();
      if (pair.includes("GBP") || pair.includes("ZGBP")) return "GBP";
      if (pair.includes("EUR") || pair.includes("ZEUR")) return "EUR";
      if (pair.includes("USD") || pair.includes("ZUSD")) return "USD";
      return "";
    }

    function calculateGBPEquivalent(trade) {
      const cost = parseFloat(trade.cost || 0);
      const cur = extractFiatCurrency(trade);
      if (cur === "GBP") return cost.toFixed(2);
      if (cur === "EUR") return (cost * 0.86).toFixed(2); // Approximate EUR‚ÜíGBP
      if (cur === "USD") return (cost * 0.79).toFixed(2); // Approximate USD‚ÜíGBP
      return cost.toFixed(2);
    }

    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const d = String(dt.getDate()).padStart(2, "0");
      const m = String(dt.getMonth() + 1).padStart(2, "0");
      const y = dt.getFullYear();
      return d + "/" + m + "/" + y;
    }

    // ---------- Google Auth / Sheets ----------
    function gapiLoaded() {
      gapi.load("client", async () => {
        await gapi.client.init({ apiKey: "AIzaSyDvZ1XZw5bZgWSB9zaU7h9Vtn7MhDGFMSM" });
        await gapi.client.load("sheets", "v4");
        logTrace("GAPI Ready.");
      });
    }

    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: "23231735212-jtgur3sn2ndh798ke00pm2a1d5rkd4eu.apps.googleusercontent.com",
        scope: "https://www.googleapis.com/auth/spreadsheets",
        prompt: "consent", // Force re-consent to clear stale tokens
        callback: () => { }
      });
      logTrace("GIS Ready.");
    }

    function initRefresh() {
      requestToken(true, () => fetchAllSheets());
    }

    function requestToken(forcePrompt, onOk) {
      tokenClient.callback = (resp) => {
        if (!resp || !resp.access_token) return;
        const issuedAt = Date.now();
        const expiresIn = resp.expires_in ? Number(resp.expires_in) : 3600;
        localStorage.setItem("g_token", resp.access_token);
        localStorage.setItem("g_token_issued_at", String(issuedAt));
        localStorage.setItem("g_token_expires_in", String(expiresIn));
        gapi.client.setToken({ access_token: resp.access_token });
        onOk();
      };
      const args = forcePrompt ? { prompt: "consent" } : { prompt: "" };
      tokenClient.requestAccessToken(args);
    }

    function ensureTokenThen(onOk) {
      const tok = localStorage.getItem("g_token");
      const issuedAt = Number(localStorage.getItem("g_token_issued_at") || "0");
      const exp = Number(localStorage.getItem("g_token_expires_in") || "0");
      const age = (Date.now() - issuedAt) / 1000;

      if (tok && issuedAt && exp && age < (exp - 60)) {
        gapi.client.setToken({ access_token: tok });
        onOk();
        return;
      }
      requestToken(true, onOk);
    }

    function saveSheetId(val) {
      if (val) localStorage.setItem("kraken_sheet_id", val.trim());
    }

    async function handleSync() {
      // Get ID from storage or default
      const storedSheetId = localStorage.getItem("kraken_sheet_id");
      const targetSheetId = storedSheetId || SHEET_ID;

      // We allow sync if ANY of the staging datasets are present, not just the Report staging
      // But typically user generates reports first.

      const hasStaging = stagingRecords.length > 0;
      const hasBank = (typeof bankRecords !== "undefined" && bankRecords.length > 0);
      const hasSummary = (typeof summaryRecords !== "undefined" && summaryRecords.crypto && (summaryRecords.crypto.length > 0 || summaryRecords.fiat.length > 0 || summaryRecords.deposits.length > 0));

      if (!hasStaging && !hasBank && !hasSummary) {
        alert("No reports generated to sync. Please generate a report first.");
        return;
      }

      updateStatus("Syncing...", "sync");
      logTrace(`Sync started. Target Sheet=${targetSheetId.substr(0, 10)}...`);
      logTrace(`Records: Staging=${stagingRecords.length}, Bank=${hasBank ? bankRecords.length : 0}, Summary=${hasSummary ? "yes" : "no"}`);

      ensureTokenThen(async () => {
        try {
          // Verify Sheet Access First (cheap check)
          try {
            await gapi.client.sheets.spreadsheets.get({ spreadsheetId: targetSheetId });
          } catch (err) {
            throw new Error("Cannot access Sheet. Please check the ID in API Config and ensure you have permission (404/403).");
          }

          // 1. ReportStaging
          if (hasStaging) {
            const headers = [
              "Date", "Type", "Time (UTC)", "Recipient", "Sent to", "GBP Sent", "Amount", "Fee", "Asset",
              "GBP Fee", "Conv Rate", "Conv Currency", "Source", "Destination", "Dest Tag", "Transaction ID"
            ];

            const vals = stagingRecords.map(r => {
              // v3.022: Format Based on Asset Type
              const asset = (r.asset || "").toUpperCase();
              const isCrypto = asset.includes("USDT") || asset.includes("XRP") || asset.includes("BTC") || asset.includes("ETH");
              const decimals = isCrypto ? 4 : 2;

              const fmt = (v) => (v !== undefined && v !== "") ? parseFloat(v).toFixed(decimals) : "";
              const fmtFiat = (v) => (v !== undefined && v !== "") ? parseFloat(v).toFixed(2) : "";

              return [
                r.dateSent, r.type || '', r.timeSent || '', r.recipient, r.sentTo || '', fmtFiat(r.gbpSent),
                fmt(r.amount), fmt(r.fee), r.asset, fmtFiat(r.gbpFee), r.conversionRate || '', r.conversionCurrency || '',
                r.rateSource || '', r.wallet, r.destTag, r.txId
              ];
            });

            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: "'ReportStaging'!A:Z" });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'ReportStaging'!A1:P1", valueInputOption: "USER_ENTERED", resource: { values: [headers] }
            });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'ReportStaging'!A2:P" + (1 + vals.length), valueInputOption: "USER_ENTERED", resource: { values: vals }
            });
            logTrace("ReportStaging exported.");
          }

          // 2. KrakenLedger
          if (cacheData.withdrawals && cacheData.withdrawals.length > 0) {
            const ledgerHeaders = ["Date", "Type", "Time", "Amount", "Fee", "Asset", "Balance", "Ledger ID", "Ref ID"];
            const ledgerVals = cacheData.withdrawals.map(w => [
              w.time ? formatTimestamp(w.time) : '', w.type || '', w.time ? formatTime(w.time) : '', w.amount || 0, w.fee || 0,
              w.asset || '', w.balance || 0, w.ledgerId || '', w.refid || ''
            ]);
            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: "'KrakenLedger'!A:Z" });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenLedger'!A1:I1", valueInputOption: "USER_ENTERED", resource: { values: [ledgerHeaders] }
            });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenLedger'!A2:I" + (1 + ledgerVals.length), valueInputOption: "USER_ENTERED", resource: { values: ledgerVals }
            });
            logTrace("KrakenLedger exported.");
          }

          // 3. KrakenStatement
          if (hasBank) {
            let header1 = ["Date", "Time", "Type", "Details"];
            let header2 = ["", "", "", ""];
            TRACKED_ASSETS.forEach(a => {
              header1.push(a, "", "");
              header2.push("Amount", "P/L Fee", "Balance");
            });

            const bankVals = bankRecords.map(r => {
              let row = [r.date, r.time, r.type, r.details];
              TRACKED_ASSETS.forEach(asset => {
                const amt = r.amounts[asset];
                const fee = r.fees[asset];
                const bal = r.balances[asset];

                // Formatting Logic
                const isFiat = (asset === "GBP" || asset === "EUR");
                const decimals = isFiat ? 2 : 4;

                const fmt = (val) => {
                  if (val === undefined || val === "") return "";
                  return parseFloat(val).toFixed(decimals);
                };

                // Special case: Amount can be 0, we want to show 0.00 if it exists
                // But in the object model, undefined means "no entry for this column".

                row.push(amt !== undefined ? fmt(amt) : "");
                row.push((fee !== undefined && fee > 0) ? fmt(fee) : "");
                row.push(bal !== undefined ? fmt(bal) : "");
              });
              return row;
            });

            const rangeReq = "'KrakenStatement'!A:Z";
            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: rangeReq });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenStatement'!A1", valueInputOption: "USER_ENTERED", resource: { values: [header1, header2] }
            });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenStatement'!A3", valueInputOption: "USER_ENTERED", resource: { values: bankVals }
            });
            logTrace("KrakenStatement exported.");
          }

          // 4. KrakenStatementSummary
          if (hasSummary) {
            let s1Headers = ["Withdrawals to Recipients (USDT XRP)", "", "", "", "", "", ""];
            let s1ColHeaders = ["Recipient", "USDT", "Avg Rate", "GBP Equivalent", "XRP Amount", "Avg Rate", "GBP Equivalent"];

            let s1Rows = [];
            const fmt = (v, d) => (v && parseFloat(v) !== 0) ? parseFloat(v).toFixed(d) : "-";

            if (summaryRecords.crypto && summaryRecords.crypto.length > 0) {
              s1Rows = summaryRecords.crypto.map(r => {
                const usdtRate = (r.USDT > 0 && r.USDT_GBP > 0) ? (r.USDT_GBP / r.USDT).toFixed(4) : "";
                const xrpRate = (r.XRP > 0 && r.XRP_GBP > 0) ? (r.XRP_GBP / r.XRP).toFixed(4) : "";
                return [
                  r.recipient,
                  fmt(r.USDT, 4),
                  usdtRate,
                  fmt(r.USDT_GBP, 2),
                  fmt(r.XRP, 4),
                  xrpRate,
                  fmt(r.XRP_GBP, 2)
                ];
              });
            } else {
              s1Rows = [["", "-", "", "-", "-", "", "-"]];
            }

            let s2Headers = ["Withdrawals to Haricom Bank Accounts (GBP EUR)", "", ""];
            let s2ColHeaders = ["Haricom Bank Account", "GBP Amount", "EUR Amount"];
            let s2Rows = [];
            if (summaryRecords.fiat && summaryRecords.fiat.length > 0) {
              s2Rows = summaryRecords.fiat.map(r => [r.recipient, fmt(r.GBP, 2), fmt(r.EUR, 2)]);
            } else {
              s2Rows = [["", "-", "-"]];
            }

            let s3Headers = ["Deposits from Haricom Bank Accounts (GBP EUR)", "", ""];
            let s3ColHeaders = ["Currency", "Total Amount", "GBP Equivalent"];
            const s3Rows = (summaryRecords.deposits || []).map(r => [
              r.asset, fmt(r.total, 2), fmt(r.gbpVal, 2)
            ]);

            let s4Headers = ["Fees (GBP EUR USDT XRP)", ""];
            let s4ColHeaders = ["Currency", "Total Amount", "GBP Equivalent"];
            const s4Rows = (summaryRecords.fees || []).map(r => [
              r.asset, (r.asset === "USDT" || r.asset === "XRP") ? fmt(r.total, 4) : fmt(r.total, 2), fmt(r.gbpVal, 2)
            ]);

            const rangeReq = "'KrakenStatementSummary'!A:Z";
            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: rangeReq });

            // S1
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenStatementSummary'!A1", valueInputOption: "USER_ENTERED",
              resource: { values: [s1Headers, s1ColHeaders, ...s1Rows] }
            });

            // S2
            let currentRow = 1 + 2 + s1Rows.length + 2;
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: `'KrakenStatementSummary'!A${currentRow}`, valueInputOption: "USER_ENTERED",
              resource: { values: [s2Headers, s2ColHeaders, ...s2Rows] }
            });

            // S3
            currentRow = currentRow + 2 + s2Rows.length + 2;
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: `'KrakenStatementSummary'!A${currentRow}`, valueInputOption: "USER_ENTERED",
              resource: { values: [s3Headers, s3ColHeaders, ...s3Rows] }
            });

            // S4 (Fees)
            currentRow = currentRow + 2 + s3Rows.length + 2;
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: `'KrakenStatementSummary'!A${currentRow}`, valueInputOption: "USER_ENTERED",
              resource: { values: [s4Headers, s4ColHeaders, ...s4Rows] }
            });
            logTrace("KrakenStatementSummary exported.");
          }

          updateStatus("Synced All", "active");
          // alert("Sync complete.\nReports exported to Google Sheets.");

        } catch (e) {
          let errMsg;
          // v2.994: Manual Extraction for Auth/Network Errors
          if (e.result && e.result.error) {
            errMsg = `Code: ${e.result.error.code}, Message: ${e.result.error.message}`;
          } else {
            // Fallback for non-JSON Error objects
            errMsg = e.toString();
            if (errMsg === "[object Object]") {
              // Try to parse keys
              try {
                const keys = Object.keys(e);
                if (keys.length > 0) errMsg = JSON.stringify(e);
                else errMsg = "Network Error (Blocked by Browser/CORS) or Auth Token Invalid";
              } catch (z) { errMsg = "Unknown Network Error"; }
            }
          }

          if (errMsg.includes("404") || errMsg.includes("NOT_FOUND")) {
            logTrace("Sync skipped: Sheet ID not found. Please set correct Sheet ID in API Config.");
            updateStatus("Sync Failed: Check SheetID", "error");
            // alert("Sync Failed: Spreadsheet Not Found (404).\n\nTarget Sheet ID: " + targetSheetId + "\n\nPlease correct it in 'API Config' or ensure you have permission.");
          } else {
            updateStatus("Sync error", "error");
            logTrace("Sync error: " + errMsg);
            // alert("Sync failed. " + errMsg);
          }
        }
      });
    }

    // ---------- Address Viewer ----------
    function toggleAddressViewer() {
      const btn = document.getElementById("address_btn");
      const section = document.getElementById("addressViewerSection");
      const isHidden = section.style.display === "none";
      // Keep button visible, just change label
      if (isHidden) {
        btn.textContent = "Display Addresses (click to close)";
        section.style.display = "block";
        renderAddressTable();
      } else {
        btn.textContent = "Display Addresses";
        section.style.display = "none";
      }
    }

    function renderAddressTable() {
      const tbody = document.getElementById("addressTableBody");
      const addresses = cacheData.krakenAddresses || [];

      if (addresses.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded. Click "Fetch Addresses" first.</td></tr>';
        return;
      }

      // Sort by Asset, then Recipient, then Key Name
      const sorted = [...addresses].sort((a, b) => {
        const assetA = (a.asset || "").toUpperCase();
        const assetB = (b.asset || "").toUpperCase();
        if (assetA !== assetB) return assetA.localeCompare(assetB);

        const recipA = (a.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        const recipB = (b.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        if (recipA !== recipB) return recipA.localeCompare(recipB);

        return (a.key || "").localeCompare(b.key || "");
      });

      let html = "";
      for (const addr of sorted) {
        const asset = escHtml(addr.asset || "");
        const keyName = escHtml(addr.key || "");
        const recipient = escHtml((addr.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim());
        const address = escHtml(addr.address || "");
        const destTag = escHtml(addr.tag || addr.memo || "");
        const info = escHtml(addr.info || addr.bank_details || "");

        html += '<tr style="border-bottom:1px solid #e0e0e0;">';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:45px; font-size:0.6rem;">' + asset + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:150px; max-width:150px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + recipient + '">' + recipient + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:200px; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + keyName + '">' + keyName + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; font-family:monospace; font-size:0.5rem; word-break:break-all;" title="' + address + '">' + address + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:70px; font-size:0.6rem;">' + destTag + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:150px; font-size:0.6rem; word-break:break-word;" title="' + info + '">' + info + '</td>';
        html += '</tr>';
      }

      tbody.innerHTML = html;
    }

    // ---------- Kraken API ----------

    // v3.015: Global helper to load credentials (fix for ReferenceError)
    function loadSavedCredentials() {
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxyType = localStorage.getItem("kraken_cors_proxy_type");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
      const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
      const savedSheetId = localStorage.getItem("kraken_sheet_id");

      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedSheetId) document.getElementById("googleSheetId").value = savedSheetId;
      if (savedProxyType) {
        const sel = document.getElementById("corsProxySelect");
        if (sel) sel.value = savedProxyType;
        if (savedProxyType === "custom" && savedProxy) {
          const inp = document.getElementById("corsProxy");
          if (inp) { inp.value = savedProxy; inp.style.display = "block"; }
        }
      }
      if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
      if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;

      logTrace("Credentials loaded from storage.");
    }



    function toggleApiConfig() {
      const btn = document.getElementById("api_btn");
      const section = document.getElementById("apiConfigSection");
      const isHidden = section.style.display === "none";
      // Keep button visible, just change label
      if (isHidden) {
        btn.innerHTML = "‚öôÔ∏è API Config (click to close)";
        section.style.display = "block";
      } else {
        btn.innerHTML = "‚öôÔ∏è API Config";
        section.style.display = "none";
        return; // Don't reload credentials when closing
      }

      // Load saved credentials when opening (refresh in case changed)
      // v3.041: Disabled auto-reload on open to prevent overwriting unsaved input
      /*
      if (isHidden) {
        loadSavedCredentials();
      }
      */

    }

    function getApiCredentials() {
      let apiKey = document.getElementById("krakenApiKey").value.trim();
      let privateKey = document.getElementById("krakenPrivateKey").value.trim();
      if (!apiKey) apiKey = DEFAULT_API_KEY;
      if (!privateKey) privateKey = DEFAULT_PRIVATE_KEY;
      // Save for next time
      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      const proxy = getSelectedProxy();
      return { apiKey, privateKey, proxy };
    }

    // Withdraw API uses separate credentials (requires 2FA permission)
    function getWithdrawCredentials() {
      let apiKey = document.getElementById("withdrawApiKey").value.trim();
      let privateKey = document.getElementById("withdrawPrivateKey").value.trim();
      if (!apiKey || !privateKey) {
        throw new Error("Please enter Withdraw API credentials in API Config (requires 2FA permission)");
      }
      const proxy = getSelectedProxy();
      return { apiKey, privateKey, proxy };
    }

    // Base64 helpers
    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    // Kraken API signature generation using Web Crypto API
    async function createKrakenSignature(urlPath, postData, privateKeyBase64) {
      if (!privateKeyBase64 || privateKeyBase64.length < 10) {
        throw new Error("Invalid Private Key: Key is empty or too short");
      }

      const encoder = new TextEncoder();

      // Step 1: Get nonce from postData
      const params = new URLSearchParams(postData);
      const nonce = params.get("nonce");

      // Step 2: SHA256 hash of (nonce + postData)
      const sha256Data = encoder.encode(nonce + postData);
      const sha256Hash = await crypto.subtle.digest("SHA-256", sha256Data);

      // Step 3: Concatenate urlPath bytes + sha256Hash bytes
      const pathBytes = encoder.encode(urlPath);
      const combined = new Uint8Array(pathBytes.length + sha256Hash.byteLength);
      combined.set(pathBytes, 0);
      combined.set(new Uint8Array(sha256Hash), pathBytes.length);

      // Step 4: HMAC-SHA512 with decoded private key
      let privateKeyBytes;
      try {
        privateKeyBytes = base64ToArrayBuffer(privateKeyBase64);
      } catch (e) {
        throw new Error("Invalid Private Key: Not a valid Base64 string");
      }

      if (privateKeyBytes.byteLength === 0) {
        throw new Error("Invalid Private Key: Decoded key is empty");
      }

      let hmacKey;
      try {
        hmacKey = await crypto.subtle.importKey(
          "raw",
          privateKeyBytes,
          { name: "HMAC", hash: "SHA-512" },
          false,
          ["sign"]
        );
      } catch (e) {
        throw new Error("Crypto Import Key Error: " + (e.message || e) + " (Check Private Key format)");
      }

      const signature = await crypto.subtle.sign("HMAC", hmacKey, combined);

      // Step 5: Base64 encode the signature
      return arrayBufferToBase64(signature);
    }

    async function callKrakenPrivateAPI(endpoint, params = {}, credentials = null, retryCount = 0) {
      const { apiKey, privateKey, proxy } = credentials || getApiCredentials();
      const urlPath = "/0/private/" + endpoint;
      const nonce = Date.now().toString();

      const postParams = new URLSearchParams({ nonce, ...params });
      const postData = postParams.toString();

      try {
        const signature = await createKrakenSignature(urlPath, postData, privateKey);

        const url = (proxy ? proxy : "") + KRAKEN_API_URL + urlPath;

        logTrace("Calling Kraken API: " + endpoint + " (with OTP: " + (params.otp ? "yes" : "no") + ")");
        logTrace("URL: " + url);

        const response = await fetch(url, {
          method: "POST",
          headers: {
            "API-Key": apiKey,
            "API-Sign": signature,
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: postData
        });

        if (!response.ok) {
          // Try to get more details from the response
          let errorDetails = "";
          try {
            const errorText = await response.text();
            errorDetails = errorText.substring(0, 200);
            logTrace("Error response body: " + errorDetails);
          } catch (e) { }

          // Retry on HTTP 5xx errors (transient proxy issues like 526)
          if (response.status >= 500 && retryCount < 2) {
            logTrace("HTTP " + response.status + " error, retrying in 1 second... (attempt " + (retryCount + 2) + "/3)");
            await new Promise(r => setTimeout(r, 1000));
            return callKrakenPrivateAPI(endpoint, params, credentials, retryCount + 1);
          }

          if (response.status === 403 && proxy && proxy.includes("cors-anywhere")) {
            logTrace("*** CORS-ANYWHERE 403: You may need to visit " + proxy + " and click 'Request temporary access' ***");
            throw new Error("CORS Proxy 403: Visit " + proxy + " to request access first");
          }
          throw new Error("HTTP " + response.status + ": " + response.statusText + (errorDetails ? " - " + errorDetails : ""));
        }

        const data = await response.json();

        if (data.error && data.error.length > 0) {
          throw new Error("Kraken API Error: " + data.error.join(", "));
        }

        return data.result;

      } catch (e) {
        if (e.message.includes("Failed to fetch") || e.message.includes("NetworkError")) {
          // Retry on network errors
          if (retryCount < 2) {
            logTrace("Network error, retrying in 1 second... (attempt " + (retryCount + 2) + "/3)");
            await new Promise(r => setTimeout(r, 1000));
            return callKrakenPrivateAPI(endpoint, params, credentials, retryCount + 1);
          }
          logTrace("CORS blocked. Try using a CORS proxy in API Config.");
          throw new Error("CORS blocked. Please configure a CORS proxy in API Config.");
        }
        throw e;
      }
    }


    async function fetchKrakenAddresses() {
      logTrace("Fetching Kraken withdrawal addresses...");

      try {
        // Get withdrawal-specific credentials
        const withdrawCreds = getWithdrawCredentials();

        // Prompt for 2FA code
        const otp = prompt("Enter your 2FA code for Kraken Withdrawal API:");
        if (!otp || otp.trim() === "") {
          logTrace("2FA cancelled by user");
          updateStatus("Cancelled", "idle");
          return;
        }

        updateStatus("Fetching Kraken...", "sync");

        // Fetch all withdrawal addresses using withdrawal API key with 2FA
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, withdrawCreds);

        logTrace("Kraken WithdrawAddresses response: " + JSON.stringify(addresses).substring(0, 500));

        // addresses is an array of address objects
        cacheData.krakenAddresses = addresses || [];

        // Parse into destTags (XRP) and wallets (USDT/others)
        const newDestTags = [];
        const newWallets = [];

        for (const addr of cacheData.krakenAddresses) {
          // addr structure: { address, asset, key, memo, method, new, tag, verified }
          const keyName = addr.key || "";  // This is the saved address name (e.g., "Aleksey XRP")
          const asset = addr.asset || "";
          const address = addr.address || "";
          const destTag = addr.tag || addr.memo || "";  // XRP uses tag, others might use memo

          // Try to extract recipient name from key (e.g., "Aleksey XRP" -> "Aleksey")
          const recipientName = keyName.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim() || keyName;

          if (asset.toUpperCase().includes("XRP") || asset === "XXRP") {
            newDestTags.push({
              recipient: recipientName,
              destTag: destTag,
              address: address,
              keyName: keyName,
              asset: asset
            });
          } else {
            newWallets.push({
              recipient: recipientName,
              asset: asset,
              address: address,
              keyName: keyName
            });
          }
        }

        // Merge with existing data (don't overwrite if already have data)
        if (newDestTags.length > 0) {
          cacheData.destTags = newDestTags;
          logTrace("Found " + newDestTags.length + " XRP addresses with destination tags.");
        }
        if (newWallets.length > 0) {
          cacheData.wallets = newWallets;
          logTrace("Found " + newWallets.length + " other wallet addresses (USDT, etc.).");
        }

        // v3.043: Also fetch history here (reusing OTP) so Read Ledger doesn't need to ask again
        updateStatus("Fetching history...", "sync");
        await fetchWithdrawalHistory(otp.trim());

        updateStatusCounts();
        updateStatus("Kraken OK", "active");

        const summary = "Fetched " + cacheData.krakenAddresses.length + " addresses.\n" +
          "XRP (with dest tags): " + newDestTags.length + "\n" +
          "Other wallets: " + newWallets.length;
        // alert(summary);
        logTrace(summary.replace(/\n/g, " | "));

      } catch (e) {
        updateStatus("Kraken Error", "error");
        logTrace("Kraken API error: " + (e.message || e));
        // alert("Kraken API Error:\n" + (e.message || e) + "\n\nCheck trace log for details.");
      }
    }

    // Fetch withdrawal history with destination details
    async function fetchWithdrawalHistory(otp) {
      const withdrawCreds = getWithdrawCredentials();

      // Try both USDT and XRP (common assets for withdrawals)
      const assets = ["USDT", "XXRP", "ZUSD", "ZGBP"];
      const allWithdrawals = [];

      for (const asset of assets) {
        try {
          logTrace("Fetching withdrawal history for " + asset + "...");
          const params = otp ? { asset, otp } : { asset };
          const result = await callKrakenPrivateAPI("WithdrawStatus", params, withdrawCreds);

          if (Array.isArray(result)) {
            for (const w of result) {
              allWithdrawals.push({
                ...w,
                queriedAsset: asset
              });
            }
            logTrace("Found " + result.length + " withdrawals for " + asset);
          }
        } catch (e) {
          logTrace("WithdrawStatus for " + asset + ": " + (e.message || "error"));
        }
      }

      cacheData.withdrawalHistory = allWithdrawals;
      logTrace("Total withdrawal history entries: " + allWithdrawals.length);
      return allWithdrawals;
    }

    // Get historical exchange rate from Kraken public API
    // Returns { gbpRate, eurRate } for the given asset at the given timestamp
    // Strategy: Fetch USD pair (more history) and convert via GBP/USD rate
    async function getKrakenRate(asset, timestamp) {
      // Map Kraken asset names to pair names
      const assetMap = {
        "XXRP": "XRP", "XRP": "XRP",
        "USDT": "USDT", "USDTTRC20": "USDT",
        "XXBT": "XBT", "XBT": "XBT",
        "XETH": "ETH", "ETH": "ETH",
        "ZUSD": "USD", "USD": "USD"
      };

      const baseAsset = assetMap[asset] || asset.replace(/^X|^Z/, "");
      const rates = { gbpRate: null, eurRate: null, usdRate: null };
      const proxy = getSelectedProxy();

      // Use 30 days before to ensure we get historical data
      const thirtyDaysBefore = timestamp - (30 * 24 * 60 * 60);

      // Helper to fetch rate from OHLC
      async function fetchOHLC(pair, since) {
        try {
          const url = proxy + "https://api.kraken.com/0/public/OHLC?pair=" + pair + "&interval=1440&since=" + Math.floor(since);
          const response = await fetch(url);
          const data = await response.json();

          if (data.result && Object.keys(data.result).length > 0) {
            const pairData = Object.values(data.result).find(v => Array.isArray(v));
            if (pairData && pairData.length > 0) {
              // Find the candle closest to our timestamp
              let bestCandle = null;
              let bestDiff = Infinity;

              for (const candle of pairData) {
                const diff = Math.abs(candle[0] - timestamp);
                if (diff < bestDiff) {
                  bestDiff = diff;
                  bestCandle = candle;
                }
              }

              // Accept if within 60 days
              if (bestCandle && bestDiff < 60 * 24 * 60 * 60) {
                return parseFloat(bestCandle[4]); // close price
              }
            }
          }
        } catch (e) {
          // Pair might not exist
        }
        return null;
      }

      // USDT is a USD stablecoin, so USDT/USD rate is always ~1.0
      if (baseAsset === "USDT") {
        rates.usdRate = 1.0;
        // Try direct GBP pair for USDT
        rates.gbpRate = await fetchOHLC("USDTGBP", thirtyDaysBefore);

        // If no direct GBP, try USD/GBP conversion
        if (rates.gbpRate === null) {
          // Try USDGBP (gives GBP per USD directly)
          const usdgbpRate = await fetchOHLC("USDGBP", thirtyDaysBefore);
          if (usdgbpRate !== null) {
            rates.gbpRate = usdgbpRate; // 1 USDT = 1 USD = x GBP
          } else {
            // Fallback: Try GBPUSD (gives USD per GBP, so invert)
            const gbpusdRate = await fetchOHLC("GBPUSD", thirtyDaysBefore);
            if (gbpusdRate !== null) {
              rates.gbpRate = 1.0 / gbpusdRate; // 1 USDT = 1 USD, convert to GBP
            }
          }
        }

      } else {
        // For other assets (XRP, etc.), try USD pair first
        rates.usdRate = await fetchOHLC(baseAsset + "USD", thirtyDaysBefore);

        // If we have USD rate, get GBP/USD to convert
        if (rates.usdRate !== null) {
          // Try USDGBP first (gives GBP per USD directly)
          const usdgbpRate = await fetchOHLC("USDGBP", thirtyDaysBefore);
          if (usdgbpRate !== null) {
            rates.gbpRate = rates.usdRate * usdgbpRate;
          } else {
            // Fallback: try GBPUSD (gives USD per GBP, so divide)
            const gbpusdRate = await fetchOHLC("GBPUSD", thirtyDaysBefore);
            if (gbpusdRate !== null) {
              rates.gbpRate = rates.usdRate / gbpusdRate;
            } else {
              // Final fallback: use external forex API for GBP/USD
              try {
                const dateStr = new Date(timestamp * 1000).toISOString().split("T")[0];
                const forexUrl = `https://api.frankfurter.app/${dateStr}?from=USD&to=GBP`;
                const resp = await fetch(forexUrl);
                if (resp.ok) {
                  const data = await resp.json();
                  if (data.rates && data.rates.GBP) {
                    rates.gbpRate = rates.usdRate * data.rates.GBP;
                    rates.rateSource = "Kraken + frankfurter";
                    logTrace(baseAsset + "/GBP via Kraken+frankfurter: " + rates.gbpRate);
                  }
                }
              } catch (e) {
                logTrace("Forex API fallback failed: " + e.message);
              }
            }

          }
        }

        // If still no GBP rate, try direct GBP pair
        if (rates.gbpRate === null) {
          rates.gbpRate = await fetchOHLC(baseAsset + "GBP", thirtyDaysBefore);
        }
      }



      // Try EUR pair for eurRate
      if (baseAsset !== "USDT") {
        rates.eurRate = await fetchOHLC(baseAsset + "EUR", thirtyDaysBefore);
      } else {
        rates.eurRate = await fetchOHLC("USDTEUR", thirtyDaysBefore);
      }

      // If still no GBP rate but we have EUR rate, convert via EUR/GBP
      if (rates.gbpRate === null && rates.eurRate !== null) {
        // Try GBPEUR pair (gives EUR per GBP, so we divide)
        let gbpeurRate = await fetchOHLC("GBPEUR", thirtyDaysBefore);
        if (gbpeurRate !== null) {
          rates.gbpRate = rates.eurRate / gbpeurRate;
        } else {
          // Fallback: try EURGBP (gives GBP per EUR, so we multiply)
          const eurgbpRate = await fetchOHLC("EURGBP", thirtyDaysBefore);
          if (eurgbpRate !== null) {
            rates.gbpRate = rates.eurRate * eurgbpRate;
          }
        }
      }

      // Final fallback: Use external forex API for GBP/USD rate if USDT still has no GBP rate
      if (rates.gbpRate === null && baseAsset === "USDT") {
        try {
          const dateStr = new Date(timestamp * 1000).toISOString().split("T")[0];
          const forexUrl = `https://api.frankfurter.app/${dateStr}?from=USD&to=GBP`;
          const resp = await fetch(forexUrl);
          if (resp.ok) {
            const data = await resp.json();
            if (data.rates && data.rates.GBP) {
              rates.gbpRate = data.rates.GBP;
              rates.rateSource = "frankfurter";
              logTrace("USDT/GBP via frankfurter: " + rates.gbpRate);
            }
          }
        } catch (e) {
          logTrace("Forex API fallback failed: " + e.message);
        }
      }

      // Final fallback for XRP: Use CryptoCompare for historical XRP/USD, then forex for USD/GBP
      if (rates.gbpRate === null && baseAsset === "XRP") {
        try {
          const dateStr = new Date(timestamp * 1000).toISOString().split("T")[0];
          logTrace("XRP fallback: trying CryptoCompare for " + dateStr);

          // Get XRP/USD from CryptoCompare (free API, no auth needed)
          const ccUrl = `https://min-api.cryptocompare.com/data/v2/histoday?fsym=XRP&tsym=USD&limit=1&toTs=${timestamp}`;
          const ccResp = await fetch(ccUrl);
          logTrace("CryptoCompare response status: " + ccResp.status);

          if (ccResp.ok) {
            const ccData = await ccResp.json();
            if (ccData.Response === "Success" && ccData.Data && ccData.Data.Data && ccData.Data.Data.length > 0) {
              // Use the close price from the first data point
              const xrpUsd = ccData.Data.Data[0].close;
              logTrace("CryptoCompare XRP/USD: " + xrpUsd);

              // Now get USD/GBP from forex API
              const forexUrl = `https://api.frankfurter.app/${dateStr}?from=USD&to=GBP`;
              const forexResp = await fetch(forexUrl);
              if (forexResp.ok) {
                const forexData = await forexResp.json();
                if (forexData.rates && forexData.rates.GBP) {
                  rates.gbpRate = xrpUsd * forexData.rates.GBP;
                  rates.rateSource = "CryptoCompare";
                  logTrace("XRP/GBP via CryptoCompare+Forex: " + rates.gbpRate);
                }
              }
            } else {
              logTrace("CryptoCompare returned no data for XRP: " + (ccData.Message || "No data"));
            }
          } else {
            const errText = await ccResp.text();
            logTrace("CryptoCompare error: " + ccResp.status + " - " + errText.substring(0, 100));
          }
        } catch (e) {
          logTrace("CryptoCompare/Forex API fallback for XRP failed: " + e.message);
        }
      }




      return rates;

    }

    window.handleDateChange = function (id) {
      const val = document.getElementById(id).value;
      if (val) {
        const s = document.getElementById("startDate").value;
        const e = document.getElementById("endDate").value;
        if (s && e && s > e) {
          alert("End Date cannot be before Start Date");
          document.getElementById(id).value = "";
          return;
        }
        updateStatus("Date Changed. Click 'Read Ledger' to refresh.", "active");
      }
    };

    // ========== MAIN FUNCTION: Fetch & Generate Report (v2.0) ==========
    async function readLedger() {
      // Step 0: Validate date range
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;

      if (!startDate || !endDate) {
        alert("Please select Start Date and End Date first.");
        return;
      }

      const startTime = new Date(startDate).getTime() / 1000;
      const endTime = new Date(endDate + "T23:59:59").getTime() / 1000;

      logTrace("Date range: " + startDate + " to " + endDate);
      logTrace("Unix range: " + startTime + " to " + endTime);

      // Check if data exists and ask for confirmation
      if (cacheData.withdrawals.length > 0 || stagingRecords.length > 0) {
        if (!confirm("Start new Ledger Read? This will clear all current reports and data.")) {
          return;
        }
      }

      // Clear Ledger Data and Reports (Keep addresses/history intact if already fetched)
      const oldRates = cacheData.ratesCache || {};
      const oldAddresses = cacheData.krakenAddresses || [];
      const oldHistory = cacheData.withdrawalHistory || [];

      cacheData = {
        withdrawals: [],
        krakenAddresses: oldAddresses,
        withdrawalHistory: oldHistory,
        ratesCache: oldRates
      };

      stagingRecords = [];
      bankRecords = [];
      summaryRecords = null;

      document.getElementById("statusSummary").innerHTML = "";
      document.getElementById("previewArea").innerHTML = "";
      document.getElementById("bankReportArea").innerHTML = "";
      document.getElementById("summaryReportArea").innerHTML = "";
      updateGlobalRecordCounts();

      // Step 1: Prompt for 2FA (Only if we need to fetch addresses/history or if user Has 2FA on Query)
      // v3.042: Optimisation - Check if we already have addresses/history.
      // If we have them, we might SKIP the 2FA prompt if the Ledgers API (Query) doesn't enforce it.
      // However, usually users set 2FA for everything.
      // SAFE BET: Only prompt if we are actually going to call a 2FA-gated endpoint OR if we suspect Query needs it.
      // Let's assume Ledgers API (Query) does NOT require 2FA by default, but WithdrawStatus DOES.

      const needAddresses = (!cacheData.krakenAddresses || cacheData.krakenAddresses.length === 0);
      const needHistory = (!cacheData.withdrawalHistory || cacheData.withdrawalHistory.length === 0);

      let otp = "";

      // If we need data that requires 2FA, prompt now.
      if (needAddresses || needHistory) {
        otp = prompt("Enter your Kraken 2FA code (needed for Addresses/History):");
        if (!otp || otp.trim() === "") {
          logTrace("2FA cancelled (skipping address/history fetch)");
          // We can proceed to try fetching Ledgers without 2FA, 
          // but if the user CANCELLED, maybe they want to abort?
          // Let's assume they want to try reading ledger anyway if they have addresses cached.
          if (needAddresses) return; // Can't generate decent report without addresses
        }
      }

      try {
        const creds = getApiCredentials();
        updateStatus("Fetching...", "sync");

        // Step 2: Call Kraken Ledgers API 
        // Note: Query API often doesn't need 2FA. We pass OTP only if we have it.
        logTrace("Calling Kraken Ledgers API...");

        const params = {
          type: "withdrawal",
          start: Math.floor(startTime),
          end: Math.floor(endTime)
        };
        if (otp) params.otp = otp.trim();

        const ledgerResult = await callKrakenPrivateAPI("Ledgers", params, creds);

        // ledgerResult is { ledger_id: { refid, time, type, subtype, aclass, asset, amount, fee, balance } }
        const allWithdrawals = [];
        for (const [ledgerId, entry] of Object.entries(ledgerResult.ledger || ledgerResult || {})) {
          const asset = (entry.asset || "").toUpperCase();
          // Filter to USDT and XRP only
          if (asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP") {
            allWithdrawals.push({
              ledgerId,
              refid: entry.refid,
              time: entry.time,
              asset: asset,
              amount: parseFloat(entry.amount || 0),
              fee: parseFloat(entry.fee || 0),
              balance: parseFloat(entry.balance || 0)
            });
          }
        }

        cacheData.withdrawals = allWithdrawals;
        logTrace("Fetched " + allWithdrawals.length + " USDT/XRP withdrawals from Ledgers API");

        // Step 3 & 4: Call WithdrawStatus / WithdrawAddresses ONLY if we have OTP
        if (otp) {
          logTrace("Fetching withdrawal details...");
          await fetchWithdrawalHistory(otp.trim());

          logTrace("Fetching saved addresses...");
          const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, creds);
          cacheData.krakenAddresses = addresses || [];
          logTrace("Fetched " + cacheData.krakenAddresses.length + " saved addresses");
        } else {
          logTrace("Skipping address/history fetch (no 2FA provided). Using cached data if available.");
          logTrace("Cached Addresses: " + cacheData.krakenAddresses.length);
        }

        updateStatusCounts();

        // Step 5: Generate report from fetched data
        await generateReportFromCache();

        updateStatus("Ready", "active");

      } catch (e) {
        updateStatus("Error", "error");
        logTrace("Error: " + (e.message || e));
        alert("Error: " + (e.message || e));
      }
    }

    // Generate report from cached data (no API calls except for rates)
    async function generateReportFromCache() {
      if (cacheData.withdrawals.length === 0) {
        alert("No withdrawal data. Please Fetch first.");
        return;
      }

      updateStatus("Generating...", "sync");
      logTrace("Generating report from " + cacheData.withdrawals.length + " entries...");

      stagingRecords = [];
      document.getElementById("previewArea").innerHTML = ""; // v3.017: Clear previous report
      document.getElementById("bankReportArea").innerHTML = "";

      // Sort ALL ledger entries by time (ascending) for trade matching
      const sortedLedger = [...cacheData.withdrawals].sort((a, b) => a.time - b.time);

      // Helper: Find immediately preceding trade that matches a withdrawal
      function findMatchingTrade(withdrawalIndex, withdrawal) {
        // Look for a trade immediately before this withdrawal (same asset, amount matches withdrawal + fee)
        const targetAmount = Math.abs(withdrawal.amount) + Math.abs(withdrawal.fee);

        for (let i = withdrawalIndex - 1; i >= 0 && i >= withdrawalIndex - 5; i--) {
          const prev = sortedLedger[i];
          if (prev.type !== "trade") continue;

          // Check if same asset and amount matches
          const prevAsset = (prev.asset || "").toUpperCase();
          const withdrawalAsset = (withdrawal.asset || "").toUpperCase();
          if (!prevAsset.includes("XRP") && !prevAsset.includes("USDT")) continue;
          if (!withdrawalAsset.includes(prevAsset.replace("X", "")) &&
            !prevAsset.includes(withdrawalAsset.replace("X", ""))) continue;

          // Check if trade amount ‚âà withdrawal amount + fee (within 0.01% tolerance)
          const tradeAmount = Math.abs(prev.amount);
          const tolerance = targetAmount * 0.0001;
          if (Math.abs(tradeAmount - targetAmount) <= tolerance) {
            // Found matching crypto trade! Now find the GBP/EUR counterpart
            return { cryptoTrade: prev, index: i };
          }
        }
        return null;
      }

      // Helper: Find GBP/EUR trade counterpart (should be very close in time to the crypto trade)
      function findFiatCounterpart(tradeIndex, cryptoTrade) {
        // Look within a few entries around the crypto trade for a GBP or EUR trade
        for (let i = Math.max(0, tradeIndex - 3); i <= Math.min(sortedLedger.length - 1, tradeIndex + 3); i++) {
          if (i === tradeIndex) continue;
          const entry = sortedLedger[i];
          if (entry.type !== "trade") continue;

          const asset = (entry.asset || "").toUpperCase();
          // Look for GBP or EUR (Kraken uses ZGBP, ZEUR, or just GBP, EUR)
          if (asset.includes("GBP") || asset.includes("EUR") || asset === "ZGBP" || asset === "ZEUR") {
            // Found fiat trade! Should be very close in time (within a few seconds)
            const timeDiff = Math.abs(entry.time - cryptoTrade.time);
            if (timeDiff <= 60) { // Within 60 seconds
              return entry;
            }
          }
        }
        return null;
      }

      // Step 1: Collect unique dates for batch rate lookup
      const uniqueDates = new Set();
      for (const w of cacheData.withdrawals) {
        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        uniqueDates.add(dateStr);
      }
      logTrace("Unique dates: " + Array.from(uniqueDates).join(", "));

      // Step 2: Batch fetch rates for each unique date
      const ratesToFetch = [];
      const cachedDates = [];
      for (const dateStr of uniqueDates) {
        const timestamp = new Date(dateStr).getTime() / 1000 + 43200; // noon
        const cached = cacheData.ratesCache[dateStr];
        if (!cached) {
          ratesToFetch.push({ dateStr, timestamp });
        } else if (cached.USDTGBP === null || cached.XRPGBP === null) {
          // Retry dates where GBP rate is null (API might return data on retry)
          ratesToFetch.push({ dateStr, timestamp });
          logTrace("Retrying rate for " + dateStr + " (had null GBP)");
        } else {
          cachedDates.push(dateStr);
        }
      }
      if (cachedDates.length > 0) {
        logTrace("Using cached rates for " + cachedDates.length + " dates: " + cachedDates.join(", "));
      }

      if (ratesToFetch.length > 0) {
        logTrace("Fetching rates for " + ratesToFetch.length + " dates...");
        let fetchCount = 0;
        updateStatus("Fetching rates... " + fetchCount + "/" + ratesToFetch.length, "sync");
        for (const { dateStr, timestamp } of ratesToFetch) {
          fetchCount++;
          updateStatus("Fetching rates... " + fetchCount + "/" + ratesToFetch.length, "sync");

          // Fetch all 4 pairs for this date
          const usdtRates = await getKrakenRate("USDT", timestamp);
          const xrpRates = await getKrakenRate("XRP", timestamp);

          cacheData.ratesCache[dateStr] = {
            USDTGBP: usdtRates.gbpRate,
            USDTEUR: usdtRates.eurRate,
            USDTSource: usdtRates.rateSource || "Kraken day rate",
            XRPGBP: xrpRates.gbpRate,
            XRPEUR: xrpRates.eurRate,
            XRPSource: xrpRates.rateSource || "Kraken day rate"
          };



          logTrace("Rates for " + dateStr + ": USDTGBP=" + usdtRates.gbpRate + ", XRPGBP=" + xrpRates.gbpRate);

          // Small delay to avoid API rate limiting
          await new Promise(r => setTimeout(r, 200));
        }
      }


      // Step 3: Build records (only for withdrawals, but use sortedLedger for trade matching)
      // Iterate REVERSE (end to start) so report is Newest -> Oldest
      for (let idx = sortedLedger.length - 1; idx >= 0; idx--) {
        const w = sortedLedger[idx];

        // Only process withdrawals, deposits, and trades
        // v3.030: Include deposits as requested
        if (w.type !== "withdrawal" && w.type !== "trade" && w.type !== "deposit") continue;

        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        const rates = cacheData.ratesCache[dateStr] || {};

        // Find matching withdrawal in history (for address/tag)
        const historyMatch = cacheData.withdrawalHistory.find(h => h.refid === w.refid);

        // Get address from history
        let walletAddr = historyMatch ? (historyMatch.info || historyMatch.address || "") : "";
        let destTag = historyMatch ? (historyMatch.dest || historyMatch.tag || "") : "";

        // Find recipient from krakenAddresses
        let fullRecipient = "";

        // Helper to normalize string for matching (remove spaces, symbols, lowercase)
        const normalize = (s) => (s || "").toLowerCase().replace(/[^a-z0-9]/g, "");

        const walletAddrNorm = normalize(walletAddr);

        const addrMatch = cacheData.krakenAddresses.find(a => {
          // Strict match on address field
          if (a.address === walletAddr) {
            return (destTag ? (a.tag === destTag) : (!a.tag));
          }
          // v2.48: Fuzzy/Normalized match for Fiat IBANs
          // Check if normalised address in book matches normalised wallet address
          // OR if the 'info' field (sometimes matches)
          if (walletAddrNorm.length > 5 && (normalize(a.address) === walletAddrNorm || normalize(a.info) === walletAddrNorm)) {
            return true;
          }
          return false;
        });

        if (addrMatch) {
          // Use the Key Name from address book
          fullRecipient = (addrMatch.key || "").trim();
        } else {
          // Fallback 1: Loose match on address only (for crypto non-tag assets)
          // Fallback 1: Loose match on address only (for crypto non-tag assets)
          const looseMatch = cacheData.krakenAddresses.find(a => a.address === walletAddr);
          if (looseMatch) {
            // If we found a match by address, use it.
            // (We relax strict tag matching here because sometimes tags appear in "info" or are optional)
            fullRecipient = (looseMatch.key || "").trim();
          } else {
            // Fallback 2: Use the 'info' field from withdrawal history directly if no book match
            if (historyMatch && historyMatch.info) {
              fullRecipient = historyMatch.info;
            }
          }
        }

        // v2.48 Fallback 2: If still empty and it's a Fiat withdrawal, use the bank name from history
        if (!fullRecipient && (w.type === "withdrawal")) {
          const isFiat = w.asset.includes("GBP") || w.asset.includes("EUR") || w.asset.includes("USD") || w.asset.includes("ZGBP") || w.asset.includes("ZEUR") || w.asset.includes("ZUSD");
          if (isFiat && walletAddr) {
            fullRecipient = walletAddr; // e.g. "Revolut Ltd"
          }
        }

        // Split recipient: first 2 words = name, rest = sent to destination
        // v2.48: Ensure we handle cases with < 2 words gracefully
        const words = (fullRecipient || "").split(/\s+/);
        let recipientName = "";
        let sentTo = "";

        if (words.length > 0 && words[0] !== "") {
          if (words.length === 1) {
            recipientName = words[0];
          } else {
            recipientName = words[0] + " " + words[1];
            sentTo = words.slice(2).join(" ").trim();
          }
        }


        // Calculate GBP equivalent - TRY TRADE MATCHING FIRST
        let gbpSent = "";
        let gbpFee = "";
        let conversionRate = "";
        let conversionCurrency = "";
        let rateSource = "";
        const absAmount = Math.abs(w.amount);
        const absFee = Math.abs(w.fee);
        const netAmount = absAmount - absFee;  // Amount after fee deduction

        // STEP A: Try to match this withdrawal to its immediately preceding trade
        const tradeMatch = findMatchingTrade(idx, w);
        if (tradeMatch) {
          const fiatTrade = findFiatCounterpart(tradeMatch.index, tradeMatch.cryptoTrade);
          if (fiatTrade) {
            // Calculate rate from matched trade pair
            const cryptoAmount = Math.abs(tradeMatch.cryptoTrade.amount);
            const fiatAmount = Math.abs(fiatTrade.amount);
            const matchedRate = fiatAmount / cryptoAmount;
            const fiatAsset = (fiatTrade.asset || "").toUpperCase();

            conversionCurrency = fiatAsset.includes("GBP") || fiatAsset === "ZGBP" ? "GBP" :
              fiatAsset.includes("EUR") || fiatAsset === "ZEUR" ? "EUR" : fiatAsset;
            conversionRate = matchedRate.toFixed(6);
            gbpSent = (netAmount * matchedRate).toFixed(2);
            gbpFee = (absFee * matchedRate).toFixed(2);
            // v3.014: "Trade" -> "Exact rate" via User Request
            rateSource = "Exact rate";

            logTrace("Trade match for " + w.refid + ": " + cryptoAmount.toFixed(2) + " " + w.asset +
              " = " + fiatAmount.toFixed(2) + " " + conversionCurrency +
              " (rate: " + conversionRate + ")");
          }
        }

        // STEP B: Fall back to external rates if no trade match
        if (!rateSource) {
          if (w.asset.includes("USDT")) {
            if (rates.USDTGBP) {
              gbpSent = (netAmount * rates.USDTGBP).toFixed(2);
              gbpFee = (absFee * rates.USDTGBP).toFixed(2);
              conversionRate = rates.USDTGBP.toFixed(6);
              conversionCurrency = "GBP";
            } else if (rates.USDTEUR) {
              gbpSent = (netAmount * rates.USDTEUR).toFixed(2);
              gbpFee = (absFee * rates.USDTEUR).toFixed(2);
              conversionRate = rates.USDTEUR.toFixed(6);
              conversionCurrency = "EUR";
            }
            // v3.014: "Kraken" -> "Kraken day rate" via User Request
            rateSource = rates.USDTSource || "Kraken day rate";
          } else if (w.asset.includes("XRP") || w.asset === "XXRP") {
            if (rates.XRPGBP) {
              gbpSent = (netAmount * rates.XRPGBP).toFixed(2);
              gbpFee = (absFee * rates.XRPGBP).toFixed(2);
              conversionRate = rates.XRPGBP.toFixed(6);
              conversionCurrency = "GBP";
            } else if (rates.XRPEUR) {
              gbpSent = (netAmount * rates.XRPEUR).toFixed(2);
              gbpFee = (absFee * rates.XRPEUR).toFixed(2);
              conversionRate = rates.XRPEUR.toFixed(6);
              conversionCurrency = "EUR";
            }
            rateSource = rates.XRPSource || "Kraken day rate";
          }
        }

        // Normalize asset name (XXRP -> XRP, USDT stays USDT)
        const normalizedAsset = w.asset.includes("XRP") || w.asset === "XXRP" ? "XRP" :
          w.asset.includes("USDT") ? "USDT" : w.asset;


        const record = {
          dateSent: formatTimestamp(w.time),
          timeSent: formatTime(w.time),
          refid: w.refid, // v2.90: needed for linking
          type: w.type || "withdrawal",  // Type from ledger entry
          entryDate: "",
          recipient: recipientName,
          sentTo: sentTo,
          asset: normalizedAsset,
          amount: Math.abs(w.amount).toFixed(6),
          fee: Math.abs(w.fee).toFixed(6),
          balance: w.balance.toFixed(6),
          conversionCurrency: conversionCurrency,
          conversionRate: conversionRate,
          gbpSent: gbpSent,
          gbpFee: gbpFee,
          destTag: destTag,
          wallet: walletAddr,
          txId: w.refid,
          rateSource: rateSource,
          gbpSent: gbpSent || "0.00" // Ensure it exists
        };





        stagingRecords.push(record);

        // v2.97: Fix - Ensure withdrawalCache is populated with THESE calculated records
        // before we try to use them for Summary generation!
        // We accumulate them here.
      }
      // Populate global cache for Summary reuse
      cacheData.withdrawalCache = [...stagingRecords];

      localStorage.setItem("kraken_staging", JSON.stringify(stagingRecords));
      renderPreview();
      updateStatus("Ready", "active");
      logTrace("Report generated: " + stagingRecords.length + " records");
    }

    // Format unix timestamp to DD Mon YYYY
    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const d = String(dt.getUTCDate()).padStart(2, "0");
      const m = months[dt.getUTCMonth()];
      const y = dt.getUTCFullYear();
      return d + " " + m + " " + y;
    }


    // Format unix timestamp to HH:MM:SS (UTC)
    function formatTime(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const h = String(dt.getUTCHours()).padStart(2, "0");
      const m = String(dt.getUTCMinutes()).padStart(2, "0");
      const s = String(dt.getUTCSeconds()).padStart(2, "0");
      return h + ":" + m + ":" + s;
    }

    // ===========================================
    // KRAKEN BANK STATEMENT REPORT (New v2.49)
    // ===========================================
    let bankRecords = [];
    const TRACKED_ASSETS = ["GBP", "EUR", "USDT", "XRP"];

    async function generateBankReport() {
      const btn = document.getElementById("btn_bank_statement");
      const sDateVal = document.getElementById("startDate").value;
      const eDateVal = document.getElementById("endDate").value;

      if (!sDateVal || !eDateVal) { alert("Please select a date range."); return; }

      // Parse dates (start of day / end of day)
      const startTs = new Date(sDateVal).getTime() / 1000;
      const endTs = new Date(eDateVal).getTime() / 1000 + 86399;

      if (cacheData.withdrawals.length === 0) {
        alert("No ledger data loaded. Please 'Read Ledger' first.");
        return;
      }

      btn.innerText = "Generating...";

      // 1. Filter and Sort Data
      // Use allLedgerEntries (cached in withdrawals)
      const entries = cacheData.withdrawals
        .filter(e => e.time >= startTs && e.time <= endTs)
        .sort((a, b) => a.time - b.time); // Oldest first

      if (entries.length === 0) {
        alert("No transactions found in this date range.");
        btn.innerText = `Kraken Statement ${formatTimestamp(startTs)} to ${formatTimestamp(endTs)}`;
        return;
      }

      // 2. Calculate Opening Balances (Back-Calculation)
      // We need a starting balance for each tracked asset.
      // Strategy: Find the FIRST occurrence of each asset in the filtered list.
      // Opening = FirstEntry.balance - FirstEntry.amount (reverse the transaction)
      let runningBal = {};

      // Initialize with null to detect missing history
      TRACKED_ASSETS.forEach(a => runningBal[a] = null);

      // Scan for first occurrences to set opening balances
      for (const asset of TRACKED_ASSETS) {
        // Find first entry involving this asset
        const first = entries.find(e => {
          const a = (e.asset || "").toUpperCase();
          return a.includes(asset) || (asset === "XRP" && a === "XXRP") || (asset === "GBP" && a === "ZGBP") || (asset === "EUR" && a === "ZEUR");
        });

        if (first) {
          // Found a transaction. Opening balance is Balance BEFORE this transaction.
          // Note: amount is positive for deposits, negative for withdrawals/trades-out.
          // Balance = Prev + Amount  =>  Prev = Balance - Amount
          runningBal[asset] = first.balance - first.amount;
        } else {
          runningBal[asset] = 0; // Asset not seen in period, assume 0
        }
      }

      const openingBalRow = {
        date: formatTimestamp(startTs),
        time: "00:00:00",
        type: "Balance",
        details: "Opening Balance",
        balances: { ...runningBal }, // Snapshot
        amounts: {},
        fees: {}
      };

      // 3. Process Transactions (Merge Trades & Update Balances)
      bankRecords = [];
      bankRecords.push(openingBalRow);

      let i = 0;
      while (i < entries.length) {
        const e = entries[i];
        const next = (i + 1 < entries.length) ? entries[i + 1] : null;

        // Check for Mergeable Trade
        // Same refid, same time, both are trades
        let isTradeMerge = false;

        if (e.type === 'trade' && next && next.type === 'trade' && e.refid === next.refid) {
          isTradeMerge = true;
        }

        const row = {
          date: formatTimestamp(e.time),
          time: formatTime(e.time),
          type: isTradeMerge ? "trade" : (e.type || "transaction"),
          details: "",
          balances: {},
          amounts: {},
          fees: {},
          // V2.84: Store metadata for Summary generation
          refid: e.refid,
          _raw: e
        };

        // Helper to process one entry into the row
        const processEntry = (entry) => {
          let asset = (entry.asset || "").toUpperCase();
          // Normalize
          if (asset.includes("XRP") || asset === "XXRP") asset = "XRP";
          else if (asset.includes("USDT")) asset = "USDT";
          else if (asset.includes("GBP") || asset === "ZGBP") asset = "GBP";
          else if (asset.includes("EUR") || asset === "ZEUR") asset = "EUR";
          else return; // Ignore non-tracked assets if any

          // Update Running Balance from Authoritative Ledger Data
          runningBal[asset] = entry.balance;

          // Fill Row Data
          row.amounts[asset] = entry.amount;
          row.fees[asset] = Math.abs(entry.fee);
        };

        if (isTradeMerge) {
          // Process Both
          processEntry(e);
          processEntry(next);

          // Determine Description e.g. "Buy USDT / Sell GBP"
          const bought = (e.amount > 0 ? e : next);
          const sold = (e.amount < 0 ? e : next);

          // Fix v2.77: Safer asset normalization (don't blindly strip X)
          const norm = (a) => {
            a = (a || "").toUpperCase();
            if (a.includes("XRP") || a === "XXRP") return "XRP";
            if (a.includes("USDT")) return "USDT";
            if (a.includes("GBP") || a === "ZGBP") return "GBP";
            if (a.includes("EUR") || a === "ZEUR") return "EUR";
            if (a.includes("USD") || a === "ZUSD") return "USD";
            return a;
          };

          let bAsset = norm(bought.asset);
          let sAsset = norm(sold.asset);

          row.details = `Buy ${bAsset} / Sell ${sAsset}`;
          i += 2; // Skip next
        } else {
          // Single Entry (Deposit, Withdrawal, or Unmatched Trade)
          processEntry(e);

          let detail = ""; // Initialize default

          if (e.type === 'withdrawal' || e.type === 'deposit') {
            // Try to get recipient name from address book logic
            const normalizedAsset = (e.asset.includes("XRP") || e.asset === "XXRP") ? "XRP" : (e.asset.includes("USDT") ? "USDT" : e.asset);

            // v2.95: Try to find calculated GBP value from Withdrawal Cache (Re-applying v2.90 fix + Fallback)
            let foundGbp = 0;
            if (cacheData.withdrawalCache) {
              // Try exact RefID match
              let match = cacheData.withdrawalCache.find(w => w.refid === e.refid);
              // Fallback Match
              if (!match) {
                match = cacheData.withdrawalCache.find(w =>
                  Math.abs(w.time - e.time) < 5 &&
                  Math.abs(w.amount - e.amount) < 0.0001 &&
                  w.asset === normalizedAsset
                );
              }
              if (match && match.gbpSent) foundGbp = parseFloat(match.gbpSent);
            }

            // Fallback: Calculate from Rates if still missing
            if (!foundGbp && Math.abs(e.amount) > 0) {
              const dObj = new Date(e.time * 1000);
              const dStr = dObj.toISOString().split('T')[0];
              const dayRates = cacheData.ratesCache[dStr];
              if (dayRates) {
                let rate = 0;
                if (normalizedAsset === "USDT") rate = dayRates.USDTGBP || 0;
                else if (normalizedAsset === "XRP") rate = dayRates.XRPGBP || 0;
                if (rate > 0) foundGbp = (Math.abs(e.amount) * rate).toFixed(2);
              }
            }

            // Store queryable GBP in row
            if (!row.gbpValues) row.gbpValues = {};
            if (foundGbp) row.gbpValues[normalizedAsset] = parseFloat(foundGbp);

            // Default Detail
            detail = (e.type === 'withdrawal') ? `Withdrawal` : `Deposit`;

            // Enriched Logic: First 2 words of recipient
            let recipient = null;

            // 1. History Lookup
            const historyMatch = cacheData.withdrawalHistory.find(h => h.refid === e.refid);
            if (historyMatch) {
              const addr = historyMatch.info || historyMatch.address;
              const addrMatch = cacheData.krakenAddresses.find(a => a.address === addr);
              if (addrMatch) recipient = addrMatch.key;
              else if (addr) recipient = addr;
            }

            if (recipient) {
              // Take first 2 words
              const words = recipient.split(/\s+/).slice(0, 2).join(" ");
              // Clean common suffixes if needed, or just trust words
              detail = `${words}`;

              // v3.028: Fix "Withdrawal (EUR)" showing instead of name
              // Use the detected name as the primary detail
              row.details = detail;

            } else if (e.info && e.info !== "Withdrawal" && e.info !== "Deposit") {
              // v3.017: Fallback to ledger info if no address match (e.g. "Revolut Ltd")
              detail = e.info;
            }

            // Fix: Override for Revolut GBP
            // v3.030: User requested NO hardcoding of bank names.
            // Keeping dynamic logic only.
            // if (detail === "Revolut Ltd") { detail = "Revolut Business"; }

            // Append Asset (cleaned)
            let cleanAsset = normalizedAsset.replace("ZEUR", "EUR").replace("ZGBP", "GBP").replace("ZUSD", "USD");

            // v3.028: Make sure we don't double append
            if (!detail.includes("(" + cleanAsset + ")")) {
              detail += ` (${cleanAsset})`;
            }

            row.details = detail;

          } else {
            // Use e.type or fallback. If type is missing, use "Transfer"
            const typeLabel = e.type || "Transfer";
            row.details = `${typeLabel} (${e.asset})`;

            // Fix: Ensure Balance rows have correct labels if somehow falling here
            if (e.type === 'balance') row.details = "Balance Adjustment";
          }
          i += 1;
        }

        // Copy current state of running balances to row
        row.balances = { ...runningBal };
        bankRecords.push(row);
      }

      // 4. Closing Balance Row
      const closingBalRow = {
        date: formatTimestamp(endTs),
        time: "23:59:59",
        type: "Balance",
        details: "Closing Balance",
        balances: { ...runningBal },
        amounts: {},
        fees: {}
      };
      bankRecords.push(closingBalRow);

      // 5. Render
      // Save to Persistence
      localStorage.setItem("kraken_bank_staging", JSON.stringify(bankRecords));

      renderBankTable();

      // Update button state (Toggle behavior)
      const div = document.getElementById("bankReportArea");
      div.style.display = "block"; // Auto-show after generate

      // V2.84: Generate Summary immediately from these records to ensure consistency
      // v3.025: Decoupled to avoid "Frankenstein" behavior (Summary opening with Statement)
      // generateStatementSummary(bankRecords);
    }

    // Toggle function (Same approach as toggleReportViewer)
    async function toggleBankReport() {
      const div = document.getElementById("bankReportArea");
      const isHidden = (div.style.display === "none");

      if (isHidden) {
        // Generate & Show
        const btn = document.getElementById("btn_bank_statement");
        const originalText = btn.textContent;
        btn.textContent = "Generating...";
        btn.disabled = true;

        // Yield to allow UI update
        await new Promise(r => setTimeout(r, 50));

        try {
          // This function exists globally and populates cacheData.bankRecords then calls renderBankTable()
          await generateBankReport();
        } catch (e) {
          alert("Error generating statement: " + e.message);
        } finally {
          btn.textContent = originalText;
          btn.disabled = false;
        }
      } else {
        // Hide
        div.style.display = "none";
      }
    }

    // v2.99: Table Filter Logic
    function filterBankReport() {
      const typeInput = document.getElementById("typeFilterInput");
      const descInput = document.getElementById("descFilterInput");

      const typeFilter = typeInput ? typeInput.value.toUpperCase() : "";
      const descFilter = descInput ? descInput.value.toUpperCase() : "";

      const table = document.getElementById("bankStmtTable");
      if (!table) return;

      const trs = table.getElementsByTagName("tr");
      // Start from 1 to skip header? Actually header has ID row maybe? 
      // The header row containing inputs is row 0. Data starts at row 1.
      // Wait, the new header structure puts inputs in the header. 
      // Let's assume data rows are in <tbody>.
      const tbody = table.getElementsByTagName("tbody")[0];
      if (!tbody) return;

      const rows = tbody.getElementsByTagName("tr");

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        // Columns: 0=Date, 1=Time, 2=Type, 3=Balance(old?), 4=Desc... 
        // Need to match Render Logic.
        // Render Logic (Line 2850+):
        // td0: Date
        // td1: Time
        // td2: Type
        // td3: Balance (Debit/Credit logic?) - Wait, let's check render order.

        // Let's grab text content by index, safer.
        // Columns: 0=Date, 1=Time, 2=Type(dep/wd/trade), 3=Desc(Details), 4=GBP(Debit), 5=GBP(Credit)...
        // Correct Render Mapping (renderBankTable):
        // td0: Date
        // td1: Time
        // td2: Type (class 'type-col')
        // td3: Description (class 'desc-col') <-- This is index 3!

        const cells = row.getElementsByTagName("td");
        if (cells.length < 4) continue;

        const typeTxt = cells[2].textContent || "";
        // v2.93 Fix: Description is at index 3, not 5
        const descTxt = cells[3].textContent || "";

        const typeMatch = typeTxt.toUpperCase().indexOf(typeFilter) > -1;
        const descMatch = descTxt.toUpperCase().indexOf(descFilter) > -1;

        if (typeMatch && descMatch) {
          row.style.display = "";
        } else {
          row.style.display = "none";
        }
      }
    }

    // ===========================================
    // STATEMENT SUMMARY REPORT (v2.50)
    // ===========================================
    let summaryRecords = { crypto: [], fiat: [], deposits: [], fees: [] };
    let depositTotals = { GBP: 0, EUR: 0 }; // v3.015: Global for access in render helpers


    function toggleSummaryReport() {
      const div = document.getElementById("summaryReportArea");
      const isHidden = (div.style.display === "none");
      if (isHidden) {
        // v3.027: Prefer bankRecords if available so Summary matches the Report
        if (typeof bankRecords !== "undefined" && bankRecords.length > 0) {
          generateStatementSummary(bankRecords);
        } else {
          generateStatementSummary();
        }
      } else {
        div.style.display = "none";
      }
    }

    // V2.84: Accepts 'customRecords' (e.g. bankRecords) to ensure Summary matches Statement Table

    async function generateStatementSummary(customRecords) {
      const sDateVal = document.getElementById("startDate").value;
      const eDateVal = document.getElementById("endDate").value;

      // If we are using custom records (bankRecords), we don't strictly need date range checks 
      // as they are already filtered, but we keep them for the header labels.
      if (!sDateVal || !eDateVal) {
        if (!customRecords) { alert("Please select a date range."); return; }
      }

      const startTs = new Date(sDateVal).getTime() / 1000;
      const endTs = new Date(eDateVal).getTime() / 1000 + 86399;

      // Aggregation Containers
      const cryptoTotals = {}; // { recipient: { USDT: 0, XRP: 0, USDT_GBP: 0, XRP_GBP: 0 } }
      const fMap = {};         // { recipient: { GBP: 0, EUR: 0 } }
      depositTotals = { GBP: 0, EUR: 0 }; // v3.015: Reset global variable
      const feeTotals = { GBP: 0, EUR: 0, USDT: 0, XRP: 0 };
      const fiatWithdrawals = []; // legacy support

      // Helper to normalize
      const getAssetKey = (a) => {
        a = (a || "").toUpperCase();
        if (a.includes("XRP") || a === "XXRP") return "XRP";
        if (a.includes("USDT")) return "USDT";
        if (a.includes("GBP") || a === "ZGBP") return "GBP";
        if (a.includes("EUR") || a === "ZEUR") return "EUR";
        return null;
      };

      // Helper for GBP Calculation
      function calculateGbpValue(e, amount, assetKey) {
        // 1. Try finding a Trade (Exact Ledger Match)
        if (cacheData && cacheData.withdrawals) {
          const trade = cacheData.withdrawals.find(t =>
            t.refid === e.refid &&
            t.type === 'trade' &&
            (t.asset === 'ZGBP' || t.asset.includes('GBP'))
          );
          if (trade) {
            return Math.abs(trade.amount);
          }
        }

        // 2. Try finding in Withdrawal Cache (Calculated Rates)
        // v2.993: This is critical for unmatched withdrawals ensuring they use the rate derived during "Read Ledger"
        if (cacheData && cacheData.withdrawalCache) {
          const cached = cacheData.withdrawalCache.find(w => w.refid === e.refid);
          if (cached && cached.gbpSent) {
            return parseFloat(cached.gbpSent);
          }
        }
        return 0; // Default to 0 if no match found
      }

      // Determine Source Data
      // If customRecords (bankRecords) is provided, use it. Otherwise fallback (legacy).
      // We map bankRecords back to a structure similar to 'e' for the loop, 
      // OR we write a specific loop for bankRecords.
      // A specific loop is safer to ensure we use the TABLE values.

      let sourceData = [];
      let isFromTable = false;
      // Removed duplicate declarations

      if (customRecords && customRecords.length > 0) {
        sourceData = customRecords;
        isFromTable = true;
        logTrace(`Generating Summary from ${sourceData.length} Statement Rows (Source of Truth)`);
      } else {
        // Legacy Fallback
        sourceData = cacheData.withdrawals.filter(e =>
          e.time >= startTs && e.time <= endTs &&
          (e.type === 'withdrawal' || e.type === 'deposit')
        );
        logTrace(`Generating Summary from ${sourceData.length} Cache Entries`);
      }

      // Deduplication Set (Only needed for Legacy, Table is assumed clean)
      const seenIds = new Set();

      for (const item of sourceData) {
        let e, assetKey, amount;

        if (isFromTable) {
          // bankRecord item: { details, amounts: {USDT: -100}, _raw: e }
          // We need to handle potentially MULTIPLE assets in one row (though unlikely for withdrawal)
          // But usually a withdrawal element affects one main asset.
          // We iterate the amounts in the row.

          // Extract Recipient from Details
          let recipient = item.details || "Unknown";

          // v3.011: Enhanced Fallback for "Unknown"
          // If details contains "Withdrawal to..." or similar, extract from there
          if (recipient === "Unknown" && item._raw && item._raw.info) {
            recipient = item._raw.info;
          }
          if (recipient === "Unknown" && item.details && item.details !== "Unknown") {
            // Try to parse from the generic details if populated
            recipient = item.details;
          }

          // Clean Recipient (remove (USDT) etc)
          // v3.027: Handling "Revolut Business (GBP)" -> "Revolut Business"
          recipient = recipient.replace(/\(.*\)/, "").trim();

          // Also apply the "First 2 words" rule but be careful not to kill valid names
          // Check for specific known bank names first
          if (recipient.includes("Revolut")) {
            // Keep "Revolut Ltd" or "Revolut Business"
          } else {
            recipient = recipient.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim();
            const words = recipient.split(/\s+/);
            if (words.length > 2) recipient = words.slice(0, 2).join(" ");
          }

          // v3.030: User requested NO hardcoding.
          // if (recipient === "Revolut Ltd") recipient = "Revolut Business";

          // Iterate Asssets in this Row
          for (const [asset, val] of Object.entries(item.amounts)) {
            if (!val) continue;
            if (asset === "USDT" || asset === "XRP") {
              // Crypto
              if (val < 0) { // Withdrawal
                amount = Math.abs(val);
                if (!cryptoTotals[recipient]) cryptoTotals[recipient] = { USDT: 0, XRP: 0, USDT_GBP: 0, XRP_GBP: 0 };
                cryptoTotals[recipient][asset] += amount; // Accumulate once


                // Calculate GBP
                // v2.90: Use enriched values from Table Generation if available
                let gbpVal = 0;
                // v3.011: Fix GBP Equivalent access using correct keys
                // The key in gbpValues (from step 382) is normalized (USDT, XRP, GBP, EUR)
                let lookupAsset = asset;
                // Ensure asset matches the normalization used in generateBankReport
                if (asset.includes("USDT")) lookupAsset = "USDT";
                else if (asset.includes("XRP") || asset === "XXRP") lookupAsset = "XRP";

                if (item.gbpValues && item.gbpValues[lookupAsset]) {
                  gbpVal = item.gbpValues[lookupAsset];
                } else if (item._raw) {
                  // Fallback to recalculation (less accurate without trade match context)
                  gbpVal = calculateGbpValue(item._raw, amount, asset);
                }

                // v3.019: Robust Fallback for Missing GBP (Check Withdrawal Cache directly)
                if ((!gbpVal || gbpVal === 0) && item._raw && cacheData.withdrawalCache) {
                  const exactMatch = cacheData.withdrawalCache.find(w => w.refid === item._raw.refid);
                  if (exactMatch && exactMatch.gbpSent) {
                    gbpVal = parseFloat(exactMatch.gbpSent);
                    logTrace(`Fallback success for ${recipient} (${asset}): Found calculated GBP ${gbpVal}`);
                  } else {
                    logTrace(`Fallback failed for ${recipient} (${asset}): No match in withdrawalCache`);
                  }
                }

                if (asset === "USDT") cryptoTotals[recipient].USDT_GBP += gbpVal;
                if (asset === "XRP") cryptoTotals[recipient].XRP_GBP += gbpVal;
              }
            } else if (asset === "GBP" || asset === "EUR") {
              // Fiat
              if (val < 0) { // Withdrawal
                amount = Math.abs(val);
                // Add to fiatWithdrawals logic
                // We need to aggregate fiat too
                let exist = fiatWithdrawals.find(f => f.recipient === recipient);
                if (!exist) {
                  exist = { recipient: recipient, GBP: 0, EUR: 0 };
                  fiatWithdrawals.push(exist);
                }
                exist[asset] += amount;
              } else if (val > 0) { // Deposit
                // item.type === 'deposit' check?
                // In bankRecords, positive is Credit.
                // Check if it's considered a "Deposit" type?
                if (item.type && item.type.toLowerCase().includes("deposit")) {
                  depositTotals[asset] += val;
                }
              }
            }

            // Accumulate Fees (from Table Row)
            if (item.fees) {
              ["GBP", "EUR", "USDT", "XRP"].forEach(fAsset => {
                // item.fees[fAsset] can be a number or undefined
                if (item.fees[fAsset] && item.fees[fAsset] > 0) {
                  if (feeTotals[fAsset] !== undefined) feeTotals[fAsset] += item.fees[fAsset];
                }
              });
            }
          }
          continue; // Next row
        }

        // --- LEGACY LOOP (If no table data) ---
        e = item;

        // Prevent processing the same RefID twice (fixes potential double counting)
        // ... (Existing Key Logic)

        const uniqueKey = `${e.refid}_${e.amount}_${e.time}_${e.asset}_${e.type}`;
        if (seenIds.has(uniqueKey)) continue;
        seenIds.add(uniqueKey);

        assetKey = getAssetKey(e.asset);
        if (!assetKey) continue;

        amount = Math.abs(e.amount);

        if (e.type === 'withdrawal') {
          // Find Recipient Logic
          let recipient = "Unknown";

          // 1. Try to link to Withdrawal History via Refid
          const hist = cacheData.withdrawalHistory.find(h => h.refid === e.refid);
          let addr = null;

          if (hist) {
            addr = hist.info || hist.address;

            // 2. Check Address Book
            // Try matching method depending on crypto/fiat
            if (addr) {
              const match = cacheData.krakenAddresses.find(a => a.address === addr);
              if (match) recipient = match.key; // Use the "Key Name" (e.g. Revolut B (EUR))
              else recipient = addr; // Fallback to raw info
            }
          }

          // 3. Fallback: If still unknown, use checking logic from 'info' text often found in ledgers? 
          if (recipient === "Unknown" && (assetKey === "GBP" || assetKey === "EUR")) {
            // Best effort
          }

          // CLEANING & TRUNCATION
          // Remove asset tags
          recipient = recipient.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim();

          // STRICT RULE: First 2 words only
          const words = recipient.split(/\s+/);
          if (words.length > 2) {
            recipient = words.slice(0, 2).join(" ");
          }

          // Segregate Data
          if (assetKey === "USDT" || assetKey === "XRP") {
            // Crypto: Aggregated
            if (!cryptoTotals[recipient]) cryptoTotals[recipient] = { USDT: 0, XRP: 0 };
            cryptoTotals[recipient][assetKey] += amount;

            // Calc GBP
            const gbpVal = calculateGbpValue(e, amount, assetKey);
            if (assetKey === "USDT") cryptoTotals[recipient].USDT_GBP += gbpVal;
            if (assetKey === "XRP") cryptoTotals[recipient].XRP_GBP += gbpVal;

          } else {
            // Fiat: List Items (or Aggregated? User said "Withdrawals to ... - summary")
            if (!fMap[recipient]) fMap[recipient] = { GBP: 0, EUR: 0, EUR_GBP: 0 }; // Initialize with EUR_GBP container
            fMap[recipient][assetKey] += amount;

            // if asset is EUR, calculate its GBP value
            if (assetKey === "EUR") {
              let eurGbpVal = 0;
              if (item.gbpValues && item.gbpValues.EUR) {
                eurGbpVal = item.gbpValues.EUR;
              } else if (item._raw) {
                // Fallback logic
                eurGbpVal = calculateGbpValue(item._raw, amount, "EUR");
                // If calculateGbpValue doesn't handle EUR well (it might expect USDT/XRP), check cache
                if ((!eurGbpVal || eurGbpVal === 0) && cacheData.ratesCache) {
                  const dStr = new Date(item._raw.time * 1000).toISOString().split('T')[0];
                  const dayRates = cacheData.ratesCache[dStr];
                  if (dayRates && dayRates.USDTEUR && dayRates.USDTGBP) {
                    // Cross rate: EUR -> USDT -> GBP ? Or direct?
                    // We usually don't have EURGBP in cache directly unless we fetch it.
                    // But we do fetch it! See line 2420 (fetchOHLC("GBPEUR")).
                    // Wait, ratesCache structure (Line 2710) only stores USDTGBP, USDTEUR, XRPGBP, XRPEUR.
                    // It does NOT store GBPEUR directly in the final cache object usually?
                    // Let's check line 2710.
                    // Providing a decent estimate: EUR / USDTEUR * USDTGBP ??
                    if (dayRates.USDTEUR > 0) {
                      eurGbpVal = amount / dayRates.USDTEUR * dayRates.USDTGBP;
                    }
                  }
                }
              }
              fMap[recipient].EUR_GBP += eurGbpVal;
            }
          }
        } else if (e.type === 'deposit') {
          if (assetKey === 'GBP' || assetKey === 'EUR') {
            depositTotals[assetKey].total += amount;
            // Calculate GBP val for deposit
            let dGbp = 0;
            if (assetKey === 'GBP') dGbp = amount;
            else if (assetKey === 'EUR') {
              // Estimate EUR->GBP
              // Try to find a rate from cache
              // Simple approx if not found: 0.85? No, prefer lookup.
              // Re-use logic:
              if (item.gbpValues && item.gbpValues.EUR) dGbp = item.gbpValues.EUR;
              else dGbp = calculateGbpValue(item._raw || e, amount, "EUR");
            }
            depositTotals[assetKey].gbpVal += dGbp;
          }
        }

        // Accumulate Fees
        const feeSource = item.fees || (e && e.fees);
        if (feeSource) {
          ["GBP", "EUR", "USDT", "XRP"].forEach(fAsset => {
            if (feeSource[fAsset] > 0) {
              const fAmt = feeSource[fAsset];
              feeTotals[fAsset].total += fAmt;

              // Calc GBP for Fee
              let fGbp = 0;
              if (fAsset === 'GBP') fGbp = fAmt;
              else {
                if (item.gbpValues && item.gbpValues[fAsset]) fGbp = item.gbpValues[fAsset] * (fAmt / amount); // Pro-rate? No, separate calc.
                // Better: direct calc
                fGbp = calculateGbpValue(item._raw || e, fAmt, fAsset);
              }
              feeTotals[fAsset].gbpVal += fGbp;
            }
          });
        }
      }

      // -- Aggregation Complete --

      const cryptoRows = Object.keys(cryptoTotals).map(r => ({ recipient: r, ...cryptoTotals[r] })).sort((a, b) => a.recipient.localeCompare(b.recipient));
      const fiatRows = Object.keys(fMap).map(r => ({ recipient: r, ...fMap[r] })).sort((a, b) => a.recipient.localeCompare(b.recipient));
      const depositRows = [{ asset: "GBP", ...depositTotals.GBP }, { asset: "EUR", ...depositTotals.EUR }];
      const feeRows = [
        { asset: "GBP", ...feeTotals.GBP },
        { asset: "EUR", ...feeTotals.EUR },
        { asset: "USDT", ...feeTotals.USDT },
        { asset: "XRP", ...feeTotals.XRP }
      ];

      summaryRecords = { crypto: cryptoRows, fiat: fiatRows, deposits: depositRows, fees: feeRows };
      localStorage.setItem("kraken_summary_staging", JSON.stringify(summaryRecords));

      renderSummaryTable();
    }

    function renderSummaryTable() {
      const div = document.getElementById("summaryReportArea");
      div.style.display = "block";

      // Check if empty (using new structure keys)
      // For deposits, we must check if total > 0 because length is always 2 (presets)
      // Show Always
      const isEmpty = false;

      // --- Container (Centered) ---
      let html = '<div style="max-width:1000px; margin:0 auto; box-shadow:0 1px 4px rgba(0,0,0,0.1); background:#fff; border-radius:4px; overflow:hidden; border:1px solid #ddd;">';

      // Main Title Bar (Blue)
      html += '<div onclick="toggleSummaryReport()" style="cursor:pointer; background:#2980b9; color:#fff; padding:8px 15px; font-size:0.8rem; font-weight:bold; display:flex; justify-content:space-between; align-items:center;" title="Click to close report">';
      html += '<span>Statement Summary</span>';
      if (!isEmpty) {
        html += '<button onclick="event.stopPropagation(); copySummaryReport()" title="Copy Table" style="padding:2px 8px; background:#fff; color:#2980b9; border:none; border-radius:3px; font-size:0.65rem; font-weight:600; cursor:pointer;">&#x2398; Copy Tables</button>';
      }
      html += '</div>';

      if (isEmpty) {
        html += '<div style="padding:20px; text-align:center; color:#7f8c8d; font-size:0.75rem;">No summary data generated.</div>';
        html += '</div>'; // Close container
        div.innerHTML = html;
        if (div.scrollIntoView) div.scrollIntoView({ behavior: "smooth" });
        return;
      }

      html += '<div style="padding:15px;">'; // Padding for content

      // --- 1. CRYPTO TABLE ---
      html += '<div style="background:#8e44ad; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0;">Withdrawals to Recipients (USDT XRP)</div>';
      html += '<div style="overflow-x:auto;">';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:20px; border:1px solid #ddd; table-layout:fixed;">';
      html += '<thead style="background:#f9f9f9;"><tr>';
      html += '<th rowspan="2" style="padding:4px; border:1px solid #ddd; text-align:left; vertical-align:middle; width:20%;">Recipient</th>';
      html += '<th colspan="2" style="padding:4px; border:1px solid #ddd; text-align:center;">USDT Withdrawal</th>';
      html += '<th colspan="2" style="padding:4px; border:1px solid #ddd; text-align:center;">XRP Withdrawal</th>';
      html += '</tr><tr>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">USDT</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">GBP Equivalent</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">XRP Amount</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">GBP Equivalent</th>';
      html += '</tr></thead><tbody>';

      if (summaryRecords.crypto && summaryRecords.crypto.length > 0) {
        for (const r of summaryRecords.crypto) {
          html += '<tr>';
          html += `<td style="padding:5px; border:1px solid #ddd; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${escHtml(r.recipient)}">${escHtml(r.recipient)}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right;">${r.USDT > 0 ? r.USDT.toFixed(4) : "-"}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right; color:#2980b9;">${r.USDT_GBP > 0 ? r.USDT_GBP.toFixed(2) : "-"}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right;">${r.XRP > 0 ? r.XRP.toFixed(4) : "-"}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right; color:#2980b9;">${r.XRP_GBP > 0 ? r.XRP_GBP.toFixed(2) : "-"}</td>`;
          html += '</tr>';
        }
      } else {
        html += '<tr><td colspan="5" style="padding:15px; text-align:center; color:#7f8c8d; font-style:italic;">No withdrawals found for this period.</td></tr>';
      }
      html += '</tbody></table></div>';

      // --- 2. FIAT TABLE ---
      html += '<div style="background:#27ae60; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0;">Withdrawals to Haricom Bank Accounts (GBP EUR)</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:20px; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Haricom Bank Account</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">EUR</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP Equivalent (of EUR)</th>'; // New Column
      html += '</tr></thead><tbody>';

      const fiatRecipients = summaryRecords.fiat || [];
      if (fiatRecipients.length === 0) {
        html += '<tr><td colspan="4" style="text-align:center; padding:10px; font-style:italic; color:#7f8c8d;">No withdrawals found for this period.</td></tr>';
      } else {
        for (const r of fiatRecipients) {
          const gbpShow = (r.GBP && r.GBP > 0) ? r.GBP.toFixed(2) : "-";
          const eurShow = (r.EUR && r.EUR > 0) ? r.EUR.toFixed(2) : "-";
          // GBP Equivalent for EUR
          const eqShow = (r.EUR && r.EUR > 0) ? (r.EUR_GBP ? r.EUR_GBP.toFixed(2) : "0.00") : "n/a";

          html += '<tr>';
          html += `<td style="padding:4px; border:1px solid #ddd;">${r.recipient}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right;">${gbpShow}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right;">${eurShow}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; color:#7f8c8d;">${eqShow}</td>`;
          html += '</tr>';
        }
      }
      html += '</tbody></table>';

      // -- RE-IMPLEMENTING DEPOSITS SECTION TO BE ALWAYS VISIBLE --
      html += '<div style="background:#27ae60; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0; margin-top:20px;">Deposits from Haricom Bank Accounts (GBP EUR)</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:20px; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Currency</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">Total Amount</th>';
      html += '</tr></thead><tbody>';
      for (const r of summaryRecords.deposits) {
        html += '<tr>';
        html += `<td style="padding:4px; border:1px solid #ddd;">${r.asset}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; font-weight:bold;">${parseFloat(r.total || 0).toFixed(2)}</td>`;
        html += '</tr>';
      }
      html += '</tbody></table>';


      // --- 4. FEES SECTION (New V3.003) ---
      // v3.010: Changed color to Dark Slate (#2c3e50) for better accessibility (Red-Green distinction) and avoiding warning associations
      html += '<div style="background:#2c3e50; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0;">Fees (GBP EUR USDT XRP)</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:0; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Currency</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">Total Amount</th>';
      html += '</tr></thead><tbody>';

      // v3.011: Fee Display Logic with "-" for no records and proper decimals

      const renderFeeRow = (asset, total) => {
        // Heuristic: If total is 0, check if we had any activity for this asset.
        let activity = false;
        if (asset === "GBP" || asset === "EUR") {
          if (depositTotals[asset] > 0) activity = true;
          if (summaryRecords.fiat) summaryRecords.fiat.forEach(r => { if (r[asset] > 0) activity = true; });
        } else {
          if (summaryRecords.crypto) summaryRecords.crypto.forEach(r => { if (r[asset] > 0) activity = true; });
        }

        if (!activity && total === 0) return "-";

        const decimals = (asset === "GBP" || asset === "EUR") ? 2 : 4;
        return total.toFixed(decimals);
      };

      if (summaryRecords.fees && summaryRecords.fees.length > 0) {
        for (const r of summaryRecords.fees) {
          html += '<tr>';
          html += `<td style="padding:4px; border:1px solid #ddd;">${r.asset}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; font-weight:bold;">${renderFeeRow(r.asset, r.total)}</td>`;
          html += '</tr>';
        }
      }
      html += '</tbody></table>';

      html += '</div></div>'; // Close padding div, Close container div
      div.innerHTML = html;
      if (div.scrollIntoView) div.scrollIntoView({ behavior: "smooth" });
    }

    function renderBankTable() {
      const div = document.getElementById("bankReportArea");
      // Don't force display:block here, just update content. 
      updateGlobalRecordCounts();

      let html = '<table id="bankStmtTable" style="min-width:100%; width:auto; border-collapse:collapse;"><thead><tr>';

      // Fixed Columns (Rowspan 2 for vertical centering)
      const hStyle = "border:1px solid #ddd; padding:8px; vertical-align:middle; background:#f9f9f9;";
      html += `<th rowspan="2" class="w-bank-datetime" style="${hStyle}">Date</th>`;
      html += `<th rowspan="2" class="w-bank-datetime" style="${hStyle}">Time</th>`;
      html += `<th rowspan="2" class="w-type" style="${hStyle}">
        Type<br/>
        <input type="text" id="typeFilterInput" placeholder="Filter..." 
        onkeyup="filterBankReport()" onclick="event.stopPropagation()">
      </th>`;
      html += `<th rowspan="2" class="w-bank-details" style="${hStyle}">
        Description<br/>
        <input type="text" id="descFilterInput" placeholder="Filter..." 
        onkeyup="filterBankReport()" onclick="event.stopPropagation()">
      </th>`;

      // Asset Columns (Dynamic)
      // Asset Columns (Dynamic)
      TRACKED_ASSETS.forEach(asset => {
        let cleanAsset = asset;
        if (asset === "ZEUR") cleanAsset = "EUR";
        if (asset === "ZGBP") cleanAsset = "GBP";
        if (asset === "XXRP") cleanAsset = "XRP";

        html += `<th colspan="4" class="section-border-left" style="text-align:center; border-bottom:none; background:#f9f9f9;">${cleanAsset}</th>`;
      });
      html += '</tr><tr>';

      // Sub-headers (Amounts)
      TRACKED_ASSETS.forEach(asset => {
        html += `<th class="section-border-left" style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Debit</th>`;
        html += `<th style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Credit</th>`;
        html += `<th style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Fee</th>`;
        html += `<th style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Balance</th>`;
      });
      html += '</tr></thead><tbody>';

      if (bankRecords.length === 0) {
        html += `<tr><td colspan="${4 + (TRACKED_ASSETS.length * 4)}" style="text-align:center; padding:10px;">No bank statement generated. Select dates and click the button.</td></tr>`;
      } else {
        for (const r of bankRecords) {
          // Rule: Only bold the Closing Balance (or Opening?) - User said "remove bold from balances"
          // but likely meant the columns. 
          // Previous code: isBalRow ? "background:#f2f2f2; font-weight:bold;" : ""
          // We will keep bold for the ROW if it is a Balance row (Opening/Closing) for emphasis,
          // OR remove it entirely if that was the request. 
          // "Remove bold for balances, only use bold for the total below".
          // So Opening/Closing rows can be bold (Totals), but the regular rows should not have bold balance columns.
          // Regular rows didn't have bold columns before, only the Balance ROWs were bold.
          // IF "balance" refers to the column itself? 
          // Let's assume the Row Style "font-weight:bold" affects the whole row.
          const isBalRow = r.type.includes("Balance");
          const rowStyle = isBalRow ? "background:#f2f2f2; font-weight:bold;" : "";

          // Apply Z-strip to description if it contains (ZEUR) etc.
          let desc = escHtml(r.details);
          desc = desc.replace("(ZEUR)", "(EUR)").replace("(ZGBP)", "(GBP)").replace("(ZUSD)", "(USD)");

          html += `<tr style="${rowStyle}">`;
          html += `<td class="w-bank-datetime" style="padding:4px; border-bottom:1px solid #eee;">${r.date}</td>`;
          html += `<td class="w-bank-datetime" style="padding:4px; border-bottom:1px solid #eee;">${r.time}</td>`;
          html += `<td class="w-type" style="padding:4px; border-bottom:1px solid #eee;">${r.type}</td>`;
          html += `<td class="w-bank-details" style="padding:4px; border-bottom:1px solid #eee;">${desc}</td>`;

          TRACKED_ASSETS.forEach(asset => {
            const amt = r.amounts[asset];
            const fee = r.fees[asset];
            const bal = r.balances[asset];

            const dec = (asset === "USDT" || asset === "XRP") ? 4 : 2;

            // Split Debit/Credit
            // Debit: Negative amount (withdrawals/sends/trades out). Show as Positive.
            // Credit: Positive amount (deposits/trades in). Show as Positive.
            const showDeb = (amt !== undefined && amt < 0) ? Math.abs(amt).toFixed(dec) : "";
            const showCred = (amt !== undefined && amt > 0) ? Math.abs(amt).toFixed(dec) : "";

            const showFee = (fee !== undefined && fee > 0) ? fee.toFixed(dec) : "";
            const showBal = (bal !== undefined) ? bal.toFixed(dec) : "0.00";

            // Ensure individual cells aren't bold unless row is
            html += `<td class="w-bank-val section-border-left" style="padding:4px; border-bottom:1px solid #eee; color:#c0392b;">${showDeb}</td>`;
            html += `<td class="w-bank-val" style="padding:4px; border-bottom:1px solid #eee; color:#27ae60;">${showCred}</td>`;
            html += `<td class="w-bank-val" style="padding:4px; border-bottom:1px solid #eee; color:#7f8c8d;">${showFee}</td>`;
            html += `<td class="w-bank-bal" style="padding:4px; border-bottom:1px solid #eee;">${showBal}</td>`;
          });
          html += `</tr>`;
        }
      }

      html += '</tbody></table>';
      div.innerHTML = html;
    }

    // Copy Functions
    function copyBankReport() {
      if (!bankRecords || bankRecords.length === 0) { alert("No data to copy."); return; }
      const div = document.getElementById("bankReportArea");
      copyNodeText(div);
    }

    function copySummaryReport() {
      if (typeof summaryRecords === "undefined") return;

      const hasData = (summaryRecords.crypto && (summaryRecords.crypto.length > 0 || summaryRecords.fiat.length > 0 || summaryRecords.deposits.length > 0));
      if (!hasData) { alert("No data to copy."); return; }

      const div = document.getElementById("summaryReportArea");
      copyNodeText(div);
    }

    function filterDetails(query) {
      const filter = query.toUpperCase();
      const area = document.getElementById("bankReportArea");
      if (!area) return;

      const rows = area.getElementsByTagName("tr");
      // Skip headers (first 2 rows usually, checking th vs td)
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = row.getElementsByTagName("td");
        if (cells.length > 3) {
          // Description is usually index 3 (Date, Time, Type, Desc...)
          // Using class 'w-bank-details' is safer? row.querySelector(".w-bank-details")
          const descCell = row.querySelector(".w-bank-details");
          if (descCell) {
            const txt = descCell.textContent || descCell.innerText;
            if (txt.toUpperCase().indexOf(filter) > -1) {
              row.style.display = "";
            } else {
              row.style.display = "none";
            }
          }
        }
      }
    }

    function copyNodeText(node) {
      if (!node) return;
      const selection = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(node);
      selection.removeAllRanges();
      selection.addRange(range);

      try {
        document.execCommand('copy');
        alert("Table copied to clipboard!");
      } catch (e) {
        alert("Failed to copy.");
      }
      selection.removeAllRanges();
    }

    // ---------- Boot ----------
    async function waitFor(cond, timeoutMs) {
      const t0 = Date.now();
      return new Promise((resolve, reject) => {
        const tick = () => {
          if (cond()) return resolve(true);
          if (Date.now() - t0 > timeoutMs) return reject(new Error("Timeout"));
          setTimeout(tick, 50);
        };
        tick();
      });
    }

    async function boot() {
      // Load saved staging
      const savedStaging = localStorage.getItem("kraken_staging");
      if (savedStaging) {
        try {
          stagingRecords = JSON.parse(savedStaging);
        } catch (e) { }
      }

      // Load saved Bank Staging
      const savedBank = localStorage.getItem("kraken_bank_staging");
      if (savedBank) {
        try {
          bankRecords = JSON.parse(savedBank);
          // We do not auto-render or auto-show, but data is ready.
        } catch (e) { }
      }

      // Load saved Summary Staging
      const savedSummary = localStorage.getItem("kraken_summary_staging");
      if (savedSummary) {
        try {
          summaryRecords = JSON.parse(savedSummary);
        } catch (e) { }
      }

      // Load cached data from localStorage (so Generate Report works without re-pulling)
      const savedWithdrawals = localStorage.getItem("kraken_v2_withdrawals");
      const savedAddresses = localStorage.getItem("kraken_v2_addresses");
      const savedHistory = localStorage.getItem("kraken_v2_history");
      const savedRates = localStorage.getItem("kraken_v2_rates");
      if (savedWithdrawals) cacheData.withdrawals = JSON.parse(savedWithdrawals);
      if (savedAddresses) cacheData.krakenAddresses = JSON.parse(savedAddresses);
      if (savedHistory) cacheData.withdrawalHistory = JSON.parse(savedHistory);
      if (savedRates) cacheData.ratesCache = JSON.parse(savedRates);

      renderPreview();
      updateStatusCounts();

      // Auto-load API credentials from localStorage
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxyType = localStorage.getItem("kraken_cors_proxy_type");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
      const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
      const savedSheetId = localStorage.getItem("kraken_sheet_id");

      // Force update of date-dependent buttons on boot (in case of browser autofill)
      setTimeout(() => updateBankButtonLabel(), 500);
      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedSheetId) document.getElementById("googleSheetId").value = savedSheetId;
      if (savedProxyType) {
        document.getElementById("corsProxySelect").value = savedProxyType;
        if (savedProxyType === "custom" && savedProxy) {
          document.getElementById("corsProxy").value = savedProxy;
          document.getElementById("corsProxy").style.display = "block";
        }
      }
      if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
      if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;

      try {
        await waitFor(() => typeof gapi !== "undefined", 8000);
        gapiLoaded();
      } catch (_) {
        logTrace("GAPI not available.");
      }

      try {
        await waitFor(() => typeof google !== "undefined" && google.accounts && google.accounts.oauth2, 8000);
        gisLoaded();
      } catch (_) {
        logTrace("GIS not available.");
      }

      logTrace("v2.0 Ready. Set date range, then click 'Fetch & Generate Report'.");
    }

    window.addEventListener("load", boot);
  </script>
</body>

</html>