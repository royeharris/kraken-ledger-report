<!--
Version: 4.00-11
Objective: Bank Label Normalisation (GBP/EUR)
Source: Phase III-1 Bank Withdrawal Label Normalisation
Constraint: NO REFACTOR
Purpose: GitHub Pages testing
-->

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Kraken Ledger Report v4.00</title>
  <script async defer src="https://accounts.google.com/gsi/client"></script>
  <script async defer src="https://apis.google.com/js/api.js"></script>
  <style>
    :root {
      --primary: #2c3e50;
      --accent: #27ae60;
      --danger: #c0392b;
      --bg: #f8f9fa;
      --bridge: #2980b9;
      --cache: #8e44ad;
      --kraken: #5741d9;
      --joy: #27ae60;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      margin: 0;
      padding: 10px;
    }

    .container {
      max-width: 960px;
      margin: auto;
      background: #fff;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .branding-row {
      margin-bottom: 10px;
      font-size: 1.1rem;
      line-height: 1.1;
      color: var(--primary);
    }

    .branding-row b {
      font-weight: 800;
    }

    .branding-row span {
      font-weight: 500;
      font-size: 0.75rem;
      color: #7f8c8d;
      margin-left: 6px;
    }

    .header-wrap {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
      gap: 8px;
    }

    .header-btns {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      width: 100%;
    }

    .btn-lookup {
      padding: 6px;
      font-size: 0.72rem;
      border-radius: 6px;
      border: none;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      flex: 1;
      height: 52px;
      line-height: 1.1;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }

    .btn-pull {
      background: var(--cache);
    }

    .btn-refresh {
      background: var(--bridge);
    }

    .btn-save {
      background: var(--accent);
    }

    .btn-reset {
      background: var(--danger);
    }

    label {
      font-size: 0.7rem;
      font-weight: 800;
      display: block;
      margin-bottom: 2px;
      color: var(--primary);
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      font-size: 16px;
      box-sizing: border-box;
      height: 38px;
      -webkit-text-size-adjust: 100%;
      font-family: inherit;
    }

    .date-input-container {
      display: flex;
      align-items: center;
      gap: 5px;
      background: #fff;
      border: 1px solid #dcdde1;
      border-radius: 6px;
      padding: 0 8px;
      height: 38px;
    }

    .date-input-container input[type="date"] {
      border: none;
      padding: 0;
      height: 100%;
      font-size: 14px;
      flex-grow: 1;
      outline: none;
      background: transparent;
    }

    .date-input-container:hover,
    .date-input-container:focus-within {
      border: 1px solid var(--primary);
      box-shadow: 0 0 0 1px var(--primary);
    }

    .date-disp {
      font-size: 0.65rem;
      color: #7f8c8d;
      text-align: center;
      margin-top: 2px;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
      padding: 10px;
      background: #f1f2f6;
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--primary);
    }

    .status-item {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .status-item b {
      font-weight: 800;
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      width: 100%;
      margin-top: 15px;
    }

    button.action-main {
      padding: 8px 10px;
      border: none;
      border-radius: 6px;
      font-weight: 900;
      cursor: pointer;
      color: #fff;
      font-size: 0.72rem;
      -webkit-font-smoothing: antialiased;
      min-height: 52px;
    }

    .preview-wrap {
      width: 100%;
      overflow-x: auto;
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.58rem;
      table-layout: auto;
      /* Allow columns to adapt */
      font-family: inherit;
    }

    th,
    td {
      border: 1px solid #eee;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    th {
      padding: 6px 4px;
    }

    td {
      padding: 2px 3px;
    }

    th {
      background: #f2f2f2;
      font-weight: 900 !important;
      color: var(--primary);
      font-size: 0.58rem !important;
    }

    /* Fixed header enhancement */
    thead tr th {
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* Column widths - optimized for screen fit */
    .w-date {
      width: 50px;
    }

    .w-type {
      min-width: 9ch;
      width: 9ch;
      /* Sticky Type Column */
      position: sticky;
      left: 0;
      background-color: #fff;
      z-index: 20;
      border-right: 1px solid #ddd;
    }

    .w-time {
      width: 45px;
      text-align: center;
    }

    .w-recipient {
      width: 80px;
    }

    .w-sentto {
      width: 90px;
    }

    .w-asset {
      width: 30px;
      text-align: center;
    }

    .w-amount,
    .w-balance,
    .w-fee,
    .w-gbp,
    .w-gbpfee {
      text-align: right;
      white-space: nowrap;
    }

    .w-rate {
      width: 60px;
      text-align: right;
    }

    .w-cur {
      width: 50px;
      text-align: center;
    }

    .w-desttag {
      width: 60px;
    }

    .w-txid {
      width: 80px;
    }

    .w-source {
      width: 60px;
    }

    .w-wallet {
      width: 120px;
    }

    /* Bank Report specific columns */
    .w-bank-datetime {
      min-width: 14ch;
      width: 14ch;
    }

    .w-bank-details {
      min-width: 17ch;
      width: 17ch;
      /* Sticky Description Column */
      position: sticky;
      left: 9ch;
      /* Fix transparency: must be opaque to hide scrolling content behind it */
      background-color: #fff;
      z-index: 20;
      /* High z-index to stay on top of scrolling content */
      border-right: 1px solid #ddd;
    }

    /* Filter Input Optimization */
    #typeFilterInput,
    #descFilterInput {
      width: 90%;
      font-size: 0.55rem;
      padding: 1px;
      margin-top: 1px;
      height: 18px;
      /* Reduced fixed height */
    }

    .w-bank-val {
      min-width: 11ch;
      width: 11ch;
      text-align: right;
    }

    .w-bank-bal {
      min-width: 11ch;
      width: 11ch;
      text-align: right;
      /* font-weight: 700; removed per user request */
      background: #f8f9fa;
    }

    .section-border-left {
      border-left: 2px solid #bdc3c7 !important;
    }

    #log_btn {
      margin-top: 15px;
      width: 100%;
      background: var(--primary);
      color: #fff;
      font-size: 0.7rem;
      border-radius: 6px;
      padding: 8px;
      border: none;
      font-weight: 700;
      display: block;
    }

    #trace_log {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background: #2c3e50;
      color: #00ff00;
      font-family: "Courier New", monospace;
      font-size: 0.6rem;
      border-radius: 6px;
      max-height: 170px;
      overflow-y: auto;
      white-space: pre-wrap;
      cursor: pointer;
    }

    .ico {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--primary);
    }

    .cal-svg {
      width: 16px;
      height: 16px;
      display: block;
      fill: currentColor;
    }

    @media (max-width: 430px) {
      .actions {
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }

      button.action-main {
        min-height: 54px;
        padding: 8px 10px;
      }
    }

    /* Statement Summary - enforce accountant-friendly monochrome */
    #summaryReport table td,
    #summaryReport table td span {
      color: #000 !important;
    }

    #summaryReport table td {
      font-weight: 400;
    }

    #summaryReport table td .gbp-amt,
    #summaryReport table td .gbp-eq,
    #summaryReport table td .gbpEq {
      font-weight: 700 !important;
    }

    #summaryReport table td .na {
      color: #000 !important;
      font-weight: 400 !important;
    }

    /* Fixed sticky column transparency fix */
    .sticky-col {
      position: sticky;
      left: 0;
      background-color: #fff !important;
      z-index: 20;
      border-right: 1px solid #ddd;
      /* separation line */
    }
  </style>

  <script>
    (function () {
      function getDateRangeKey() {
        const s = document.getElementById('startDate')?.value || '';
        const e = document.getElementById('endDate')?.value || '';
        return s + '|' + e;
      }

      function resetStatementDerivedState() {
        // Derived summary state (must not leak across date ranges)
        window.statementSummaryTotals = {};
        window.feesByAsset = {};
        window.closingBalances = {};
        window.summaryAlreadyBuilt = false;

        // Cached FX rates + cached withdrawal rows used by summary/trade matching
        try {
          if (typeof cacheData !== "undefined" && cacheData) {
            cacheData.ratesCache = cacheData.ratesCache || {};
            cacheData.withdrawalCache = cacheData.withdrawalCache || [];
          }
        } catch (e) { }
        if (window.logTrace) logTrace("Statement Summary state reset due to date-range change.");
      }

      window.__checkAndResetSummaryState = function () {
        const key = getDateRangeKey();
        const lastKey = localStorage.getItem('kraken_last_date_range');
        if (lastKey !== key) {
          resetStatementDerivedState();
          localStorage.setItem('kraken_last_date_range', key);
          if (window.logTrace) logTrace("Date range changed ‚Üí recomputing Statement Summary.");
        } else {
          if (window.logTrace) logTrace("Date range unchanged ‚Üí reusing Statement Summary.");
        }
      };
    })();
  </script>


  <script>
    const APP_VERSION = "v4.00-11";
  </script>


  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const v = (typeof APP_VERSION !== "undefined") ? APP_VERSION : "";
      const headerEl = document.getElementById("appVersion");
      if (headerEl && v) headerEl.textContent = v;

      const traceEl = document.getElementById("trace_log");
      if (traceEl && v) traceEl.textContent = `Trace: ${v} Kraken Withdrawals Report initialized.`;

      if (v) document.title = `Kraken Reports ${v}`;
    });
  </script>

</head>

<body>
  <div class="container">
    <div class="header-wrap">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; position:relative;">
        <div class="branding-row" style="margin-bottom:0; line-height:1.2;">
          <div><b>Kraken Reports</b> <span style="font-size:0.7rem; color:#7f8c8d; font-weight:600;"><span
                id="appVersion"></span></span></div>
          <div style="font-size:0.65rem; color:#b0b0b0; font-weight:400;">GBP | EUR | USDT | XRP</div>
        </div>
        <div style="display:flex; gap:4px;">
          <button onclick="copyTraceToClipboard()"
            style="background:#16a085; padding:4px 8px; height:auto; font-size:0.65rem; border-radius:6px; border:none; color:#fff; cursor:pointer; font-weight:800;">Copy
            Trace</button>
          <button id="resetBtn" onclick="handleReportReset()"
            style="background:var(--danger); padding:4px 8px; height:auto; font-size:0.65rem; border-radius:6px; border:none; color:#fff; cursor:pointer; font-weight:800; box-shadow: 0 0 6px rgba(192,57,43,0.5);">Reset</button>
        </div>
      </div>

      <!-- Date Range -->
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
        <div>
          <label>Start Date</label>
          <div class="date-input-container" onclick="document.getElementById('startDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="startDate" onchange="handleDateChange('startDate')" type="date" />
          </div>
        </div>
        <div>
          <label>End Date</label>
          <div class="date-input-container" onclick="document.getElementById('endDate').showPicker()">
            <span class="ico" aria-hidden="true">
              <svg class="cal-svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1.5A2.5 2.5 0 0 1 22 6.5v13A2.5 2.5 0 0 1 19.5 22h-15A2.5 2.5 0 0 1 2 19.5v-13A2.5 2.5 0 0 1 4.5 4H6V3a1 1 0 0 1 1-1Zm12.5 8H4.5v9.5c0 .276.224.5.5.5h14.5c.276 0 .5-.224.5-.5V10ZM6 6H4.5a.5.5 0 0 0-.5.5V8h16V6.5a.5.5 0 0 0-.5-.5H18v1a1 1 0 1 1-2 0V6H8v1a1 1 0 1 1-2 0V6Z">
                </path>
              </svg>
            </span><input id="endDate" onchange="handleDateChange('endDate')" type="date" />
          </div>
        </div>
      </div>

      <!-- Three Action Buttons -->
      <div style="display:flex; gap:6px; margin-bottom:10px;">
        <button onclick="readLedger()"
          style="flex:1; padding:10px 4px; background:var(--primary); color:#fff; border:none; border-radius:4px; font-size:0.7rem; font-weight:600; cursor:pointer;">Read<br />Ledger</button>
        <button onclick="pullAddresses()"
          style="flex:1; padding:10px 4px; background:var(--kraken); color:#fff; border:none; border-radius:4px; font-size:0.7rem; font-weight:600; cursor:pointer;">Pull
          Addresses<br />‚ú± 2FA</button>
        <button id="generate_btn" onclick="generateReport()"
          style="flex:1; padding:8px 4px; background:var(--joy); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Generate
          Report</button>
      </div>

      <div id="auth_status"
        style="font-size:0.7rem; font-weight:700; text-align:center; margin-bottom:0; margin-top:0; color:var(--primary);">
        Status:
        Ready</div>
    </div>

    <!-- API Config Button + Panel (click to close) -->
    <button id="api_btn" onclick="toggleApiConfig()"
      style="width:100%; padding:8px; margin-top:4px; background:#34495e; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">‚öôÔ∏è
      API Config</button>

    <div id="apiConfigSection" onclick="toggleApiConfig()"
      style="display:none; margin-bottom:15px; padding:10px; background:#f1f2f6; border-radius:6px; border:2px solid #34495e; cursor:pointer;">
      <div
        style="font-size:0.85rem; font-weight:700; color:var(--primary); margin-bottom:10px; padding-bottom:6px; border-bottom:1px solid #ddd;">
        ‚öôÔ∏è Kraken API Configuration (click to close)</div>

      <div onclick="event.stopPropagation()">
        <div style="font-size:0.7rem; font-weight:700; color:var(--primary); margin-bottom:4px;">Query API (for Ledger
          data)</div>
        <label>API Key</label>
        <input autocapitalize="off" autocorrect="off" spellcheck="false" autocomplete="off" data-1p-ignore="true" data-lpignore="true" type="text" id="krakenApiKey" placeholder="API Key with Query permissions" style="margin-bottom:4px;">
        <label>Private Key</label>
        <input type="password" id="krakenPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:10px;">

        <div
          style="font-size:0.7rem; font-weight:700; color:#e67e22; margin-bottom:4px; padding-top:8px; border-top:1px solid #ddd;">
          Google Sheets (for Sync)</div>
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <label>Sheet ID</label>
          <a href="https://docs.google.com/spreadsheets" target="_blank"
            style="font-size:0.6rem; color:#000; text-decoration:none;">Open Google Sheets ‚Üó</a>
        </div>
        <input type="text" id="googleSheetId" placeholder="e.g. 1Vf0iqthwHv0kFqTRJkYShH..." style="margin-bottom:2px;">
        <div style="font-size:0.6rem; color:#95a5a6; margin-bottom:10px; line-height:1.2;">
          Found in URL: .../spreadsheets/d/<b>ID_IS_HERE</b>/edit
        </div>

        <div
          style="font-size:0.7rem; font-weight:700; color:var(--kraken); margin-bottom:4px; padding-top:8px; border-top:1px solid #ddd;">
          Withdraw API (for Addresses - requires 2FA)</div>
        <label>API Key</label>
        <input autocapitalize="off" autocorrect="off" spellcheck="false" autocomplete="off" data-1p-ignore="true" data-lpignore="true" type="text" id="withdrawApiKey" placeholder="API Key with Withdraw permissions"
          style="margin-bottom:4px;">

            <div class="col-md-6">
              <label for="googleSheetsApiKey" class="form-label">Google Sheets API Key</label>
              <input autocapitalize="off" autocorrect="off" spellcheck="false" autocomplete="off" data-1p-ignore="true" data-lpignore="true" type="text" class="form-control" id="googleSheetsApiKey" placeholder="AIza... (stored locally)">

            <div class="col-md-6">
              <label for="googleOAuthClientId" class="form-label">Google OAuth Client ID</label>
              <input autocapitalize="off" autocorrect="off" spellcheck="false" autocomplete="off" data-1p-ignore="true" data-lpignore="true" type="text" class="form-control" id="googleOAuthClientId" placeholder="xxxxx-xxxxxxxx.apps.googleusercontent.com (stored locally)">
            </div>

            </div>

        <label>Private Key</label>
        <input type="password" id="withdrawPrivateKey" placeholder="Private Key (Base64)" style="margin-bottom:10px;">

        <div style="margin-bottom:4px; padding-top:8px; border-top:1px solid #ddd;"></div>
        <label style="font-weight:700;">Proxy Configuration</label>
        <select id="corsProxySelect" onchange="handleProxyChange()" style="margin-bottom:4px; width:100%; padding:4px;">
          <option value="gas">Google Apps Script (Private & Unlimited) - RECOMMENDED</option>
          <option value="https://cors-anywhere.herokuapp.com/">cors-anywhere (Legacy/Backup)</option>
          <option value="">None (Direct - will fail in browser)</option>
        </select>

        <div id="gasConfigDiv"
          style="display:none; margin-top:4px; margin-bottom:8px; padding:8px; background:#f9fbe7; border:1px solid #c0ca33; border-radius:4px;">
          <label style="font-weight:700; color:#558b2f; font-size:0.7rem;">Your Google Web App URL</label>
          <input type="text" id="gasProxyUrl" placeholder="https://script.google.com/macros/s/.../exec"
            style="width:100%; margin-top:2px; font-size:0.7rem; padding:4px;">
          <div style="font-size:0.6rem; color:#555; margin-top:4px; line-height:1.2;">
            1. Deploy <b>kraken_cors_proxy.gs</b> as a Web App (Anyone).<br>
            2. Paste the URL here.
          </div>
        </div>

        <input type="text" id="corsProxy" placeholder="Custom proxy URL" style="display:none; margin-bottom:4px;">
        <div style="font-size:0.6rem; color:#7f8c8d; margin-top:2px;">Browser CORS blocks direct Kraken calls. Select a
          proxy or use custom.</div>

        <button onclick="saveApiConfig(); event.stopPropagation();"
          style="margin-top:10px; padding:8px 16px; background:var(--accent); color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Save
          API Keys</button>
      </div>
    </div>

    <!-- Display Buttons for Address and Ledger Viewers -->
    <button id="address_btn" onclick="toggleAddressViewer()"
      style="width:100%; padding:8px; margin-top:10px; background:#27ae60; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Addresses</button>

    <!-- Address Viewer Panel (hidden by default) - click to close -->
    <div id="addressViewerSection" onclick="toggleAddressViewer()"
      style="display:none; margin-bottom:15px; padding:10px; background:#e8f5e9; border-radius:6px; max-height:300px; overflow-y:auto; border:2px solid #27ae60; cursor:pointer;">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #a5d6a7;">
        <span style="font-size:0.85rem; font-weight:700; color:#000;">üìã Withdrawal Addresses (click to
          close)</span>
        <button onclick="event.stopPropagation(); copyAddressesToClipboard();"
          style="padding:4px 8px; background:#27ae60; color:#fff; border:none; border-radius:4px; font-size:0.6rem; cursor:pointer;">Copy
          to Clipboard</button>
      </div>
      <table id="addressTable" style="width:100%; font-size:0.6rem; border-collapse:collapse; table-layout:fixed;">
        <thead style="position:sticky; top:0; z-index:1;">
          <tr style="background:#c8e6c9; text-align:left;">
            <th style="padding:4px; border:1px solid #a5d6a7; width:40px;">Asset</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:100px;">Recipient</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:140px;">Key Name</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:200px;">Address</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:60px;">Dest Tag</th>
            <th style="padding:4px; border:1px solid #a5d6a7; width:150px;">Info / Bank Details</th>
          </tr>
        </thead>
        <tbody id="addressTableBody">
          <tr>
            <td colspan="6" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded. Click "Pull
              Addresses" first.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <button id="ledger_btn" onclick="toggleLedgerViewer()"
      style="width:100%; padding:8px; margin-top:6px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Ledger</button>

    <!-- Ledger Viewer Panel (hidden by default) - click to close -->
    <div id="ledgerViewerSection" onclick="toggleLedgerViewer()"
      style="display:none; margin-bottom:15px; padding:10px; background:#e3f2fd; border-radius:6px; max-height:300px; overflow-y:auto; border:2px solid #16a085; cursor:pointer;">
      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #90caf9;">
        <span style="font-size:0.85rem; font-weight:700; color:#16a085;">üìä Ledger Data (click to close)</span>
        <button onclick="event.stopPropagation(); copyLedgerToClipboard();"
          style="padding:4px 8px; background:#16a085; color:#fff; border:none; border-radius:4px; font-size:0.6rem; cursor:pointer;">Copy
          to Clipboard</button>
      </div>
      <table id="ledgerTable" style="width:100%; font-size:0.6rem; border-collapse:collapse; table-layout:fixed;">
        <thead style="position:sticky; top:0; z-index:1;">
          <tr style="background:#bbdefb; text-align:left;">
            <th style="padding:4px; border:1px solid #90caf9; width:70px;">Date</th>
            <th style="padding:4px; border:1px solid #90caf9; width:70px;">Type</th>
            <th style="padding:4px; border:1px solid #90caf9; width:70px;">Time</th>
            <th style="padding:4px; border:1px solid #90caf9; width:80px;">Amount</th>
            <th style="padding:4px; border:1px solid #90caf9; width:60px;">Fee</th>
            <th style="padding:4px; border:1px solid #90caf9; width:50px;">Asset</th>
            <th style="padding:4px; border:1px solid #90caf9; width:80px;">Balance</th>
            <th style="padding:4px; border:1px solid #90caf9; width:140px;">Ledger ID</th>
            <th style="padding:4px; border:1px solid #90caf9;">Ref ID</th>
          </tr>
        </thead>
        <tbody id="ledgerTableBody">
          <tr>
            <td colspan="9" style="padding:8px; text-align:center; color:#7f8c8d;">No ledger data loaded. Click "Read
              Ledger" first.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Status Bar -->
    <div class="status-row"
      style="display:flex; align-items:center; justify-content:space-between; gap:20px; padding:6px 15px;">
      <!-- Left & Center Content (Addresses + Stats) -->
      <div id="statusSummary" style="flex:1; display:flex; font-size:0.7rem;">
        <div>Ref: <b id="withdrawalCount">0</b></div>
      </div>

      <!-- Right Content (Record Counts) -->
      <div class="status-item" id="stagingHint"
        style="flex:0 0 auto; text-align:right; font-size:0.7rem; color:#7f8c8d;">
      </div>
    </div>

    <!-- Bottom Actions -->
    <div style="display:flex; gap:6px; margin-top:10px;">
      <button onclick="handleSync()"
        style="flex:1; padding:8px 4px; background:var(--bridge); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Send
        Reports<br />to Sheets</button>
      <button onclick="saveLocalData()"
        style="flex:1; padding:8px 4px; background:var(--accent); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Save<br />Local</button>
      <button id="wipeBtn" onclick="handleWipeConfirm()"
        style="flex:1; padding:8px 4px; background:var(--danger); color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer; opacity:0.85;">Clear
        Report<br />Staging</button>
      <button onclick="loadLocalData()"
        style="flex:1; padding:8px 4px; background:#8e44ad; color:#fff; border:none; border-radius:4px; font-size:0.65rem; font-weight:600; cursor:pointer;">Load<br />Local</button>
    </div>

    <!-- Copy Button moved inside Report -->

    <button id="report_btn" onclick="toggleReportViewer()"
      style="width:100%; padding:8px; margin-top:10px; background:#e67e22; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Trade/Withdrawal Report</button>

    <div class="preview-wrap" id="previewArea" style="display:none;"></div>

    <button id="btn_bank_statement" onclick="toggleBankReport()"
      style="width:100%; padding:8px; margin-top:10px; background:#2980b9; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">
      Kraken Statement (Select Dates)</button>

    <div class="preview-wrap" id="bankReportArea" style="display:none; margin-top:10px;"></div>

    <button id="btn_statement_summary" onclick="toggleSummaryReport()"
      style="width:100%; padding:8px; margin-top:5px; background:#2980b9; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer; display:none;">
      Statement Summary</button>

    <div class="preview-wrap" id="summaryReportArea" style="display:none; margin-top:10px;"></div>

    <button id="log_btn" onclick="toggleLog()"
      style="width:100%; padding:8px; margin-top:10px; background:#8e44ad; color:#fff; border:none; border-radius:4px; font-size:0.75rem; font-weight:600; cursor:pointer;">Display
      Progress Log</button>
    <div id="trace_log" onclick="toggleLog()">Trace: v4.000 Kraken Ledger Report initialized.</div>
  </div>

  <script>
    // Ensure error handlers never crash before the in-app logger exists.
    function _safeTrace(msg) {
      try {
        if (typeof window.logTrace === "function") window.logTrace(msg);
        else console.error(msg);
      } catch (e) {
        console.error(msg);
      }
    }
    window.onerror = function (message, source, lineno, colno) {
      _safeTrace("FATAL: " + message + " @ " + (source || "") + ":" + lineno + ":" + colno);
      try { updateStatus("Error Occurred", "error"); } catch (e) { }
    };
    window.onunhandledrejection = function (ev) {
      _safeTrace("FATAL PROMISE: " + (ev && ev.reason ? (ev.reason.message || ev.reason) : "unknown"));
      try { updateStatus("Error Occurred", "error"); } catch (e) { }
    };
  </script>

  <script>

    const SHEET_ID = "1Vf0iqthwHv0kFqTRJkYShH_RBpbokLmiEDWGJN3Q_E";
    const VER = "Kraken Withdrawals Report (" + APP_VERSION + ")";
    const KRAKEN_API_URL = "https://api.kraken.com";

    // Default API credentials (enter your own in API Config)
    const DEFAULT_API_KEY = "";
    const DEFAULT_PRIVATE_KEY = "";

    // Cache data structure (v2.0)
    let cacheData = {
      withdrawals: [],        // from Kraken Ledgers API (withdrawals only)
      withdrawalHistory: [],  // from Kraken WithdrawStatus API
      krakenAddresses: [],    // from Kraken WithdrawAddresses API
      ratesCache: {},         // { "2024-11-02": { USDTGBP: 0.79, USDTEUR: 0.92, ... } }
      withdrawalCache: []     // v2.90: Store calculated withdrawal rows (with GBP) for reuse
    };

    let stagingRecords = [];
    let tokenClient;
    let resetConfirmed = false;
    let wipeConfirmed = false;
    let isGenerating = false;
    let reportResetConfirmed = false;

    // ---------- Logging ----------
    function logTrace(msg) {
      const log = document.getElementById("trace_log");
      const now = new Date().toLocaleTimeString();
      const base = log.textContent && log.textContent.trim().length
        ? log.textContent
        : "Trace: " + APP_VERSION + " Kraken Ledger Report initialized.";
      log.textContent = base + "\n[" + now + "] " + msg;
      log.scrollTop = log.scrollHeight;
      console.log(msg);
    }

    window.onerror = function (message, source, lineno, colno) {
      logTrace("FATAL: " + message + " @ " + (source || "") + ":" + lineno + ":" + colno);
      updateStatus("Error Occurred", "error");
    };
    window.onunhandledrejection = function (ev) {
      logTrace("FATAL PROMISE: " + (ev && ev.reason ? (ev.reason.message || ev.reason) : "unknown"));
      updateStatus("Error Occurred", "error");
    };

    function toggleLog() {
      const btn = document.getElementById("log_btn");
      const log = document.getElementById("trace_log");
      // Fix double-click issue: initially style.display is "" but CSS is "none"
      const isHidden = (log.style.display === "none" || log.style.display === "");
      // Keep button visible, just change label
      if (isHidden) {
        btn.textContent = "Display Progress Log (click to close)";
        log.style.display = "block";
      } else {
        btn.textContent = "Display Progress Log";
        log.style.display = "none";
      }
    }

    // Toggle report preview visibility
    function toggleReportViewer() {
      const btn = document.getElementById("report_btn");
      const area = document.getElementById("previewArea");
      const isHidden = area.style.display === "none";
      btn.innerText = isHidden ? "Hide Trade/Withdrawal Report" : "Display Trade/Withdrawal Report";
      area.style.display = isHidden ? "block" : "none";
    }

    function copyTraceToClipboard() {
      const log = document.getElementById("trace_log");
      const text = log.textContent || "";
      if (!text.trim() || text.trim() === "Trace: " + APP_VERSION + " Kraken Ledger Report initialized.") {
        alert("There are no trace log records to copy.");
        return;
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Trace log copied to clipboard!");
      });
    }

    function updateStatus(label, state) {
      const el = document.getElementById("auth_status");
      el.innerText = "Status: " + label;
      const colors = { idle: "#7f8c8d", active: "#27ae60", sync: "#e67e22", error: "#c0392b" };
      el.style.color = colors[state] || colors.idle;
    }

    // ---------- Date Handling ----------
    // ---------- Date Handling ----------
    function handleDateChange(id) {
      const sInput = document.getElementById("startDate");
      const eInput = document.getElementById("endDate");
      const sVal = sInput.value;
      const eVal = eInput.value;
      const today = new Date().toISOString().split("T")[0];

      // Set MAX to today for both (proactive UX)
      if (!sInput.max) sInput.max = today;
      if (!eInput.max) eInput.max = today;

      // 1. Future Check
      if (eVal && eVal > today) {
        alert("End Date cannot be in the future.");
        eInput.value = "";
        return;
      }

      // 2. Sequence Check (Only if both present)
      if (sVal && eVal) {
        if (eVal < sVal) {
          alert("End Date cannot be before Start Date.");
          eInput.value = ""; // Reset End Date
          return;
        }
      }

      // Update Bank Report Button Label (Always run this)
      updateBankButtonLabel();

      const dStr = document.getElementById(id).value;
      const dispEl = document.getElementById(id + "Disp");
      if (!dispEl) return; // Element doesn't exist in new design, safe to exit if we only needed to update it

      if (!dStr) { dispEl.innerText = ""; return; }
      const [y, m, d] = dStr.split("-").map(Number);
      const dt = new Date(y, m - 1, d);
      const day = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][dt.getDay()];
      const mon = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][dt.getMonth()];
      dispEl.innerText = day + " " + dt.getDate() + " " + mon + " '" + String(dt.getFullYear()).slice(-2);
    }

    function updateBankButtonLabel() {
      const s = document.getElementById("startDate").value;
      const e = document.getElementById("endDate").value;
      const btn = document.getElementById("btn_bank_statement");

      if (s && e) {
        // Format dates nicely e.g. 01 Nov 2024
        const fmt = (dStr) => {
          const [y, m, d] = dStr.split("-");
          if (!m) return dStr;
          const mon = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][parseInt(m) - 1];
          return `${d} ${mon} ${y}`;
        };
        btn.textContent = `Kraken Statement ${fmt(s)} to ${fmt(e)}`;

        // Also show Summary Button
        const sumBtn = document.getElementById("btn_statement_summary");
        if (sumBtn) sumBtn.style.display = "block";
      } else {
        btn.textContent = "Kraken Statement (Select Dates)";
        const sumBtn = document.getElementById("btn_statement_summary");
        if (sumBtn) sumBtn.style.display = "none";
      }
    }

    // ---------- Reset / Wipe ----------
    function handleResetConfirm() {
      const btn = document.getElementById("resetBtn");
      if (!resetConfirmed) {
        resetConfirmed = true;
        btn.innerText = "CONFIRM?";
        setTimeout(() => { resetConfirmed = false; btn.innerText = "Reset"; }, 3000);
        return;
      }
      resetConfirmed = false;
      btn.innerText = "Reset";
      localReset();
    }

    function handleWipeConfirm() {
      const btn = document.getElementById("wipeBtn");
      if (!wipeConfirmed) {
        wipeConfirmed = true;
        btn.innerHTML = "CONFIRM?";
        setTimeout(() => { wipeConfirmed = false; btn.innerHTML = "Clear<br/>Staging"; }, 3000);
        return;
      }
      wipeConfirmed = false;
      btn.innerHTML = "Clear<br/>Staging";
      stagingRecords = [];
      localStorage.removeItem("kraken_staging");
      renderPreview();
      logTrace("Staging cleared manually.");
    }

    // Reset button with two-click confirmation - resets UI state without clearing data
    function handleReportReset() {
      const btn = document.getElementById("resetBtn");
      if (!reportResetConfirmed) {
        reportResetConfirmed = true;
        btn.innerText = "CONFIRM?";
        btn.style.animation = "pulse 0.5s ease-in-out";
        setTimeout(() => {
          reportResetConfirmed = false;
          btn.innerText = "Reset";
          btn.style.animation = "";
        }, 3000);
        return;
      }
      reportResetConfirmed = false;
      btn.innerText = "Reset";
      btn.style.animation = "";

      // Reset UI state and Clear ALL Data (Ledger, Reports, Cache)
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";

      // Clear Memory Variables
      stagingRecords = [];
      cacheData.withdrawals = [];
      cacheData.ratesCache = {};
      cacheData.withdrawalCache = [];
      if (typeof bankRecords !== 'undefined') bankRecords = [];
      if (typeof summaryRecords !== 'undefined') summaryRecords = { crypto: [], fiat: [], deposits: [], fees: [] };

      // Clear LocalStorage
      localStorage.removeItem("kraken_staging");
      localStorage.removeItem("kraken_v2_withdrawals");
      localStorage.removeItem("kraken_v2_rates_" + APP_VERSION);
      localStorage.removeItem("kraken_summary_staging_" + APP_VERSION);

      // Clear Views
      renderPreview();
      renderLedgerTable();
      const bankArea = document.getElementById("bankReportArea");
      if (bankArea) bankArea.style.display = 'none'; // Hide bank area
      const summaryArea = document.getElementById("summaryReportArea");
      if (summaryArea) summaryArea.style.display = 'none'; // Hide summary area

      updateStatus("Ready", "idle");
      updateStatusCounts(); // This calls updateGlobalRecordCounts internally now
      logTrace("=== APPLICATION RESET ===\nUI reset. Ledger cleared. Reports cleared.");
    }


    // Copy report to clipboard (tab-separated for spreadsheet paste)
    function copyReportToClipboard() {
      if (!stagingRecords.length) {
        alert("No report records to copy. Generate a report first.");
        return;
      }

      // Build header row - match the report table order
      const headers = ["Date", "Type", "Time (UTC)", "Recipient", "Sent to", "GBP Sent", "Amount", "Fee", "Asset", "GBP Fee", "Conv Rate", "Conv Currency", "Source", "Destination", "Dest Tag", "Transaction ID"];

      // Build data rows
      let text = headers.join("\t") + "\n";
      for (const r of stagingRecords) {
        const row = [
          r.dateSent,
          r.type || '',
          r.timeSent || '',
          r.recipient,
          r.sentTo || '',
          r.gbpSent || '',
          r.amount,
          r.fee,
          r.asset,
          r.gbpFee || '',
          r.conversionRate || '',
          r.conversionCurrency || '',
          r.rateSource || '',
          r.wallet,
          r.destTag,
          r.txId
        ];
        text += row.join("\t") + "\n";
      }




      navigator.clipboard.writeText(text).then(() => {
        alert("Report copied to clipboard! (" + stagingRecords.length + " records)");
        logTrace("Copied " + stagingRecords.length + " report records to clipboard");
      }).catch(err => {
        logTrace("ERROR copying to clipboard: " + err);
        alert("Failed to copy. Check browser permissions.");
      });
    }

    function localReset() {
      document.getElementById("startDate").value = "";
      document.getElementById("endDate").value = "";
      updateStatusCounts();
      logTrace("UI Reset.");
    }

    // ---------- Status Display ----------
    function updateStatusCounts() {
      // Calculate categorized counts
      let wCrypto = 0, wFiat = 0, dFiat = 0;
      let tradesFiatToCrypto = 0, tradesCryptoToFiat = 0, tradesFiatToFiat = 0;

      for (const w of cacheData.withdrawals) {
        const type = (w.type || "").toLowerCase();
        const asset = (w.asset || "").toUpperCase();

        // Fix v2.80: Strict Fiat Check (Exclude USDT)
        // USDT contains "USD", so we must explicitly check.
        // Known Fiat: GBP, EUR, USD, ZGBP, ZEUR, ZUSD.
        // Known Crypto: USDT, XRP, XXRP, ETH, BTC, etc.
        const isUSDT = asset.includes("USDT");
        const isFiat = !isUSDT && (asset.includes("GBP") || asset.includes("EUR") || asset.includes("USD") || asset === "ZGBP" || asset === "ZEUR" || asset === "ZUSD");

        if (type === "withdrawal") {
          if (isFiat) wFiat++; else wCrypto++;
        } else if (type === "deposit") {
          if (isFiat) dFiat++;
        } else if (type === "trade") {
          // Count based on SPEND side (amount < 0) to avoid double counting pairs
          // Fiat -> Crypto (Buy): Spend Fiat (Amount < 0, Asset Fiat)
          // Crypto -> Fiat (Sell): Spend Crypto (Amount < 0, Asset Crypto)
          if (w.amount < 0) {
            // Find the "Buy" side (positive amount, same refid) to check its asset
            const buySide = cacheData.withdrawals.find(b => b.refid === w.refid && b.amount > 0);

            if (buySide) {
              const buyAsset = (buySide.asset || "").toUpperCase();
              const isBuyFiat = (buyAsset.includes("GBP") || buyAsset.includes("EUR") || buyAsset.includes("USD") || buyAsset === "ZGBP" || buyAsset === "ZEUR" || buyAsset === "ZUSD");

              if (isFiat && isBuyFiat) {
                tradesFiatToFiat++;
              } else if (isFiat) {
                tradesFiatToCrypto++;
              } else {
                tradesCryptoToFiat++;
              }
            } else {
              // Fallback if unmatched (shouldn't happen often)
              if (isFiat) tradesFiatToCrypto++;
              else tradesCryptoToFiat++;
            }
          }
        }
      }

      const totalTrades = tradesFiatToCrypto + tradesCryptoToFiat;

      const summaryHtml = `
        <div style="display:flex; flex-direction:row; align-items:center; justify-content:space-between; width:100%; height:100%; font-size:0.7rem;">
          <!-- Block 1: Addresses (Left) -->
          <div style="display:flex; flex-direction:column; justify-content:center; align-items:flex-start;">
             <span style="color:#d35400;">Addresses: <b id="addressCount">${cacheData.krakenAddresses.length}</b></span>
          </div>

          <!-- Block 2: Stats Grid (Centered) -->
          <div style="display:grid; grid-template-columns: auto auto; gap:2px 12px; align-items:center;">
            <!-- Row 1: Deposits -->
            <div style="font-weight:600; text-align:left; color:#000;">Deposits:</div>
            <div style="text-align:left; color:#000;">fiat <b>${dFiat}</b></div>

            <!-- Row 2: Trades -->
            <div style="font-weight:600; text-align:left; color:#8e44ad;">Trades:</div>
            <div style="text-align:left; color:#8e44ad;">
               fiat&gt;crypto <b>${tradesFiatToCrypto}</b> <span style="color:#ccc; margin:0 4px;">|</span> crypto&gt;fiat <b>${tradesCryptoToFiat}</b> <span style="color:#ccc; margin:0 4px;">|</span> fiat&gt;fiat <b>${tradesFiatToFiat}</b>
            </div>

            <!-- Row 3: Withdrawals -->
            <div style="font-weight:600; text-align:left; color:#000;">Withdrawals:</div>
            <div style="text-align:left; color:#000;">
               crypto <b>${wCrypto}</b> <span style="color:#ccc; margin:0 4px;">|</span> fiat <b>${wFiat}</b>
            </div>
          </div>
          
          <!-- Spacer to push Block 3 (in parallel div) to right, or just empty here if using external div -->
          <div style="width:10px;"></div>
        </div>
      `;

      const el = document.getElementById("statusSummary");
      if (el) el.innerHTML = summaryHtml;

      // Keep legacy IDs updated just in case
      const wCount = document.getElementById("withdrawalCount");
      if (wCount) wCount.innerText = cacheData.withdrawals.length;

      const aCount = document.getElementById("addressCount");
      if (aCount) aCount.innerText = cacheData.krakenAddresses.length;

      updateGlobalRecordCounts(); // Ensure detailed counts are updated
    }

    // ---------- CORS Proxy Handling ----------
    function handleProxyChange() {
      const select = document.getElementById("corsProxySelect");
      const gasConfigDiv = document.getElementById("gasConfigDiv");
      const customInput = document.getElementById("corsProxy");

      // Reset visibility
      if (gasConfigDiv) gasConfigDiv.style.display = "none";
      if (customInput) customInput.style.display = "none";

      if (select.value === "gas") {
        if (gasConfigDiv) gasConfigDiv.style.display = "block";
      } else if (select.value === "custom") {
        if (customInput) {
          customInput.style.display = "block";
          customInput.focus();
        }
      }
    }

    function getSelectedProxy() {
      const select = document.getElementById("corsProxySelect");
      const customInput = document.getElementById("corsProxy");
      if (select.value === "gas") {
        return "gas";
      }
      if (select.value === "custom") {
        return customInput.value.trim();
      }
      return select.value;
    }

    // ---------- Local Save/Load (v2.0) ----------

    // v3.043-2: Internal cache saver used by Summary/Closing Balances (silent, no alerts)
    function saveCacheToLocalStorage() {
      try {
        localStorage.setItem("kraken_v2_withdrawals", JSON.stringify(cacheData.withdrawals || []));
        localStorage.setItem("kraken_v2_history", JSON.stringify(cacheData.withdrawalHistory || []));
        localStorage.setItem("kraken_v2_addresses", JSON.stringify(cacheData.krakenAddresses || []));
        localStorage.setItem("kraken_v2_rates_" + APP_VERSION, JSON.stringify(cacheData.ratesCache || {}));
        // Optional: store computed withdrawalCache (used for GBP fallbacks)
        if (cacheData && Array.isArray(cacheData.withdrawalCache)) {
          localStorage.setItem("kraken_v3_withdrawal_cache", JSON.stringify(cacheData.withdrawalCache));
        }
        return true;
      } catch (e) {
        // Never fail app flow due to storage issues (quota/private mode)
        try { if (typeof logTrace === "function") logTrace("WARN: saveCacheToLocalStorage failed: " + (e && e.message ? e.message : e)); } catch (_) { }
        return false;
      }
    }

    function saveLocalData() {
      if (cacheData.withdrawals.length === 0) {
        alert("Fetch data first before saving.");
        return;
      }
      localStorage.setItem("kraken_v2_withdrawals", JSON.stringify(cacheData.withdrawals));
      localStorage.setItem("kraken_v2_history", JSON.stringify(cacheData.withdrawalHistory));
      localStorage.setItem("kraken_v2_addresses", JSON.stringify(cacheData.krakenAddresses));
      localStorage.setItem("kraken_v2_rates_" + APP_VERSION, JSON.stringify(cacheData.ratesCache));
      logTrace("Data saved to localStorage.");
      alert("Data saved to local storage.");
    }

    function loadLocalData() {
      const cached = localStorage.getItem("kraken_v2_withdrawals");
      if (!cached) {
        alert("No saved data found. Use 'Fetch & Generate Report' first.");
        return;
      }
      cacheData.withdrawals = JSON.parse(cached || "[]");
      cacheData.withdrawalHistory = JSON.parse(localStorage.getItem("kraken_v2_history") || "[]");
      cacheData.krakenAddresses = JSON.parse(localStorage.getItem("kraken_v2_addresses") || "[]");
      cacheData.ratesCache = JSON.parse(localStorage.getItem("kraken_v2_rates_" + APP_VERSION) || "{}");
      updateStatusCounts();
      logTrace("Loaded from localStorage. Withdrawals=" + cacheData.withdrawals.length);

      // Regenerate report from cached data
      generateReportFromCache();
    }

    function saveApiConfig() {
      const apiKey = document.getElementById("krakenApiKey").value;
      const privateKey = document.getElementById("krakenPrivateKey").value;
      const withdrawKey = document.getElementById("withdrawApiKey").value;
      const withdrawPrivate = document.getElementById("withdrawPrivateKey").value;
      const sheetId = document.getElementById("googleSheetId").value;
      const proxy = getSelectedProxy();
      const gasUrl = document.getElementById("gasProxyUrl").value;
      const googleSheetsApiKey = document.getElementById("googleSheetsApiKey").value;
      const googleOAuthClientId = document.getElementById("googleOAuthClientId").value;

      localStorage.setItem("kraken_api_key", apiKey);
      localStorage.setItem("kraken_private_key", privateKey);
      localStorage.setItem("kraken_withdraw_api_key", withdrawKey);
      localStorage.setItem("kraken_withdraw_private_key", withdrawPrivate);
      localStorage.setItem("krk_google_sheets_api_key", googleSheetsApiKey || "");
      localStorage.setItem("krk_google_oauth_client_id", googleOAuthClientId || "");
      if (sheetId && sheetId.trim()) localStorage.setItem("kraken_sheet_id", sheetId.trim());

      localStorage.setItem("kraken_cors_proxy", proxy);
      localStorage.setItem("kraken_cors_proxy_type", document.getElementById("corsProxySelect").value);
      localStorage.setItem("kraken_gas_proxy_url", gasUrl ? gasUrl.trim() : "");

      initGoogleFromConfig(false);
      logTrace("API credentials saved (Query + Withdraw).");
      alert("API keys saved.");
    }

    // ========== STEP 1: Read Ledger (Query API - no 2FA needed) ==========
    async function readLedger() {
      // Validate date range
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;

      if (!startDate || !endDate) {
        // alert("Please select Start Date and End Date first.");
        logTrace("WARNING: User attempted to read ledger without setting dates.");
        updateStatus("Set Date Range", "error");
        logTrace("ERROR: Date range not set");
        return;
      }

      const startTime = new Date(startDate).getTime() / 1000;
      const endTime = new Date(endDate + "T23:59:59").getTime() / 1000;

      logTrace("=== READ LEDGER ===");
      logTrace("Date range: " + startDate + " to " + endDate);
      logTrace("Unix range: " + startTime + " to " + endTime);

      // v3.045-19.47c: Fixed Scope - genBtn defined before try block
      const genBtn = document.getElementById("generate_btn");

      try {
        const creds = getApiCredentials();
        logTrace("Using Query API Key: " + creds.apiKey.substring(0, 8) + "...");
        logTrace("Proxy: " + (creds.proxy || "(none)"));

        if (genBtn) genBtn.disabled = true;
        cacheData.withdrawals = []; // Clear stale data

        updateStatus("Reading Ledger...", "sync");

        // Paginate through ALL ledger records (all types)
        const allLedgerEntries = [];
        let offset = 0;
        let hasMore = true;
        let totalCount = 0;

        while (hasMore) {
          logTrace("Calling Kraken Ledgers API (offset=" + offset + ")...");
          const ledgerResult = await callKrakenPrivateAPI("Ledgers", {
            // No type filter - get all types: withdrawal, deposit, trade, etc.
            start: Math.floor(startTime),
            end: Math.floor(endTime),
            ofs: offset
          }, creds);

          // Get total count from first response
          if (offset === 0 && ledgerResult.count) {
            totalCount = ledgerResult.count;
            logTrace("Total ledger entries (all types): " + totalCount);
          }

          const ledgerData = ledgerResult.ledger || {};
          const batchSize = Object.keys(ledgerData).length;
          logTrace("Batch " + (Math.floor(offset / 50) + 1) + ": " + batchSize + " records");

          if (batchSize === 0) {
            hasMore = false;
            break;
          }

          // Parse and filter for USDT/XRP
          for (const [ledgerId, entry] of Object.entries(ledgerData)) {
            const asset = (entry.asset || "").toUpperCase();
            // Include USDT, XRP. Also include Fiat assets (GBP, EUR, USD) to detect Fiat Deposits
            const isCrypto = asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP";
            const isFiat = asset.includes("GBP") || asset.includes("EUR") || asset.includes("USD") ||
              asset === "ZGBP" || asset === "ZEUR" || asset === "ZUSD";

            if (isCrypto || isFiat) {
              allLedgerEntries.push({
                ledgerId,
                refid: entry.refid,
                time: entry.time,
                type: entry.type || "unknown",  // withdrawal, deposit, trade, etc.
                asset: asset,
                amount: parseFloat(entry.amount || 0),
                fee: parseFloat(entry.fee || 0),
                balance: parseFloat(entry.balance || 0)
              });
            }
          }

          offset += batchSize;

          // Stop if we've fetched fewer than 50 records (no more pages)
          if (batchSize < 50) {
            hasMore = false;
          }

          // Add delay between requests to avoid rate limiting (1 second)
          if (hasMore) {
            await new Promise(r => setTimeout(r, 1000));
          }
        }

        // --- CLASSIFY TRADES (One-Time Pass) ---
        // Group by RefID to analyze the full context of each trade (Trade Pairs)
        const tradeGroups = {};
        for (const entry of allLedgerEntries) {
          if (entry.type === 'trade') {
            if (!tradeGroups[entry.refid]) tradeGroups[entry.refid] = [];
            tradeGroups[entry.refid].push(entry);
          }
        }

        for (const [refid, group] of Object.entries(tradeGroups)) {
          // Identify assets involved in this trade
          let hasFiat = false;
          let hasCrypto = false;

          group.forEach(t => {
            const a = t.asset.toUpperCase();
            const isFiat = a.includes("GBP") || a.includes("EUR") || a.includes("USD") || a === "ZGBP" || a === "ZEUR";
            if (isFiat) hasFiat = true;
            else hasCrypto = true; // Assumption: if not fiat, it's crypto (USDT, XRP, ETH etc)
          });

          let typeLabel = "unknown";
          if (hasFiat && hasCrypto) {
            // Determine direction? 
            // Spend Fiat -> Buy Crypto (Fiat -> Crypto)
            // Spend Crypto -> Buy Fiat (Crypto -> Fiat)
            // We check the SPEND side (negative amount)
            const spendSide = group.find(t => t.amount < 0);
            if (spendSide) {
              const a = spendSide.asset.toUpperCase();
              const spendIsFiat = a.includes("GBP") || a.includes("EUR") || a.includes("USD") || a === "ZGBP" || a === "ZEUR";
              typeLabel = spendIsFiat ? "fiat-crypto" : "crypto-fiat";
            } else {
              typeLabel = "fiat-crypto"; // Fallback/Mixed
            }
          } else if (hasFiat && !hasCrypto) {
            typeLabel = "fiat-fiat";
          } else if (!hasFiat && hasCrypto) {
            typeLabel = "crypto-crypto";
          }

          // TAG EVERY ROW IN THIS GROUP with the global classification
          group.forEach(t => t.tradeScope = typeLabel);
        }

        cacheData.withdrawals = allLedgerEntries;  // Still use withdrawals key for compatibility

        // Re-enable Generate Button
        if (genBtn) {
          genBtn.disabled = false;
          genBtn.innerText = "Generate Report"; // Reset text if needed
          genBtn.style.opacity = "1.0";
        }

        updateStatusCounts();
        renderLedgerTable();

        logTrace("SUCCESS: Fetched " + allLedgerEntries.length + " USDT/XRP entries (from " + offset + " total entries)");
        updateStatus("Ledger: " + allLedgerEntries.length, "active");


      } catch (e) {
        if (genBtn) genBtn.disabled = false; // Re-enable on error
        updateStatus("Ledger Error", "error");
        logTrace("ERROR in readLedger: " + (e.message || e));
        // alert("Error reading ledger: " + (e.message || e));
      }
    }

    // ========== STEP 2: Pull Addresses (Withdraw API - requires 2FA) ==========
    async function pullAddresses() {
      logTrace("=== PULL ADDRESSES ===");

      // Prompt for 2FA
      const otp = prompt("Enter your Kraken 2FA code:");
      if (!otp || otp.trim() === "") {
        logTrace("2FA cancelled by user");
        return;
      }

      try {
        const creds = getWithdrawCredentials();
        logTrace("Using Withdraw API Key: " + creds.apiKey.substring(0, 8) + "...");

        updateStatus("Pulling Addresses...", "sync");

        // Call WithdrawAddresses API
        logTrace("Calling Kraken WithdrawAddresses API...");
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, creds);

        cacheData.krakenAddresses = addresses || [];
        logTrace("SUCCESS: Fetched " + cacheData.krakenAddresses.length + " addresses");

        // Also fetch withdrawal history for destination details
        logTrace("Calling WithdrawStatus API...");
        await fetchWithdrawalHistory(otp.trim());

        updateStatusCounts();

        // Log structure of first address to inspect fields (User Request v2.48)
        if (cacheData.krakenAddresses.length > 0) {
          logTrace("DEBUG: First address structure keys: " + Object.keys(cacheData.krakenAddresses[0]).join(", "));
          logTrace("DEBUG: First address sample: " + JSON.stringify(cacheData.krakenAddresses[0]));
        }

        renderAddressTable();

        updateStatus("Addresses: " + cacheData.krakenAddresses.length, "active");

      } catch (e) {
        updateStatus("Address Error", "error");
        logTrace("ERROR in pullAddresses: " + (e.message || e));
        // alert("Error pulling addresses: " + (e.message || e));
      }
    }

    // ========== STEP 3: Generate Report (local processing only) ==========
    async function generateReport() {
      // Prevent double-click / concurrent generation
      if (isGenerating) {
        logTrace("Report generation already in progress - ignoring click");
        return;
      }

      const btn = document.getElementById("generate_btn");
      isGenerating = true;
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = "Generating...<br/>Please wait";
        btn.style.opacity = "0.6";
      }

      logTrace("=== GENERATE REPORT ===");

      // Auto-Clear other reports to prevent stale data
      bankRecords = [];
      summaryRecords = { withdrawals: [], deposits: [] };
      localStorage.removeItem("kraken_bank_staging");
      localStorage.removeItem("kraken_summary_staging_" + APP_VERSION);

      const bankArea = document.getElementById("bankReportArea");
      if (bankArea) bankArea.style.display = "none";
      const summArea = document.getElementById("summaryReportArea");
      if (summArea) summArea.style.display = "none";

      const sBtn = document.getElementById("btn_bank_statement");
      if (sBtn) {
        // Reset button text checks and force update based on current dates
        if (sBtn.textContent === "Generating...") sBtn.textContent = "Kraken Statement (Select Dates)";

        // Force update of label and Summary button visibility based on dates
        updateBankButtonLabel();
      }

      // Check prerequisites
      if (cacheData.withdrawals.length === 0) {
        logTrace("Action Required: Please click 'Read Ledger' before generating a report.");
        updateStatus("No Ledger Data", "idle");
        resetGenerateButton(btn);
        return;
      }

      if (cacheData.krakenAddresses.length === 0) {
        logTrace("Action Required: Please click 'Pull Addresses' to enrich the report with recipient names.");
        updateStatus("No Addresses", "idle");
        resetGenerateButton(btn);
        return;
      }

      try {
        // Generate report from cached data
        await generateReportFromCache();
      } finally {
        resetGenerateButton(btn);
      }
    }

    function resetGenerateButton(btn) {
      isGenerating = false;
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = "Generate<br/>Report";
        btn.style.opacity = "1";
      }
    }

    // ========== Toggle Ledger Viewer ==========
    function toggleLedgerViewer() {
      const btn = document.getElementById("ledger_btn");
      const section = document.getElementById("ledgerViewerSection");
      const isHidden = section.style.display === "none";
      // Keep button visible, just change label
      if (isHidden) {
        btn.textContent = "Display Ledger (click to close)";
        section.style.display = "block";
        renderLedgerTable();
      } else {
        btn.textContent = "Display Ledger";
        section.style.display = "none";
      }
    }

    // ========== Render Ledger Table ==========
    function renderLedgerTable() {
      const tbody = document.getElementById("ledgerTableBody");
      if (cacheData.withdrawals.length === 0) {
        tbody.innerHTML = '<tr><td colspan="9" style="padding:8px; text-align:center; color:#7f8c8d;">No ledger data loaded.</td></tr>';
        return;
      }

      let html = "";
      for (const w of cacheData.withdrawals) {
        const dateStr = formatTimestamp(w.time);
        const timeStr = formatTime(w.time);
        html += "<tr>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(dateStr) + "</td>";
        html += '<td style="padding:4px 4px 4px 1px; border:1px solid #90caf9;">' + escHtml(w.type || "") + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(timeStr) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + w.amount.toFixed(6) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + Math.abs(w.fee).toFixed(6) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + escHtml(w.asset) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9;">' + w.balance.toFixed(6) + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9; word-break:break-all;">' + escHtml(w.ledgerId || "") + "</td>";
        html += '<td style="padding:4px; border:1px solid #90caf9; word-break:break-all;">' + escHtml(w.refid || "") + "</td>";
        html += "</tr>";
      }
      tbody.innerHTML = html;
      updateGlobalRecordCounts();
    }

    // ========== Copy to Clipboard Functions ==========
    function copyAddressesToClipboard() {
      if (cacheData.krakenAddresses.length === 0) {
        alert("No addresses to copy.");
        return;
      }
      let text = "Asset\tRecipient\tKey Name\tAddress\tDest Tag\tInfo\n";
      for (const a of cacheData.krakenAddresses) {
        const recipient = (a.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20)\s*/gi, "").trim();
        text += (a.asset || "") + "\t" + recipient + "\t" + (a.key || "") + "\t" + (a.address || "") + "\t" + (a.tag || a.memo || "") + "\t" + (a.info || "") + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Addresses copied to clipboard!");
        logTrace("Copied " + cacheData.krakenAddresses.length + " addresses to clipboard");
      });
    }

    function copyReportToClipboard() {
      if (!stagingRecords || stagingRecords.length === 0) {
        alert("No report data to copy.");
        return;
      }

      let text = "Date\tType\tTime\tRecipient\tSentTo\tGBPSent\tAmount\tFee\tAsset\tGBPFee\tRate\tCurrency\tSource\tDest\tTag\tTxID\n";

      for (const r of stagingRecords) {
        text += `${r.dateSent}\t${r.type}\t${r.timeSent}\t${r.recipient}\t${r.sentTo}\t${r.gbpSent}\t${r.amount}\t${r.fee}\t${r.asset}\t${r.gbpFee}\t${r.conversionRate}\t${r.conversionCurrency}\t${r.rateSource}\t${r.wallet}\t${r.destTag}\t${r.txId}\n`;
      }

      navigator.clipboard.writeText(text).then(() => {
        alert("Report copied to clipboard! Ready to paste into Excel/Sheets.");
      });
    }

    function copyLedgerToClipboard() {
      if (cacheData.withdrawals.length === 0) {
        alert("No ledger data to copy.");
        return;
      }
      let text = "Date\tAsset\tAmount\tFee\tRefID\n";
      for (const w of cacheData.withdrawals) {
        text += formatTimestamp(w.time) + "\t" + w.asset + "\t" + Math.abs(w.amount) + "\t" + Math.abs(w.fee) + "\t" + (w.refid || "") + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        alert("Ledger data copied to clipboard!");
        logTrace("Copied " + cacheData.withdrawals.length + " ledger entries to clipboard");
      });
    }

    // Helper for detailed record counts (User Requested Format)
    function updateGlobalRecordCounts() {
      const hint = document.getElementById("stagingHint");
      if (!hint) return;

      const ledgerCount = (cacheData.withdrawals && Array.isArray(cacheData.withdrawals)) ? cacheData.withdrawals.length : 0;
      const reportCount = (stagingRecords && Array.isArray(stagingRecords)) ? stagingRecords.length : 0;
      // Filter out Opening/Closing Balance rows from the count (User Request v3.045-19.24)
      const bankCount = (typeof bankRecords !== 'undefined' && Array.isArray(bankRecords))
        ? bankRecords.filter(r => r.type !== 'Balance').length
        : 0;

      // Calculate Reconciliations for Tooltip
      const depositCount = cacheData.withdrawals.filter(w => w.type === 'deposit').length;


      const tooltipText = `Logic Breakdown:\n` +
        `1. Ledger (${ledgerCount}): All raw records.\n` +
        `2. T/W Report (${reportCount}): Detailed list (Should match Ledger).\n` +
        `3. Statement (${bankCount}): Low count expected (Merges 2x Trade lines into 1).`;

      // Flex layout for vertical stacking: Label | Ledger | Trade/Withdraw Report | Statement Report
      // Grid layout for tight vertical stacking and aligned numbers
      // Grid layout for tight vertical stacking and aligned numbers
      // Grid layout for tight vertical stacking and aligned numbers. Matches Left side font size.
      hint.innerHTML = `
        <div style="display:flex; gap:15px; align-items:center; font-size:0.7rem;">
          <!-- Col 1: Label (Vertically Centered) -->
          <div style="display:flex; flex-direction:column; justify-content:center; height:100%; line-height:1.2; color:#333; font-weight:600;" title="${tooltipText}">
            <span>Number of</span>
            <span>Records</span>
          </div>

          <!-- Col 2: Stats Grid -->
          <div style="display:grid; grid-template-columns: auto auto; gap:2px 15px; align-items:baseline;">
            <!-- Ledger -->
            <div style="color:#16a085; text-align:left;">Ledger</div>
            <div style="font-weight:bold; color:#16a085; text-align:right;">${ledgerCount}</div>

            <!-- Trade/Withdraw Report -->
            <div style="color:#d35400; text-align:left;">Trade/Withdraw Report</div>
            <div style="font-weight:bold; color:#d35400; text-align:right;">${reportCount}</div>

            <!-- Statement Report -->
            <div style="color:#000; text-align:left;">Statement Report</div>
            <div style="font-weight:bold; color:#000; text-align:right;">${bankCount}</div>
          </div>
        </div>
      `;
    }

    // ---------- Staging Table Render ----------
    function renderPreview() {
      const area = document.getElementById("previewArea");

      updateGlobalRecordCounts(); // Update counts on render

      if (!stagingRecords.length) {
        area.innerHTML = "";
        return;
      }

      // Header for Preview
      let html = '<div onclick="toggleReportViewer()" style="cursor:pointer; background:#d35400; color:#fff; padding:6px 10px; font-size:0.75rem; font-weight:bold; border-radius:4px 4px 0 0; display:flex; justify-content:space-between; align-items:center;" title="Click to close report">';
      html += '<span>Trades, Withdrawals, Deposits</span>';
      html += '<button onclick="event.stopPropagation(); copyReportToClipboard()" title="Copy Table" style="padding:2px 8px; background:#fff; color:#d35400; border:none; border-radius:3px; font-size:0.65rem; font-weight:600; cursor:pointer;">&#x2398; Copy Table</button>';
      html += '</div>';

      html += '<div style="overflow-x:auto;">';
      html += '<table style="width:100%; min-width:1200px; border-collapse:collapse;"><thead><tr>';
      html += '<th class="w-date">Date</th>';
      html += '<th class="w-type">Type</th>';
      html += '<th class="w-time">Time (UTC)</th>';
      html += '<th class="w-recipient">Recipient</th>';
      html += '<th class="w-sentto">Sent to</th>';
      html += '<th class="w-gbp">GBP Sent</th>';
      html += '<th class="w-amount">Amount (Asset)</th>';
      html += '<th class="w-fee">Fee (Asset)</th>';
      html += '<th class="w-asset">Asset</th>';
      html += '<th class="w-gbpfee">GBP Fee</th>';
      html += '<th class="w-rate">Conv Rate</th>';
      html += '<th class="w-cur">Conv Currency</th>';
      html += '<th class="w-source">Source</th>';
      html += '<th class="w-wallet">Destination</th>';
      html += '<th class="w-desttag">Dest Tag</th>';
      html += '<th class="w-txid">Transaction ID</th>';
      html += '</tr></thead><tbody>';

      for (const r of stagingRecords) {

        html += '<tr>';
        html += '<td class="w-date">' + escHtml(r.dateSent) + '</td>';
        html += '<td class="w-type">' + escHtml(r.type || '') + '</td>';
        html += '<td class="w-time">' + escHtml(r.timeSent || '') + '</td>';
        html += '<td class="w-recipient">' + escHtml(r.recipient) + '</td>';
        html += '<td class="w-sentto">' + escHtml(r.sentTo || '') + '</td>';
        html += '<td class="w-gbp">' + escHtml(r.gbpSent || '') + '</td>';
        html += '<td class="w-amount">' + escHtml(r.amount) + '</td>';
        html += '<td class="w-fee">' + escHtml(r.fee) + '</td>';
        html += '<td class="w-asset">' + escHtml(r.asset) + '</td>';
        html += '<td class="w-gbpfee">' + escHtml(r.gbpFee || '') + '</td>';
        html += '<td class="w-rate">' + escHtml(r.conversionRate || '') + '</td>';
        html += '<td class="w-cur">' + escHtml(r.conversionCurrency || '') + '</td>';
        html += '<td class="w-source">' + escHtml(r.rateSource || '') + '</td>';
        html += '<td class="w-wallet">' + escHtml(r.wallet) + '</td>';
        html += '<td class="w-desttag">' + escHtml(r.destTag) + '</td>';
        html += '<td class="w-txid">' + escHtml(r.txId) + '</td>';
        html += '</tr>';
      }

      html += '</tbody></table>';
      area.innerHTML = html;
    }


    function escHtml(s) {
      if (s === null || s === undefined) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    // Parse Kraken date strings like "2024-11-02 08:42:24" to Unix timestamp
    function parseDateString(dateStr) {
      try {
        if (!dateStr && dateStr !== 0) return 0;

        // If it's already a number, return it directly (Unix timestamp in seconds)
        if (typeof dateStr === "number") {
          if (isNaN(dateStr)) return 0;
          return dateStr;
        }

        // Convert to string for parsing
        const str = String(dateStr).trim();
        if (!str) return 0;

        // If it's a numeric string without dashes, could be Unix timestamp OR Excel serial date
        const numVal = parseFloat(str);
        if (!isNaN(numVal) && str.indexOf("-") === -1) {
          // Excel serial dates are small numbers (days since 1900-01-01)
          // A date in 2024 is around 45000 in Excel format
          // Unix timestamps in seconds for 2024 are around 1700000000
          if (numVal < 100000) {
            // This is likely an Excel serial date, convert to Unix timestamp
            // Excel epoch is 1900-01-01, but Excel incorrectly considers 1900 a leap year
            // So we adjust by subtracting 25569 (days between 1900-01-01 and 1970-01-01)
            // Then multiply by 86400 (seconds per day)
            const excelEpoch = (numVal - 25569) * 86400;
            logTrace("DEBUG: Converted Excel date " + numVal + " to Unix " + excelEpoch);
            return excelEpoch;
          }

          // If number is very large (> year 2100 in seconds), it's likely milliseconds
          if (numVal > 4102444800) {
            return numVal / 1000;
          }
          return numVal;
        }

        // Parse date string like "2024-11-02 08:42:24"
        const dt = new Date(str.replace(" ", "T"));
        const result = dt.getTime() / 1000;

        // Check for invalid date
        if (isNaN(result)) {
          logTrace("WARNING: Could not parse date: '" + str + "'");
          return 0;
        }

        return result;
      } catch (e) {
        logTrace("ERROR parsing date: " + e.message);
        return 0;
      }
    }

    function extractDestTag(refid) {
      // Destination tag often appears as a numeric suffix or can be parsed from description
      // For now, return empty - will need refinement based on actual data format
      const match = String(refid).match(/\d{6,}/);
      return match ? match[0] : "";
    }

    function extractWallet(refid) {
      // Wallet address extraction - placeholder
      return "";
    }

    function extractFiatCurrency(trade) {
      const pair = (trade.pair || "").toUpperCase();
      if (pair.includes("GBP") || pair.includes("ZGBP")) return "GBP";
      if (pair.includes("EUR") || pair.includes("ZEUR")) return "EUR";
      if (pair.includes("USD") || pair.includes("ZUSD")) return "USD";
      return "";
    }

    function calculateGBPEquivalent(trade) {
      const cost = parseFloat(trade.cost || 0);
      const cur = extractFiatCurrency(trade);
      if (cur === "GBP") return cost.toFixed(2);
      if (cur === "EUR") return (cost * 0.86).toFixed(2); // Approximate EUR‚ÜíGBP
      if (cur === "USD") return (cost * 0.79).toFixed(2); // Approximate USD‚ÜíGBP
      return cost.toFixed(2);
    }

    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const d = String(dt.getDate()).padStart(2, "0");
      const m = String(dt.getMonth() + 1).padStart(2, "0");
      const y = dt.getFullYear();
      return d + "/" + m + "/" + y;
    }

    // ---------- Google Auth / Sheets ----------
    
    // v4.00-08: Initialise Google clients from saved config (prevents misleading 'not configured' logs at startup)
    function initGoogleFromConfig(silent) {
      try {
        const apiKey = localStorage.getItem("krk_google_sheets_api_key") || "";
        if (window.gapi && apiKey) {
          gapi.load("client", async () => {
            try {
              await gapi.client.init({ apiKey: apiKey });
              await gapi.client.load("sheets", "v4");
              if (!silent) logTrace("GAPI Ready.");
            } catch (e) {
              if (!silent) logTrace("GAPI init error: " + (e && e.message ? e.message : e));
            }
          });
        } else {
          if (!silent) logTrace("Google Sheets API key not configured. Use API Config.");
        }

        const cid = localStorage.getItem("krk_google_oauth_client_id") || "";
        if (window.google && google.accounts && google.accounts.oauth2 && cid) {
          tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: cid,
            scope: SCOPES,
            callback: ""
          });
          if (!silent) logTrace("GIS Ready.");
        } else {
          if (!silent) logTrace("Google OAuth Client ID not configured. Use API Config.");
        }
      } catch (e) {
        if (!silent) logTrace("Google init error: " + (e && e.message ? e.message : e));
      }
    }

function gapiLoaded() {
      // v4.00-08: keep startup silent; init happens after API Config save/load
      initGoogleFromConfig(true);
    }

    function gisLoaded() {
      // v4.00-08: keep startup silent; init happens after API Config save/load
      initGoogleFromConfig(true);
    }


    function initRefresh() {
      requestToken(true, () => fetchAllSheets());
    }

    function requestToken(forcePrompt, onOk) {
      tokenClient.callback = (resp) => {
        if (!resp || !resp.access_token) return;
        const issuedAt = Date.now();
        const expiresIn = resp.expires_in ? Number(resp.expires_in) : 3600;
        localStorage.setItem("g_token", resp.access_token);
        localStorage.setItem("g_token_issued_at", String(issuedAt));
        localStorage.setItem("g_token_expires_in", String(expiresIn));
        gapi.client.setToken({ access_token: resp.access_token });
        onOk();
      };
      const args = forcePrompt ? { prompt: "consent" } : { prompt: "" };
      tokenClient.requestAccessToken(args);
    }

    function ensureTokenThen(onOk) {
      const tok = localStorage.getItem("g_token");
      const issuedAt = Number(localStorage.getItem("g_token_issued_at") || "0");
      const exp = Number(localStorage.getItem("g_token_expires_in") || "0");
      const age = (Date.now() - issuedAt) / 1000;

      if (tok && issuedAt && exp && age < (exp - 60)) {
        gapi.client.setToken({ access_token: tok });
        onOk();
        return;
      }
      requestToken(true, onOk);
    }

    function saveSheetId(val) {
      if (val) localStorage.setItem("kraken_sheet_id", val.trim());
    }

    async function handleSync() {
      // Get ID from storage or default
      const storedSheetId = localStorage.getItem("kraken_sheet_id");
      const targetSheetId = storedSheetId || SHEET_ID;

      // We allow sync if ANY of the staging datasets are present, not just the Report staging
      // But typically user generates reports first.

      const hasStaging = stagingRecords.length > 0;
      const hasBank = (typeof bankRecords !== "undefined" && bankRecords.length > 0);
      const hasSummary = (typeof summaryRecords !== "undefined" && summaryRecords.crypto && (summaryRecords.crypto.length > 0 || summaryRecords.fiat.length > 0 || summaryRecords.deposits.length > 0));

      if (!hasStaging && !hasBank && !hasSummary) {
        alert("No reports generated to sync. Please generate a report first.");
        return;
      }

      // UI Feedback: Disable button and show "Sending..."
      const btn = document.querySelector('button[onclick="handleSync()"]');
      let originalText = "Send Reports<br/>to Sheets";
      if (btn) {
        originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = "Sending...";
        btn.style.opacity = "0.7";
        btn.style.cursor = "wait";
      }

      updateStatus("Syncing...", "sync");
      logTrace(`Sync started. Target Sheet=${targetSheetId.substr(0, 10)}...`);
      logTrace(`Records: Staging=${stagingRecords.length}, Bank=${hasBank ? bankRecords.length : 0}, Summary=${hasSummary ? "yes" : "no"}`);

      // Helper for formatting logic (copied from renderSummaryTable to fix ReferenceError)
      const _fmt2 = (v) => {
        if (v === null || v === undefined) return "-";
        const n = parseFloat(v);
        if (isNaN(n)) return "-";
        if (n === 0) return "-";
        return n.toFixed(2);
      };

      ensureTokenThen(async () => {
        try {
          // Verify Sheet Access First (cheap check)
          try {
            await gapi.client.sheets.spreadsheets.get({ spreadsheetId: targetSheetId });
          } catch (err) {
            throw new Error("Cannot access Sheet. Please check the ID in API Config and ensure you have permission (404/403).");
          }

          // 1. ReportStaging
          if (hasStaging) {
            const headers = [
              "Date", "Type", "Time (UTC)", "Recipient", "Sent to", "GBP Sent", "Amount", "Fee", "Asset",
              "GBP Fee", "Conv Rate", "Conv Currency", "Source", "Destination", "Dest Tag", "Transaction ID"
            ];

            const vals = stagingRecords.map(r => {
              // v3.022: Format Based on Asset Type
              const asset = (r.asset || "").toUpperCase();
              const isCrypto = asset.includes("USDT") || asset.includes("XRP") || asset.includes("BTC") || asset.includes("ETH");
              const decimals = isCrypto ? 4 : 2;

              const fmt = (v) => (v !== undefined && v !== "") ? parseFloat(v).toFixed(decimals) : "";
              const fmtFiat = (v) => (v !== undefined && v !== "") ? parseFloat(v).toFixed(2) : "";

              return [
                r.dateSent, r.type || '', r.timeSent || '', r.recipient, r.sentTo || '', fmtFiat(r.gbpSent),
                fmt(r.amount), fmt(r.fee), r.asset, fmtFiat(r.gbpFee), r.conversionRate || '', r.conversionCurrency || '',
                r.rateSource || '', r.wallet, r.destTag, r.txId
              ];
            });

            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: "'ReportStaging'!A:Z" });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'ReportStaging'!A1:P1", valueInputOption: "USER_ENTERED", resource: { values: [headers] }
            });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'ReportStaging'!A2:P" + (1 + vals.length), valueInputOption: "USER_ENTERED", resource: { values: vals }
            });
            logTrace("ReportStaging exported.");
          }

          // 2. KrakenLedger
          if (cacheData.withdrawals && cacheData.withdrawals.length > 0) {
            const ledgerHeaders = ["Date", "Type", "Time", "Amount", "Fee", "Asset", "Balance", "Ledger ID", "Ref ID"];
            const ledgerVals = cacheData.withdrawals.map(w => [
              w.time ? formatTimestamp(w.time) : '', w.type || '', w.time ? formatTime(w.time) : '', w.amount || 0, w.fee || 0,
              w.asset || '', w.balance || 0, w.ledgerId || '', w.refid || ''
            ]);
            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: "'KrakenLedger'!A:Z" });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenLedger'!A1:I1", valueInputOption: "USER_ENTERED", resource: { values: [ledgerHeaders] }
            });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenLedger'!A2:I" + (1 + ledgerVals.length), valueInputOption: "USER_ENTERED", resource: { values: ledgerVals }
            });
            logTrace("KrakenLedger exported.");
          }

          // 3. KrakenStatement
          if (hasBank) {
            let header1 = ["Date", "Time", "Type", "Details"];
            let header2 = ["", "", "", ""];
            TRACKED_ASSETS.forEach(a => {
              header1.push(a, "", "");
              header2.push("Amount", "P/L Fee", "Balance");
            });

            const bankVals = bankRecords.map(r => {
              let row = [r.date, r.time, r.type, r.details];
              TRACKED_ASSETS.forEach(asset => {
                const amt = r.amounts[asset];
                const fee = r.fees[asset];
                const bal = r.balances[asset];

                // Formatting Logic
                const isFiat = (asset === "GBP" || asset === "EUR");
                const decimals = isFiat ? 2 : 4;

                const fmt = (val) => {
                  if (val === undefined || val === "") return "";
                  return parseFloat(val).toFixed(decimals);
                };

                // Special case: Amount can be 0, we want to show 0.00 if it exists
                // But in the object model, undefined means "no entry for this column".

                row.push(amt !== undefined ? fmt(amt) : "");
                row.push((fee !== undefined && fee > 0) ? fmt(fee) : "");
                row.push(bal !== undefined ? fmt(bal) : "");
              });
              return row;
            });

            const rangeReq = "'KrakenStatement'!A:Z";
            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: rangeReq });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenStatement'!A1", valueInputOption: "USER_ENTERED", resource: { values: [header1, header2] }
            });
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenStatement'!A3", valueInputOption: "USER_ENTERED", resource: { values: bankVals }
            });
            logTrace("KrakenStatement exported.");
          }

          // 4. KrakenStatementSummary
          if (hasSummary) {
            let s1Headers = ["Withdrawals to Recipients  USDT | XRP", "", "", "", "", "", ""];
            let s1ColHeaders = ["Recipient", "USDT", "Avg Rate", "GBP Equivalent", "XRP Amount", "Avg Rate", "GBP Equivalent"];

            let s1Rows = [];
            const fmt = (v, d) => (v && parseFloat(v) !== 0) ? parseFloat(v).toFixed(d) : "-";

            if (summaryRecords.crypto && summaryRecords.crypto.length > 0) {
              s1Rows = summaryRecords.crypto.map(r => {
                const usdtRate = (r.USDT > 0 && r.USDT_GBP > 0) ? (r.USDT_GBP / r.USDT).toFixed(4) : "";
                const xrpRate = (r.XRP > 0 && r.XRP_GBP > 0) ? (r.XRP_GBP / r.XRP).toFixed(4) : "";
                return [
                  r.recipient,
                  fmt(r.USDT, 4),
                  usdtRate,
                  fmt(r.USDT_GBP, 2),
                  fmt(r.XRP, 4),
                  xrpRate,
                  fmt(r.XRP_GBP, 2)
                ];
              });
            } else {
              s1Rows = [["", "-", "", "-", "-", "", "-"]];
            }

            // S2: Fiat Withdrawals (Updated with EUR GBP Eq)
            let s2Headers = ["Withdrawals to Haricom Bank Accounts  GBP | EUR", "", "", ""];
            let s2ColHeaders = ["Haricom Bank Account", "GBP Amount", "EUR Amount", "EUR (GBP Eq)"];
            let s2Rows = [];
            if (summaryRecords.fiat && summaryRecords.fiat.length > 0) {
              s2Rows = summaryRecords.fiat.map(r => [
                r.recipient,
                fmt(r.GBP, 2),
                fmt(r.EUR, 2),
                (r.EUR > 0 && r.EUR_GBP > 0) ? fmt(r.EUR_GBP, 2) : "-"
              ]);
            } else {
              s2Rows = [["", "-", "-", "-"]];
            }

            // S3: Deposits
            let s3Headers = ["Deposits from Haricom Bank Accounts  GBP | EUR", "", "", ""];
            let s3ColHeaders = ["Haricom Bank Account", "GBP Amount", "EUR Amount", "EUR (GBP Eq)"];
            const s3Rows = (summaryRecords.deposits || []).map(r => [
              r.recipient,
              fmt(r.GBP, 2),
              fmt(r.EUR, 2),
              (r.EUR > 0 && r.EUR_GBP > 0) ? fmt(r.EUR_GBP, 2) : "-"
            ]);

            // S4: Fees
            let s4Headers = ["Fees  GBP | EUR | USDT | XRP", "", ""];
            let s4ColHeaders = ["Currency", "Total Amount", "GBP Equivalent"];
            const s4Rows = (summaryRecords.fees || []).map(r => [
              r.asset,
              (r.asset === "USDT" || r.asset === "XRP") ? fmt(r.total, 4) : fmt(r.total, 2),
              (r.asset === "GBP") ? "n/a" : fmt(r.gbpEq || 0, 2)
            ]);

            // S5: Reconciliation (Full Export)
            let s5Headers = ["Reconciliation Difference  GBP | EUR | USDT | XRP", "", "", "", "", ""];
            let s5ColHeaders = ["Item", "GBP", "EUR (GBP Eq)", "USDT (GBP Eq)", "XRP (GBP Eq)", "Total (GBP)"];
            let s5Rows = [];

            // Helper to sum up values from summaryRecords arrays
            const _sumAsset = (arr, assetName, field) => {
              if (!arr) return 0;
              return arr.reduce((acc, r) => {
                if (r.asset === assetName) return acc + (Number(r[field]) || 0);
                return acc;
              }, 0);
            };

            // 1. Calculate Flow Totals (GBP Eq where appropriate for columns)
            // 1. Calculate Flow Totals (GBP Eq where appropriate for columns)
            // Deposits (Haricom Bank Accounts) - These HAVE r.asset
            const depGBP = _sumAsset(summaryRecords.deposits, "GBP", "total");
            const depEUR = _sumAsset(summaryRecords.deposits, "EUR", "gbpEq");

            // Withdrawals (Recipients) - USDT/XRP (No r.asset, sum fields directly from crypto rows)
            const sumCryptoField = (arr, field) => {
              if (!arr) return 0;
              return arr.reduce((acc, r) => acc + (Number(r[field]) || 0), 0);
            };
            const wRecUSDT = -Math.abs(sumCryptoField(summaryRecords.crypto, "USDT_GBP"));
            const wRecXRP = -Math.abs(sumCryptoField(summaryRecords.crypto, "XRP_GBP"));

            // Withdrawals (Haricom Bank Accounts) - GBP/EUR (No r.asset, sum fields directly from fiat rows)
            const sumFiatField = (arr, field) => {
              if (!arr) return 0;
              return arr.reduce((acc, r) => acc + (Number(r[field]) || 0), 0);
            };
            let wBankGBP = -Math.abs(sumFiatField(summaryRecords.fiat, "GBP")); // raw GBP
            let wBankEUR = -Math.abs(sumFiatField(summaryRecords.fiat, "EUR_GBP")); // gbp eq

            // Fees
            let feeGBP = 0, feeEUR = 0, feeUSDT = 0, feeXRP = 0;
            if (summaryRecords.fees) {
              summaryRecords.fees.forEach(r => {
                if (r.asset === "GBP") feeGBP += Number(r.total || 0);
                else if (r.asset === "EUR") feeEUR += Number(r.gbpEq || 0);
                else if (r.asset === "USDT") feeUSDT += Number(r.gbpEq || 0);
                else if (r.asset === "XRP") feeXRP += Number(r.gbpEq || 0);
              });
            }
            feeGBP = -Math.abs(feeGBP);
            feeEUR = -Math.abs(feeEUR);
            feeUSDT = -Math.abs(feeUSDT);
            feeXRP = -Math.abs(feeXRP);

            // Net Trade Activity
            let tradeGBP = 0, tradeEUR = 0, tradeUSDT = 0, tradeXRP = 0;
            if (summaryRecords.trades) {
              summaryRecords.trades.forEach(r => {
                if (r.asset === "GBP") tradeGBP += Number(r.total || 0);
                else if (r.asset === "EUR") tradeEUR += Number(r.gbpEq || 0);
                else if (r.asset === "USDT") tradeUSDT += Number(r.gbpEq || 0);
                else if (r.asset === "XRP") tradeXRP += Number(r.gbpEq || 0);
              });
            }

            // 2. Calculate Opening/Closing Balances (using values passed from on-screen generation)
            let openGBP = 0, openEUR = 0, openUSDT = 0, openXRP = 0;

            if (summaryRecords.openingBalances) {
              openGBP = summaryRecords.openingBalances.GBP || 0;
              // For Sheets, we need the GBP Equivalent for EUR/USDT/XRP in the Recon table columns
              openEUR = summaryRecords.openingBalances.EUR_GBP || 0;
              // openUSDT / openXRP usually 0 but consistent
              openUSDT = summaryRecords.openingBalances.USDT_GBP || 0;
              openXRP = summaryRecords.openingBalances.XRP_GBP || 0;
            }

            let actGBP = 0, actEUR = 0, actUSDT = 0, actXRP = 0;

            const _getRate = (asset, dateStr) => {
              if (!cacheData || !cacheData.ratesCache || !dateStr) return null;
              const dr = cacheData.ratesCache[dateStr];
              if (!dr) return null;
              if (asset === "EUR") return dr.EURGBP;
              if (asset === "USDT") return dr.USDTGBP;
              if (asset === "XRP") return dr.XRPGBP;
              return null;
            };

            if (bankRecords && bankRecords.length > 0) {
              const first = bankRecords[0];
              const last = bankRecords[bankRecords.length - 1];

              // Opening
              if (first.balances) {
                openGBP = first.balances.GBP || 0;
                // For others, convert using start date rate
                const d = first.date; // YYYY-MM-DD
                const rEUR = _getRate("EUR", d) || 0;
                const rUSDT = _getRate("USDT", d) || 0;
                const rXRP = _getRate("XRP", d) || 0; // Likely 0 opening

                openEUR = (first.balances.EUR || 0) * rEUR;
                openUSDT = (first.balances.USDT || 0) * rUSDT;
                openXRP = (first.balances.XRP || 0) * rXRP;
              }

              // Closing (Actual)
              if (last.balances) {
                actGBP = last.balances.GBP || 0;
                const d = last.date;
                const rEUR = _getRate("EUR", d) || 0;
                const rUSDT = _getRate("USDT", d) || 0;
                const rXRP = _getRate("XRP", d) || 0;

                actEUR = (last.balances.EUR || 0) * rEUR;
                actUSDT = (last.balances.USDT || 0) * rUSDT;
                actXRP = (last.balances.XRP || 0) * rXRP;
              }
            }

            // 3. Calculated Closing
            const expGBP = openGBP + depGBP + wBankGBP + feeGBP + tradeGBP;
            const expEUR = openEUR + depEUR + wBankEUR + feeEUR + tradeEUR;
            const expUSDT = openUSDT + wRecUSDT + feeUSDT + tradeUSDT;
            const expXRP = openXRP + wRecXRP + feeXRP + tradeXRP;

            // 4. Differences
            const diffGBP = expGBP - actGBP;
            const diffEUR = expEUR - actEUR;
            const diffUSDT = expUSDT - actUSDT;
            const diffXRP = expXRP - actXRP;
            const diffTotal = (expGBP + expEUR + expUSDT + expXRP) - (actGBP + actEUR + actUSDT + actXRP);

            const _rowTotal = (a, b, c, d) => (a || 0) + (b || 0) + (c || 0) + (d || 0);

            // Build Rows
            const _mkRow = (label, g, e, u, x, isTotal) => [
              label,
              fmt(g, 2), fmt(e, 2), fmt(u, 2), fmt(x, 2),
              fmt(_rowTotal(g, e, u, x), 2)
            ];

            s5Rows.push(_mkRow("Opening Balance", openGBP, openEUR, openUSDT, openXRP));
            s5Rows.push(_mkRow("Deposits from bank accounts", depGBP, depEUR, 0, 0));
            s5Rows.push(_mkRow("Withdrawals to recipients", 0, 0, wRecUSDT, wRecXRP));
            s5Rows.push(_mkRow("Withdrawals to bank accounts", wBankGBP, wBankEUR, 0, 0));
            s5Rows.push(_mkRow("Fees", feeGBP, feeEUR, feeUSDT, feeXRP));
            s5Rows.push(_mkRow("Net Trade Activity", tradeGBP, tradeEUR, tradeUSDT, tradeXRP));
            s5Rows.push(_mkRow("Calculated Closing", expGBP, expEUR, expUSDT, expXRP, true));
            s5Rows.push(_mkRow("Actual Closing", actGBP, actEUR, actUSDT, actXRP, true));
            s5Rows.push(_mkRow("Reconciliation Difference", diffGBP, diffEUR, diffUSDT, diffXRP, true));

            const rangeReq = "'KrakenStatementSummary'!A:Z";
            await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId: targetSheetId, range: rangeReq });

            // S1
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: "'KrakenStatementSummary'!A1", valueInputOption: "USER_ENTERED",
              resource: { values: [s1Headers, s1ColHeaders, ...s1Rows] }
            });

            // S2
            let currentRow = 1 + 2 + s1Rows.length + 2;
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: `'KrakenStatementSummary'!A${currentRow}`, valueInputOption: "USER_ENTERED",
              resource: { values: [s2Headers, s2ColHeaders, ...s2Rows] }
            });

            // S3
            currentRow = currentRow + 2 + s2Rows.length + 2;
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: `'KrakenStatementSummary'!A${currentRow}`, valueInputOption: "USER_ENTERED",
              resource: { values: [s3Headers, s3ColHeaders, ...s3Rows] }
            });

            // S4 (Fees)
            currentRow = currentRow + 2 + s3Rows.length + 2;
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: `'KrakenStatementSummary'!A${currentRow}`, valueInputOption: "USER_ENTERED",
              resource: { values: [s4Headers, s4ColHeaders, ...s4Rows] }
            });

            // S5 (Reconciliation Table)
            currentRow = currentRow + 2 + s4Rows.length + 2;

            // Add the new Footer Note as the last row
            s5Rows.push(["", "", "", "", "", ""]); // Spacer
            const footerNote = "A reconciliation difference of GBP " + (_fmt2(diffTotal)) + " exists. This is attributed to FX variance and exchange rate fluctuations over the reporting period. Note: A positive value means calculated > actual; a negative value means calculated < actual.";
            s5Rows.push([footerNote]);

            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: targetSheetId, range: `'KrakenStatementSummary'!A${currentRow}`, valueInputOption: "USER_ENTERED",
              resource: { values: [s5Headers, s5ColHeaders, ...s5Rows] }
            });

            logTrace("KrakenStatementSummary exported.");
          }

          updateStatus("Synced All", "active");
          // alert("Sync complete.\nReports exported to Google Sheets.");
          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalText;
            btn.style.opacity = "1";
            btn.style.cursor = "pointer";
          }

        } catch (e) {
          let errMsg;
          // v2.994: Manual Extraction for Auth/Network Errors
          if (e.result && e.result.error) {
            errMsg = `Code: ${e.result.error.code}, Message: ${e.result.error.message}`;
          } else {
            // Fallback for non-JSON Error objects
            errMsg = e.toString();
            if (errMsg === "[object Object]") {
              // Try to parse keys
              try {
                const keys = Object.keys(e);
                if (keys.length > 0) errMsg = JSON.stringify(e);
                else errMsg = "Network Error (Blocked by Browser/CORS) or Auth Token Invalid";
              } catch (z) { errMsg = "Unknown Network Error"; }
            }
          }

          if (errMsg.includes("404") || errMsg.includes("NOT_FOUND")) {
            logTrace("Sync skipped: Sheet ID not found. Please set correct Sheet ID in API Config.");
            updateStatus("Sync Failed: Check SheetID", "error");
            // alert("Sync Failed: Spreadsheet Not Found (404).\n\nTarget Sheet ID: " + targetSheetId + "\n\nPlease correct it in 'API Config' or ensure you have permission.");
          } else {
            updateStatus("Sync error", "error");
            logTrace("Sync error: " + errMsg);
            // alert("Sync failed. " + errMsg);
          }
          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalText;
            btn.style.opacity = "1";
            btn.style.cursor = "pointer";
          }
        }
      });
    }

    // ---------- Address Viewer ----------
    function toggleAddressViewer() {
      const btn = document.getElementById("address_btn");
      const section = document.getElementById("addressViewerSection");
      const isHidden = section.style.display === "none";
      // Keep button visible, just change label
      if (isHidden) {
        btn.textContent = "Display Addresses (click to close)";
        section.style.display = "block";
        renderAddressTable();
      } else {
        btn.textContent = "Display Addresses";
        section.style.display = "none";
      }
    }

    function renderAddressTable() {
      const tbody = document.getElementById("addressTableBody");
      const addresses = cacheData.krakenAddresses || [];

      if (addresses.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="padding:8px; text-align:center; color:#7f8c8d;">No addresses loaded. Click "Fetch Addresses" first.</td></tr>';
        return;
      }

      // Sort by Asset, then Recipient, then Key Name
      const sorted = [...addresses].sort((a, b) => {
        const assetA = (a.asset || "").toUpperCase();
        const assetB = (b.asset || "").toUpperCase();
        if (assetA !== assetB) return assetA.localeCompare(assetB);

        const recipA = (a.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        const recipB = (b.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim();
        if (recipA !== recipB) return recipA.localeCompare(recipB);

        return (a.key || "").localeCompare(b.key || "");
      });

      let html = "";
      for (const addr of sorted) {
        const asset = escHtml(addr.asset || "");
        const keyName = escHtml(addr.key || "");
        const recipient = escHtml((addr.key || "").replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)/gi, "").trim());
        const address = escHtml(addr.address || "");
        const destTag = escHtml(addr.tag || addr.memo || "");
        const info = escHtml(addr.info || addr.bank_details || "");

        html += '<tr style="border-bottom:1px solid #e0e0e0;">';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:45px; font-size:0.6rem;">' + asset + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:150px; max-width:150px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + recipient + '">' + recipient + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:200px; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:0.6rem;" title="' + keyName + '">' + keyName + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; font-family:monospace; font-size:0.5rem; word-break:break-all;" title="' + address + '">' + address + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:70px; font-size:0.6rem;">' + destTag + '</td>';
        html += '<td style="padding:4px; border:1px solid #e0e0e0; width:150px; font-size:0.6rem; word-break:break-word;" title="' + info + '">' + info + '</td>';
        html += '</tr>';
      }

      tbody.innerHTML = html;
    }

    // ---------- Kraken API ----------

    // v3.015: Global helper to load credentials (fix for ReferenceError)
    function loadSavedCredentials() {
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxyType = localStorage.getItem("kraken_cors_proxy_type");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
      const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
      const savedSheetId = localStorage.getItem("kraken_sheet_id");

      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedProxyType) {
        const sel = document.getElementById("corsProxySelect");
        if (sel) sel.value = savedProxyType;
        if (savedProxyType === "custom" && savedProxy) {
          const inp = document.getElementById("corsProxy");
          if (inp) { inp.value = savedProxy; inp.style.display = "block"; }
        }
      }
      if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
      document.getElementById("googleSheetsApiKey").value = (localStorage.getItem("krk_google_sheets_api_key") || "");
      document.getElementById("googleOAuthClientId").value = (localStorage.getItem("krk_google_oauth_client_id") || "");
      if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;
      if (savedSheetId) document.getElementById("googleSheetId").value = savedSheetId;

      logTrace("Credentials loaded from storage.");
      initGoogleFromConfig(true);
    }


    // v3.015: Global helper to load credentials (fix for ReferenceError)
    function loadSavedCredentials() {
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxyType = localStorage.getItem("kraken_cors_proxy_type");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
      const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
      const savedSheetId = localStorage.getItem("kraken_sheet_id");

      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;
      if (savedProxyType) {
        const sel = document.getElementById("corsProxySelect");
        if (sel) sel.value = savedProxyType;
        if (savedProxyType === "custom" && savedProxy) {
          const inp = document.getElementById("corsProxy");
          if (inp) { inp.value = savedProxy; inp.style.display = "block"; }
        }
      }
      if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
      if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;
      if (savedSheetId) document.getElementById("googleSheetId").value = savedSheetId;

      logTrace("Credentials loaded from storage.");
      initGoogleFromConfig(true);
    }

    function toggleApiConfig() {
      const btn = document.getElementById("api_btn");
      const section = document.getElementById("apiConfigSection");
      const isHidden = section.style.display === "none";
      // Keep button visible, just change label
      if (isHidden) {
        btn.innerHTML = "‚öôÔ∏è API Config (click to close)";
        section.style.display = "block";
      } else {
        btn.innerHTML = "‚öôÔ∏è API Config";
        section.style.display = "none";
        return; // Don't reload credentials when closing
      }

      // Load saved credentials when opening
      // Load saved credentials when opening (refresh in case changed)
      if (isHidden) {
        loadSavedCredentials();
      }

    }

    function getApiCredentials() {
      let apiKey = document.getElementById("krakenApiKey").value.trim();
      let privateKey = document.getElementById("krakenPrivateKey").value.trim();
      if (!apiKey) apiKey = DEFAULT_API_KEY;
      if (!privateKey) privateKey = DEFAULT_PRIVATE_KEY;

      const proxy = getSelectedProxy();
      const proxyType = document.getElementById("corsProxySelect").value;
      const gasUrl = document.getElementById("gasProxyUrl").value.trim();

      return { apiKey, privateKey, proxy, proxyType, gasUrl };
    }

    // Withdraw API uses separate credentials (requires 2FA permission)
    function getWithdrawCredentials() {
      let apiKey = document.getElementById("withdrawApiKey").value.trim();
      let privateKey = document.getElementById("withdrawPrivateKey").value.trim();
      if (!apiKey || !privateKey) {
        throw new Error("Please enter Withdraw API credentials in API Config (requires 2FA permission)");
      }
      const proxy = getSelectedProxy();
      return { apiKey, privateKey, proxy };
    }

    // Base64 helpers
    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    // Kraken API signature generation using Web Crypto API
    async function createKrakenSignature(urlPath, postData, privateKeyBase64) {
      if (!privateKeyBase64 || privateKeyBase64.length < 10) {
        throw new Error("Invalid Private Key: Key is empty or too short");
      }

      const encoder = new TextEncoder();

      // Step 1: Get nonce from postData
      const params = new URLSearchParams(postData);
      const nonce = params.get("nonce");

      // Step 2: SHA256 hash of (nonce + postData)
      const sha256Data = encoder.encode(nonce + postData);
      const sha256Hash = await crypto.subtle.digest("SHA-256", sha256Data);

      // Step 3: Concatenate urlPath bytes + sha256Hash bytes
      const pathBytes = encoder.encode(urlPath);
      const combined = new Uint8Array(pathBytes.length + sha256Hash.byteLength);
      combined.set(pathBytes, 0);
      combined.set(new Uint8Array(sha256Hash), pathBytes.length);

      // Step 4: HMAC-SHA512 with decoded private key
      let privateKeyBytes;
      try {
        privateKeyBytes = base64ToArrayBuffer(privateKeyBase64);
      } catch (e) {
        throw new Error("Invalid Private Key: Not a valid Base64 string");
      }

      if (privateKeyBytes.byteLength === 0) {
        throw new Error("Invalid Private Key: Decoded key is empty");
      }

      let hmacKey;
      try {
        hmacKey = await crypto.subtle.importKey(
          "raw",
          privateKeyBytes,
          { name: "HMAC", hash: "SHA-512" },
          false,
          ["sign"]
        );
      } catch (e) {
        throw new Error("Crypto Import Key Error: " + (e.message || e) + " (Check Private Key format)");
      }

      const signature = await crypto.subtle.sign("HMAC", hmacKey, combined);

      // Step 5: Base64 encode the signature
      return arrayBufferToBase64(signature);
    }

    async function callKrakenPrivateAPI(endpoint, params = {}, credentials = null, retryCount = 0) {
      const { apiKey, privateKey, proxy, proxyType, gasUrl } = credentials || getApiCredentials();
      const urlPath = "/0/private/" + endpoint;
      const nonce = Date.now().toString();

      const postParams = new URLSearchParams({ nonce, ...params });
      const postData = postParams.toString();

      try {
        const signature = await createKrakenSignature(urlPath, postData, privateKey);

        let url = KRAKEN_API_URL + urlPath;
        let fetchOptions = {
          method: "POST",
          headers: {
            "API-Key": apiKey,
            "API-Sign": signature,
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: postData
        };

        // --- PROXY LOGIC ---
        if (proxyType === "gas" || proxy === "gas") {
          if (!gasUrl) {
            throw new Error("Google Proxy URL is missing. Please paste your Web App URL in API Config.");
          }
          // GOOGLE APPS SCRIPT WRAPPER
          // Wrapper request: POST to gasUrl with JSON body
          url = gasUrl;
          fetchOptions = {
            method: "POST",
            headers: { "Content-Type": "text/plain" }, // Use text/plain to avoid OPTIONS preflight if possible, or standard. GAS handles CORS.
            body: JSON.stringify({
              url: "https://api.kraken.com" + urlPath,
              method: "POST",
              headers: {
                "API-Key": apiKey,
                "API-Sign": signature,
                "Content-Type": "application/x-www-form-urlencoded"
              },
              payload: postData
            })
          };
          logTrace("Calling Kraken via Google Apps Script Proxy...");
        }
        else if (proxy && proxy !== "custom" && proxy !== "") {
          // PROXY URL PREFIX (cors-anywhere etc)
          url = proxy + KRAKEN_API_URL + urlPath;
          logTrace("Using standard proxy: " + proxy);
        }

        logTrace("Calling Kraken API: " + endpoint + " (with OTP: " + (params.otp ? "yes" : "no") + ")");

        const response = await fetch(url, fetchOptions);

        if (!response.ok) {
          // Special handling for cors-anywhere activation
          if (response.status === 403 && proxy && proxy.includes("herokuapp")) {
            logTrace("*** CORS-ANYWHERE 403 ***");
            const doNav = confirm("CORS Proxy requires activation (One-Time). Click OK to open the demo page, then click 'Request temporary access'. Then try again.");
            if (doNav) window.open("https://cors-anywhere.herokuapp.com/corsdemo", "_blank");
            throw new Error("Proxy Activation Required. Check the new tab.");
          }

          let errorDetails = "";
          try {
            errorDetails = await response.text();
            // If manual GAS proxy error
            if (proxyType === "gas") {
              try {
                const jsonErr = JSON.parse(errorDetails);
                if (jsonErr.statusCode && jsonErr.body) {
                  // Unwrap GAS error response
                  errorDetails = "GAS Error " + jsonErr.statusCode + ": " + jsonErr.body;
                }
              } catch (z) { }
            }
          } catch (e) { }

          throw new Error("HTTP " + response.status + ": " + response.statusText + " " + errorDetails.substring(0, 100));
        }

        const textData = await response.text();
        let rawData;
        try {
          rawData = JSON.parse(textData);
        } catch (jsonErr) {
          logTrace("JSON Parse Error. Raw response (first 200 chars): " + textData.substring(0, 200));
          throw new Error("API Parse Error: " + jsonErr.message);
        }

        // UNWRAP GAS RESPONSE ?
        // If we used GAS, the response is { statusCode: 200, body: "{...}" }
        let data = rawData;
        if (proxyType === "gas") {
          if (rawData.statusCode && rawData.body) {
            if (rawData.statusCode >= 400) {
              throw new Error("Kraken API Error (via GAS): " + rawData.body);
            }
            data = JSON.parse(rawData.body);
          }
        }

        if (data.error && data.error.length > 0) {
          throw new Error("Kraken API Error: " + data.error.join(", "));
        }

        return data.result;

      } catch (e) {
        if (e.message.includes("Failed to fetch") || e.message.includes("NetworkError")) {
          if (retryCount < 2) {
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            logTrace("Network Error. Retrying in 1s...");
            await sleep(1000);
            return callKrakenPrivateAPI(endpoint, params, credentials, retryCount + 1);
          }
          throw new Error("Network Error. Check CORS Proxy settings.");
        }
        throw e;
      }
    }


    async function fetchKrakenAddresses() {
      logTrace("Fetching Kraken withdrawal addresses...");

      try {
        // Get withdrawal-specific credentials
        const withdrawCreds = getWithdrawCredentials();

        // Prompt for 2FA code
        const otp = prompt("Enter your 2FA code for Kraken Withdrawal API:");
        if (!otp || otp.trim() === "") {
          logTrace("2FA cancelled by user");
          updateStatus("Cancelled", "idle");
          return;
        }

        updateStatus("Fetching Kraken...", "sync");

        // Fetch all withdrawal addresses using withdrawal API key with 2FA
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, withdrawCreds);

        logTrace("Kraken WithdrawAddresses response: " + JSON.stringify(addresses).substring(0, 500));

        // addresses is an array of address objects
        cacheData.krakenAddresses = addresses || [];

        // Parse into destTags (XRP) and wallets (USDT/others)
        const newDestTags = [];
        const newWallets = [];

        for (const addr of cacheData.krakenAddresses) {
          // addr structure: { address, asset, key, memo, method, new, tag, verified }
          const keyName = addr.key || "";  // This is the saved address name (e.g., "Aleksey XRP")
          const asset = addr.asset || "";
          const address = addr.address || "";
          const destTag = addr.tag || addr.memo || "";  // XRP uses tag, others might use memo

          // Try to extract recipient name from key (e.g., "Aleksey XRP" -> "Aleksey")
          const recipientName = keyName.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim() || keyName;

          if (asset.toUpperCase().includes("XRP") || asset === "XXRP") {
            newDestTags.push({
              recipient: recipientName,
              destTag: destTag,
              address: address,
              keyName: keyName,
              asset: asset
            });
          } else {
            newWallets.push({
              recipient: recipientName,
              asset: asset,
              address: address,
              keyName: keyName
            });
          }
        }

        // Merge with existing data (don't overwrite if already have data)
        if (newDestTags.length > 0) {
          cacheData.destTags = newDestTags;
          logTrace("Found " + newDestTags.length + " XRP addresses with destination tags.");
        }
        if (newWallets.length > 0) {
          cacheData.wallets = newWallets;
          logTrace("Found " + newWallets.length + " other wallet addresses (USDT, etc.).");
        }

        updateStatusCounts();
        updateStatus("Kraken OK", "active");

        const summary = "Fetched " + cacheData.krakenAddresses.length + " addresses.\n" +
          "XRP (with dest tags): " + newDestTags.length + "\n" +
          "Other wallets: " + newWallets.length;
        // alert(summary);
        logTrace(summary.replace(/\n/g, " | "));

      } catch (e) {
        updateStatus("Kraken Error", "error");
        logTrace("Kraken API error: " + (e.message || e));
        // alert("Kraken API Error:\n" + (e.message || e) + "\n\nCheck trace log for details.");
      }
    }

    // Fetch withdrawal history with destination details
    async function fetchWithdrawalHistory(otp) {
      const withdrawCreds = getWithdrawCredentials();

      // Try both USDT and XRP (common assets for withdrawals)
      const assets = ["USDT", "XXRP", "ZUSD", "ZGBP"];
      const allWithdrawals = [];

      for (const asset of assets) {
        try {
          logTrace("Fetching withdrawal history for " + asset + "...");
          const params = otp ? { asset, otp } : { asset };
          const result = await callKrakenPrivateAPI("WithdrawStatus", params, withdrawCreds);

          if (Array.isArray(result)) {
            for (const w of result) {
              allWithdrawals.push({
                ...w,
                queriedAsset: asset
              });
            }
            logTrace("Found " + result.length + " withdrawals for " + asset);
          }
        } catch (e) {
          logTrace("WithdrawStatus for " + asset + ": " + (e.message || "error"));
        }
      }

      cacheData.withdrawalHistory = allWithdrawals;
      logTrace("Total withdrawal history entries: " + allWithdrawals.length);
      return allWithdrawals;
    }

    // Get historical exchange rate from Kraken public API
    // Returns { gbpRate, eurRate } for the given asset at the given timestamp
    // Strategy: Fetch USD pair (more history) and convert via GBP/USD rate
    async function getKrakenRate(asset, timestamp) {
      // Map Kraken asset names to pair names
      const assetMap = {
        "XXRP": "XRP", "XRP": "XRP",
        "USDT": "USDT", "USDTTRC20": "USDT",
        "XXBT": "XBT", "XBT": "XBT",
        "XETH": "ETH", "ETH": "ETH",
        "ZUSD": "USD", "USD": "USD"
      };

      const baseAsset = assetMap[asset] || asset.replace(/^X|^Z/, "");
      const rates = { gbpRate: null, eurRate: null, usdRate: null };
      const proxy = getSelectedProxy();

      // Use 30 days before to ensure we get historical data
      const thirtyDaysBefore = timestamp - (30 * 24 * 60 * 60);

      // Helper to fetch rate from OHLC
      async function fetchOHLC(pair, since) {
        try {
          const url = proxy + "https://api.kraken.com/0/public/OHLC?pair=" + pair + "&interval=1440&since=" + Math.floor(since);
          const response = await fetch(url);
          const data = await response.json();

          if (data.result && Object.keys(data.result).length > 0) {
            const pairData = Object.values(data.result).find(v => Array.isArray(v));
            if (pairData && pairData.length > 0) {
              // Find the candle closest to our timestamp
              let bestCandle = null;
              let bestDiff = Infinity;

              for (const candle of pairData) {
                const diff = Math.abs(candle[0] - timestamp);
                if (diff < bestDiff) {
                  bestDiff = diff;
                  bestCandle = candle;
                }
              }

              // Accept if within 60 days
              if (bestCandle && bestDiff < 60 * 24 * 60 * 60) {
                return parseFloat(bestCandle[4]); // close price
              }
            }
          }
        } catch (e) {
          // Pair might not exist
        }
        return null;
      }

      // USDT is a USD stablecoin, so USDT/USD rate is always ~1.0
      if (baseAsset === "USDT") {
        rates.usdRate = 1.0;
        // Try direct GBP pair for USDT
        rates.gbpRate = await fetchOHLC("USDTGBP", thirtyDaysBefore);

        // If no direct GBP, try USD/GBP conversion
        if (rates.gbpRate === null) {
          // Try USDGBP (gives GBP per USD directly)
          const usdgbpRate = await fetchOHLC("USDGBP", thirtyDaysBefore);
          if (usdgbpRate !== null) {
            rates.gbpRate = usdgbpRate; // 1 USDT = 1 USD = x GBP
          } else {
            // Fallback: Try GBPUSD (gives USD per GBP, so invert)
            const gbpusdRate = await fetchOHLC("GBPUSD", thirtyDaysBefore);
            if (gbpusdRate !== null) {
              rates.gbpRate = 1.0 / gbpusdRate; // 1 USDT = 1 USD, convert to GBP
            }
          }
        }

      } else {
        // For other assets (XRP, etc.), try USD pair first
        rates.usdRate = await fetchOHLC(baseAsset + "USD", thirtyDaysBefore);

        // If we have USD rate, get GBP/USD to convert
        if (rates.usdRate !== null) {
          // Try USDGBP first (gives GBP per USD directly)
          const usdgbpRate = await fetchOHLC("USDGBP", thirtyDaysBefore);
          if (usdgbpRate !== null) {
            rates.gbpRate = rates.usdRate * usdgbpRate;
          } else {
            // Fallback: try GBPUSD (gives USD per GBP, so divide)
            const gbpusdRate = await fetchOHLC("GBPUSD", thirtyDaysBefore);
            if (gbpusdRate !== null) {
              rates.gbpRate = rates.usdRate / gbpusdRate;
            } else {
              // Final fallback: use external forex API for GBP/USD
              try {
                const dateStr = new Date(timestamp * 1000).toISOString().split("T")[0];
                const forexUrl = `https://api.frankfurter.app/${dateStr}?from=USD&to=GBP`;
                const resp = await fetch(forexUrl);
                if (resp.ok) {
                  const data = await resp.json();
                  if (data.rates && data.rates.GBP) {
                    rates.gbpRate = rates.usdRate * data.rates.GBP;
                    rates.rateSource = "Kraken + frankfurter";
                    logTrace(baseAsset + "/GBP via Kraken+frankfurter: " + rates.gbpRate);
                  }
                }
              } catch (e) {
                logTrace("Forex API fallback failed: " + e.message);
              }
            }

          }
        }

        // If still no GBP rate, try direct GBP pair
        if (rates.gbpRate === null) {
          rates.gbpRate = await fetchOHLC(baseAsset + "GBP", thirtyDaysBefore);
        }
      }



      // Try EUR pair for eurRate
      if (baseAsset !== "USDT") {
        rates.eurRate = await fetchOHLC(baseAsset + "EUR", thirtyDaysBefore);
      } else {
        rates.eurRate = await fetchOHLC("USDTEUR", thirtyDaysBefore);
      }

      // If still no GBP rate but we have EUR rate, convert via EUR/GBP
      if (rates.gbpRate === null && rates.eurRate !== null) {
        // Try GBPEUR pair (gives EUR per GBP, so we divide)
        let gbpeurRate = await fetchOHLC("GBPEUR", thirtyDaysBefore);
        if (gbpeurRate !== null) {
          rates.gbpRate = rates.eurRate / gbpeurRate;
        } else {
          // Fallback: try EURGBP (gives GBP per EUR, so we multiply)
          const eurgbpRate = await fetchOHLC("EURGBP", thirtyDaysBefore);
          if (eurgbpRate !== null) {
            rates.gbpRate = rates.eurRate * eurgbpRate;
          }
        }
      }

      // Final fallback: Use external forex API for GBP/USD rate if USDT still has no GBP rate
      if (rates.gbpRate === null && baseAsset === "USDT") {
        try {
          const dateStr = new Date(timestamp * 1000).toISOString().split("T")[0];
          const forexUrl = `https://api.frankfurter.app/${dateStr}?from=USD&to=GBP`;
          const resp = await fetch(forexUrl);
          if (resp.ok) {
            const data = await resp.json();
            if (data.rates && data.rates.GBP) {
              rates.gbpRate = data.rates.GBP;
              rates.rateSource = "frankfurter";
              logTrace("USDT/GBP via frankfurter: " + rates.gbpRate);
            }
          }
        } catch (e) {
          logTrace("Forex API fallback failed: " + e.message);
        }
      }

      // Final fallback for XRP: Use CryptoCompare for historical XRP/USD, then forex for USD/GBP
      if (rates.gbpRate === null && baseAsset === "XRP") {
        try {
          const dateStr = new Date(timestamp * 1000).toISOString().split("T")[0];
          logTrace("XRP fallback: trying CryptoCompare for " + dateStr);

          // Get XRP/USD from CryptoCompare (free API, no auth needed)
          const ccUrl = `https://min-api.cryptocompare.com/data/v2/histoday?fsym=XRP&tsym=USD&limit=1&toTs=${timestamp}`;
          const ccResp = await fetch(ccUrl);
          logTrace("CryptoCompare response status: " + ccResp.status);

          if (ccResp.ok) {
            const ccData = await ccResp.json();
            if (ccData.Response === "Success" && ccData.Data && ccData.Data.Data && ccData.Data.Data.length > 0) {
              // Use the close price from the first data point
              const xrpUsd = ccData.Data.Data[0].close;
              logTrace("CryptoCompare XRP/USD: " + xrpUsd);

              // Now get USD/GBP from forex API
              const forexUrl = `https://api.frankfurter.app/${dateStr}?from=USD&to=GBP`;
              const forexResp = await fetch(forexUrl);
              if (forexResp.ok) {
                const forexData = await forexResp.json();
                if (forexData.rates && forexData.rates.GBP) {
                  rates.gbpRate = xrpUsd * forexData.rates.GBP;
                  rates.rateSource = "CryptoCompare";
                  logTrace("XRP/GBP via CryptoCompare+Forex: " + rates.gbpRate);
                }
              }
            } else {
              logTrace("CryptoCompare returned no data for XRP: " + (ccData.Message || "No data"));
            }
          } else {
            const errText = await ccResp.text();
            logTrace("CryptoCompare error: " + ccResp.status + " - " + errText.substring(0, 100));
          }
        } catch (e) {
          logTrace("CryptoCompare/Forex API fallback for XRP failed: " + e.message);
        }
      }




      return rates;

    }

    // ========== MAIN FUNCTION: Fetch & Generate Report (v2.0) ==========
    async function fetchAndGenerateReport() {
      // Step 0: Validate date range
      const startDate = document.getElementById("startDate").value;
      const endDate = document.getElementById("endDate").value;

      window.handleDateChange = function (id) {
        const val = document.getElementById(id).value;
        if (val) {
          // Validation check if needed
          const s = document.getElementById("startDate").value;
          const e = document.getElementById("endDate").value;
          if (s && e && s > e) {
            alert("End Date cannot be before Start Date");
            document.getElementById(id).value = "";
            return;
          }
          updateStatus("Date Changed. Click 'Read Ledger' to refresh.", "active");
        }
      };

      if (!startDate || !endDate) {
        alert("Please select Start Date and End Date first.");
        return;
      }

      const startTime = new Date(startDate).getTime() / 1000;
      const endTime = new Date(endDate + "T23:59:59").getTime() / 1000;

      logTrace("Date range: " + startDate + " to " + endDate);
      logTrace("Unix range: " + startTime + " to " + endTime);

      // Step 1: Prompt for 2FA
      const otp = prompt("Enter your Kraken 2FA code:");
      if (!otp || otp.trim() === "") {
        logTrace("2FA cancelled by user");
        return;
      }

      try {
        const creds = getApiCredentials();
        updateStatus("Fetching...", "sync");

        // Step 2: Call Kraken Ledgers API for withdrawals
        logTrace("Calling Kraken Ledgers API...");
        const ledgerResult = await callKrakenPrivateAPI("Ledgers", {
          type: "withdrawal",
          start: Math.floor(startTime),
          end: Math.floor(endTime),
          otp: otp.trim()
        }, creds);

        // ledgerResult is { ledger_id: { refid, time, type, subtype, aclass, asset, amount, fee, balance } }
        const allWithdrawals = [];
        for (const [ledgerId, entry] of Object.entries(ledgerResult.ledger || ledgerResult || {})) {
          const asset = (entry.asset || "").toUpperCase();
          // Filter to USDT and XRP only
          if (asset.includes("USDT") || asset.includes("XRP") || asset === "XXRP") {
            allWithdrawals.push({
              ledgerId,
              refid: entry.refid,
              time: entry.time,
              asset: asset,
              amount: parseFloat(entry.amount || 0),
              fee: parseFloat(entry.fee || 0),
              balance: parseFloat(entry.balance || 0)
            });
          }
        }

        cacheData.withdrawals = allWithdrawals;
        logTrace("Fetched " + allWithdrawals.length + " USDT/XRP withdrawals from Ledgers API");

        // Step 3: Call WithdrawStatus for destination details
        logTrace("Fetching withdrawal details...");
        await fetchWithdrawalHistory(otp.trim());

        // Step 4: Call WithdrawAddresses for recipient names
        logTrace("Fetching saved addresses...");
        const addresses = await callKrakenPrivateAPI("WithdrawAddresses", { otp: otp.trim() }, creds);
        cacheData.krakenAddresses = addresses || [];
        logTrace("Fetched " + cacheData.krakenAddresses.length + " saved addresses");

        updateStatusCounts();

        // Step 5: Generate report from fetched data
        await generateReportFromCache();

        updateStatus("Ready", "active");

      } catch (e) {
        updateStatus("Error", "error");
        logTrace("Error: " + (e.message || e));
        alert("Error: " + (e.message || e));
      }
    }

    // Generate report from cached data (no API calls except for rates)
    async function generateReportFromCache() {
      if (cacheData.withdrawals.length === 0) {
        alert("No withdrawal data. Please Fetch first.");
        return;
      }

      updateStatus("Generating...", "sync");
      logTrace("Generating report from " + cacheData.withdrawals.length + " entries...");

      stagingRecords = [];
      document.getElementById("previewArea").innerHTML = ""; // v3.017: Clear previous report
      document.getElementById("bankReportArea").innerHTML = "";

      // Sort ALL ledger entries by time (ascending) for trade matching
      const sortedLedger = [...cacheData.withdrawals].sort((a, b) => a.time - b.time);

      // v4.00-03 Objective D: bank label lookup by fiat asset (GBP/EUR) from Kraken address book
      const bankLabelByAsset = {};
      if (cacheData.krakenAddresses && cacheData.krakenAddresses.length) {
        for (const a of cacheData.krakenAddresses) {
          if (!a || !a.asset) continue;
          if (a.asset !== "GBP" && a.asset !== "EUR") continue;
          if (bankLabelByAsset[a.asset]) continue;
          const _lbl = ((a.key || a.info || "").trim());
          if (_lbl) bankLabelByAsset[a.asset] = _lbl + " (" + a.asset + ")";
        }
      }


      // Helper: Find immediately preceding trade that matches a withdrawal
      function findMatchingTrade(withdrawalIndex, withdrawal) {
        // Look for a trade immediately before this withdrawal (same asset, amount matches withdrawal + fee)
        const targetAmount = Math.abs(withdrawal.amount) + Math.abs(withdrawal.fee);

        for (let i = withdrawalIndex - 1; i >= 0 && i >= withdrawalIndex - 5; i--) {
          const prev = sortedLedger[i];
          if (prev.type !== "trade") continue;

          // Check if same asset and amount matches
          const prevAsset = (prev.asset || "").toUpperCase();
          const withdrawalAsset = (withdrawal.asset || "").toUpperCase();
          if (!prevAsset.includes("XRP") && !prevAsset.includes("USDT")) continue;
          if (!withdrawalAsset.includes(prevAsset.replace("X", "")) &&
            !prevAsset.includes(withdrawalAsset.replace("X", ""))) continue;

          // Check if trade amount ‚âà withdrawal amount + fee (within 0.01% tolerance)
          const tradeAmount = Math.abs(prev.amount);
          const tolerance = targetAmount * 0.0001;
          if (Math.abs(tradeAmount - targetAmount) <= tolerance) {
            // Found matching crypto trade! Now find the GBP/EUR counterpart
            return { cryptoTrade: prev, index: i };
          }
        }
        return null;
      }

      // Helper: Find GBP/EUR trade counterpart (should be very close in time to the crypto trade)
      function findFiatCounterpart(tradeIndex, cryptoTrade) {
        // Look within a few entries around the crypto trade for a GBP or EUR trade
        for (let i = Math.max(0, tradeIndex - 3); i <= Math.min(sortedLedger.length - 1, tradeIndex + 3); i++) {
          if (i === tradeIndex) continue;
          const entry = sortedLedger[i];
          if (entry.type !== "trade") continue;

          const asset = (entry.asset || "").toUpperCase();
          // Look for GBP or EUR (Kraken uses ZGBP, ZEUR, or just GBP, EUR)
          if (asset.includes("GBP") || asset.includes("EUR") || asset === "ZGBP" || asset === "ZEUR") {
            // Found fiat trade! Should be very close in time (within a few seconds)
            const timeDiff = Math.abs(entry.time - cryptoTrade.time);
            if (timeDiff <= 60) { // Within 60 seconds
              return entry;
            }
          }
        }
        return null;
      }

      // Step 1: Collect unique dates for batch rate lookup
      const uniqueDates = new Set();
      for (const w of cacheData.withdrawals) {
        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        uniqueDates.add(dateStr);
      }
      logTrace("Unique dates: " + Array.from(uniqueDates).join(", "));

      // Step 2: Batch fetch rates for each unique date
      const ratesToFetch = [];
      const cachedDates = [];
      for (const dateStr of uniqueDates) {
        const timestamp = new Date(dateStr).getTime() / 1000 + 43200; // noon
        const cached = cacheData.ratesCache[dateStr];
        if (!cached) {
          ratesToFetch.push({ dateStr, timestamp });
        } else if (cached.USDTGBP === null || cached.XRPGBP === null) {
          // Retry dates where GBP rate is null (API might return data on retry)
          ratesToFetch.push({ dateStr, timestamp });
          logTrace("Retrying rate for " + dateStr + " (had null GBP)");
        } else {
          cachedDates.push(dateStr);
        }
      }
      if (cachedDates.length > 0) {
        logTrace("Using cached rates for " + cachedDates.length + " dates: " + cachedDates.join(", "));
      }

      if (ratesToFetch.length > 0) {
        logTrace("Fetching rates for " + ratesToFetch.length + " dates...");
        let fetchCount = 0;
        updateStatus("Fetching rates... " + fetchCount + "/" + ratesToFetch.length, "sync");
        for (const { dateStr, timestamp } of ratesToFetch) {
          fetchCount++;
          updateStatus("Fetching rates... " + fetchCount + "/" + ratesToFetch.length, "sync");

          // Fetch all 4 pairs for this date
          const usdtRates = await getKrakenRate("USDT", timestamp);
          const xrpRates = await getKrakenRate("XRP", timestamp);

          // Direct EUR/GBP day-rate for fiat GBP-equivalents (avoids USDT cross-rate ambiguity)
          let eurGbpRate = null;
          try {
            const fxUrl = `https://api.frankfurter.app/${dateStr}?from=EUR&to=GBP`;
            const fxResp = await fetch(fxUrl);
            if (fxResp && fxResp.ok) {
              const fxData = await fxResp.json();
              if (fxData && fxData.rates && typeof fxData.rates.GBP === "number") {
                eurGbpRate = fxData.rates.GBP;
              }
            }
          } catch (e) {
            // Keep eurGbpRate as null; do not block report generation
          }

          cacheData.ratesCache[dateStr] = {
            USDTGBP: usdtRates.gbpRate,
            USDTEUR: usdtRates.eurRate,
            EURGBP: eurGbpRate,
            USDTSource: usdtRates.rateSource || "Kraken day rate",
            EURGBPSource: eurGbpRate !== null ? "frankfurter" : null,
            XRPGBP: xrpRates.gbpRate,
            XRPEUR: xrpRates.eurRate,
            XRPSource: xrpRates.rateSource || "Kraken day rate"
          };



          logTrace("Rates for " + dateStr + ": USDTGBP=" + usdtRates.gbpRate + ", XRPGBP=" + xrpRates.gbpRate + (eurGbpRate !== null ? ", EURGBP=" + eurGbpRate : ""));

          // Small delay to avoid API rate limiting
          await new Promise(r => setTimeout(r, 200));
        }
      }


      // Step 3: Build records (only for withdrawals, but use sortedLedger for trade matching)
      // Iterate REVERSE (end to start) so report is Newest -> Oldest
      for (let idx = sortedLedger.length - 1; idx >= 0; idx--) {
        const w = sortedLedger[idx];

        // Only process withdrawals, deposits, and trades
        // v3.030: Include deposits as requested
        if (w.type !== "withdrawal" && w.type !== "trade" && w.type !== "deposit") continue;

        const dateStr = new Date(w.time * 1000).toISOString().split("T")[0];
        const rates = cacheData.ratesCache[dateStr] || {};

        // Find matching withdrawal in history (for address/tag)
        const historyMatch = cacheData.withdrawalHistory.find(h => h.refid === w.refid);

        // Get address from history
        let walletAddr = historyMatch ? (historyMatch.info || historyMatch.address || "") : "";
        let destTag = historyMatch ? (historyMatch.dest || historyMatch.tag || "") : "";

        // Find recipient from krakenAddresses
        let fullRecipient = "";

        // Helper to normalize string for matching (remove spaces, symbols, lowercase)
        const normalize = (s) => (s || "").toLowerCase().replace(/[^a-z0-9]/g, "");

        const walletAddrNorm = normalize(walletAddr);

        const addrMatch = cacheData.krakenAddresses.find(a => {
          // Strict match on address field
          if (a.address === walletAddr) {
            return (destTag ? (a.tag === destTag) : (!a.tag));
          }
          // v2.48: Fuzzy/Normalized match for Fiat IBANs
          // Check if normalised address in book matches normalised wallet address
          // OR if the 'info' field (sometimes matches)
          if (walletAddrNorm.length > 5 && (normalize(a.address) === walletAddrNorm || normalize(a.info) === walletAddrNorm)) {
            return true;
          }
          return false;
        });

        if (addrMatch) {
          // Use the Key Name from address book
          fullRecipient = ((addrMatch.key || addrMatch.info || "").trim()) + ((addrMatch.asset === 'GBP' || addrMatch.asset === 'EUR') ? ' (' + addrMatch.asset + ')' : '');
        } else {
          // Fallback 1: Loose match on address only (for crypto non-tag assets)
          // Fallback 1: Loose match on address only (for crypto non-tag assets)
          const looseMatch = cacheData.krakenAddresses.find(a => a.address === walletAddr);
          if (looseMatch) {
            // If we found a match by address, use it.
            // (We relax strict tag matching here because sometimes tags appear in "info" or are optional)
            fullRecipient = (looseMatch.key || "").trim();
          } else {
            // Fallback 2: Use the 'info' field from withdrawal history directly if no book match
            if (historyMatch && historyMatch.info) {
              fullRecipient = historyMatch.info;
            }
          }
        }

        // v2.48 Fallback 2: If still empty and it's a Fiat withdrawal, use the bank name from history
        if (!fullRecipient && (w.type === "withdrawal")) {
          const isFiat = w.asset.includes("GBP") || w.asset.includes("EUR") || w.asset.includes("USD") || w.asset.includes("ZGBP") || w.asset.includes("ZEUR") || w.asset.includes("ZUSD");
          if (isFiat && walletAddr) {
            fullRecipient = walletAddr; // e.g. "Revolut Ltd"
          }
        }

        // Split recipient: first 2 words = name, rest = sent to destination
        // v2.48: Ensure we handle cases with < 2 words gracefully
        const words = (fullRecipient || "").split(/\s+/);
        let recipientName = "";
        let sentTo = "";

        if (words.length > 0 && words[0] !== "") {
          if (words.length === 1) {
            recipientName = words[0];
          } else {
            recipientName = words[0] + " " + words[1];
            sentTo = words.slice(2).join(" ").trim();
          }
        }


        // Calculate GBP equivalent - TRY TRADE MATCHING FIRST
        let gbpSent = "";
        let gbpFee = "";
        let conversionRate = "";
        let conversionCurrency = "";
        let rateSource = "";
        const absAmount = Math.abs(w.amount);
        const absFee = Math.abs(w.fee);
        const netAmount = absAmount - absFee;  // Amount after fee deduction

        // STEP A: Try to match this withdrawal to its immediately preceding trade
        const tradeMatch = findMatchingTrade(idx, w);
        if (tradeMatch) {
          const fiatTrade = findFiatCounterpart(tradeMatch.index, tradeMatch.cryptoTrade);
          if (fiatTrade) {
            // Calculate rate from matched trade pair
            const cryptoAmount = Math.abs(tradeMatch.cryptoTrade.amount);
            const fiatAmount = Math.abs(fiatTrade.amount);
            const matchedRate = fiatAmount / cryptoAmount;
            const fiatAsset = (fiatTrade.asset || "").toUpperCase();

            conversionCurrency = fiatAsset.includes("GBP") || fiatAsset === "ZGBP" ? "GBP" :
              fiatAsset.includes("EUR") || fiatAsset === "ZEUR" ? "EUR" : fiatAsset;
            conversionRate = matchedRate.toFixed(6);

            let calculatedVal = netAmount * matchedRate;
            let calculatedFee = absFee * matchedRate;

            // v3.045-18.2 Fix: If matched trade is EUR, calculate GBP equivalent using daily EURGBP rate
            if (conversionCurrency === "EUR") {
              // We need the daily EUR/GBP rate. 'rates' object passed to this loop context?
              // generateReportFromCache iterates entries and fetches rates first.
              // 'rates' variable is available in this scope (it is the daily rate object).
              if (rates && rates.EURGBP) {
                calculatedVal = calculatedVal * rates.EURGBP;
                calculatedFee = calculatedFee * rates.EURGBP;
                // Update rate source info to reflect this double conversion
                rateSource = "Exact rate (EUR-Trade) + EURGBP";
              } else {
                // Fallback if no EURGBP rate (shouldn't happen as we fetch it)
                rateSource = "Exact rate (EUR-Trade) [No GBP conv]";
              }
            } else {
              rateSource = "Exact rate";
            }

            gbpSent = calculatedVal.toFixed(2);
            gbpFee = calculatedFee.toFixed(2);

            logTrace("Trade match for " + w.refid + ": " + cryptoAmount.toFixed(2) + " " + w.asset +
              " = " + fiatAmount.toFixed(2) + " " + conversionCurrency +
              " (rate: " + conversionRate + ")" + (conversionCurrency === "EUR" ? " -> Converted to GBP: " + gbpSent : ""));
          }
        }

        // STEP B: Fall back to external rates if no trade match
        if (!rateSource) {
          // v3.045-18.6: If this is a TRADE row, try to find its counterpart to get exact value!
          // Previously we only did this for Withdrawals.
          if (w.type === 'trade') {
            // Reuse the findFiatCounterpart logic, but we might be the crypto side OR the fiat side.
            // Usually we care about the CRYPTO side being valued in GBP.
            // If this row is USDT/XRP, we want to know what we got/paid in Fiat.

            // WE ARE ITERATING `sortedLedger` via `idx`.
            // If this row is USDT, finding counterpart means finding the other leg (EUR/GBP).
            const fiatTrade = findFiatCounterpart(idx, w);
            if (fiatTrade) {
              const cryptoAmount = Math.abs(w.amount);
              const fiatAmount = Math.abs(fiatTrade.amount);
              const matchedRate = fiatAmount / cryptoAmount; // implied rate
              const fiatAsset = (fiatTrade.asset || "").toUpperCase();

              conversionCurrency = fiatAsset.includes("GBP") || fiatAsset === "ZGBP" ? "GBP" :
                fiatAsset.includes("EUR") || fiatAsset === "ZEUR" ? "EUR" : fiatAsset;

              conversionRate = matchedRate.toFixed(6);

              let calculatedVal = Math.abs(w.amount) * matchedRate; // Net amount? Trades usually have fee separate or embedded. 
              // Ledger "amount" is net of fee usually? No, fee is separate column.
              // But for Trade Valuation: Value of the Trade = Fiat Amount Involved.
              // So simple: Valuation = Fiat Amount.
              // Wait, if I bought 100 USDT for 85 EUR. Value is 85 EUR.
              calculatedVal = fiatAmount;

              let calculatedFee = Math.abs(w.fee) * matchedRate;
              // Fee is in USDT probably. So value of fee is fee * rate.

              if (conversionCurrency === "EUR") {
                if (rates && rates.EURGBP) {
                  calculatedVal = calculatedVal * rates.EURGBP;
                  calculatedFee = calculatedFee * rates.EURGBP;
                  rateSource = "Exact rate (EUR-Trade) + EURGBP";
                } else {
                  rateSource = "Exact rate (EUR-Trade) [No GBP conv]";
                }
              } else {
                rateSource = "Exact rate";
              }

              gbpSent = calculatedVal.toFixed(2);
              gbpFee = calculatedFee.toFixed(2);

              logTrace("Trade Valuation for " + w.refid + ": " + cryptoAmount.toFixed(2) + " " + w.asset +
                " = " + fiatAmount.toFixed(2) + " " + conversionCurrency +
                " (rate: " + conversionRate + ") -> GBP: " + gbpSent);
            }
          }
        }

        // Fallback to Daily Rate if still no source
        if (!rateSource) {
          if (w.asset.includes("USDT")) {
            if (rates.USDTGBP) {
              gbpSent = (netAmount * rates.USDTGBP).toFixed(2);
              gbpFee = (absFee * rates.USDTGBP).toFixed(2);
              conversionRate = rates.USDTGBP.toFixed(6);
              conversionCurrency = "GBP";
            } else if (rates.USDTEUR) {
              gbpSent = (netAmount * rates.USDTEUR).toFixed(2);
              gbpFee = (absFee * rates.USDTEUR).toFixed(2);
              conversionRate = rates.USDTEUR.toFixed(6);
              conversionCurrency = "EUR";
            }
            // v3.014: "Kraken" -> "Kraken day rate" via User Request
            rateSource = rates.USDTSource || "Kraken day rate";
          } else if (w.asset.includes("XRP") || w.asset === "XXRP") {
            if (rates.XRPGBP) {
              gbpSent = (netAmount * rates.XRPGBP).toFixed(2);
              gbpFee = (absFee * rates.XRPGBP).toFixed(2);
              conversionRate = rates.XRPGBP.toFixed(6);
              conversionCurrency = "GBP";
            } else if (rates.XRPEUR) {
              gbpSent = (netAmount * rates.XRPEUR).toFixed(2);
              gbpFee = (absFee * rates.XRPEUR).toFixed(2);
              conversionRate = rates.XRPEUR.toFixed(6);
              conversionCurrency = "EUR";
            }
            rateSource = rates.XRPSource || "Kraken day rate";
          }
        }

        // Normalize asset name (XXRP -> XRP, USDT stays USDT)
        const normalizedAsset = w.asset.includes("XRP") || w.asset === "XXRP" ? "XRP" :
          w.asset.includes("USDT") ? "USDT" : w.asset;


        const record = {
          dateSent: formatTimestamp(w.time),
          timeSent: formatTime(w.time),
          refid: w.refid, // v2.90: needed for linking
          type: w.type || "withdrawal",  // Type from ledger entry
          entryDate: "",
          recipient: recipientName,
          sentTo: sentTo,
          asset: normalizedAsset,
          amount: Math.abs(w.amount).toFixed(6),
          fee: Math.abs(w.fee).toFixed(6),
          balance: w.balance.toFixed(6),
          conversionCurrency: conversionCurrency,
          conversionRate: conversionRate,
          gbpSent: gbpSent,
          gbpFee: gbpFee,
          destTag: destTag,
          wallet: walletAddr,
          txId: w.refid,
          rateSource: rateSource,
          gbpSent: gbpSent || "0.00" // Ensure it exists
        };





        stagingRecords.push(record);

        // v2.97: Fix - Ensure withdrawalCache is populated with THESE calculated records
        // before we try to use them for Summary generation!
        // We accumulate them here.
      }
      // Populate global cache for Summary reuse
      cacheData.withdrawalCache = [...stagingRecords];

      localStorage.setItem("kraken_staging", JSON.stringify(stagingRecords));
      renderPreview();
      updateStatus("Ready", "active");
      logTrace("Report generated: " + stagingRecords.length + " records");
    }

    // Format unix timestamp to DD Mon YYYY
    function formatTimestamp(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const d = String(dt.getUTCDate()).padStart(2, "0");
      const m = months[dt.getUTCMonth()];
      const y = dt.getUTCFullYear();
      return d + " " + m + " " + y;
    }


    // Format unix timestamp to HH:MM:SS (UTC)
    function formatTime(unixTime) {
      if (!unixTime) return "";
      const dt = new Date(unixTime * 1000);
      const h = String(dt.getUTCHours()).padStart(2, "0");
      const m = String(dt.getUTCMinutes()).padStart(2, "0");
      const s = String(dt.getUTCSeconds()).padStart(2, "0");
      return h + ":" + m + ":" + s;
    }

    // ===========================================
    // KRAKEN BANK STATEMENT REPORT (New v2.49)
    // ===========================================
    let bankRecords = [];
    const TRACKED_ASSETS = ["GBP", "EUR", "USDT", "XRP"];

    async function generateBankReport() {
      const btn = document.getElementById("btn_bank_statement");
      const sDateVal = document.getElementById("startDate").value;
      const eDateVal = document.getElementById("endDate").value;

      if (!sDateVal || !eDateVal) { alert("Please select a date range."); return; }

      // Parse dates (start of day / end of day)
      const startTs = new Date(sDateVal).getTime() / 1000;
      const endTs = new Date(eDateVal).getTime() / 1000 + 86399;

      if (cacheData.withdrawals.length === 0) {
        alert("No ledger data loaded. Please 'Read Ledger' first.");
        return;
      }

      btn.innerText = "Generating...";

      // 1. Filter and Sort Data
      // Use allLedgerEntries (cached in withdrawals)
      const entries = cacheData.withdrawals
        .filter(e => e.time >= startTs && e.time <= endTs)
        .sort((a, b) => a.time - b.time); // Oldest first

      if (entries.length === 0) {
        alert("No transactions found in this date range.");
        btn.innerText = `Kraken Statement ${formatTimestamp(startTs)} to ${formatTimestamp(endTs)}`;
        return;
      }

      // 2. Calculate Opening Balances (Back-Calculation)
      // We need a starting balance for each tracked asset.
      // Strategy: Find the FIRST occurrence of each asset in the filtered list.
      // Opening = FirstEntry.balance - FirstEntry.amount (reverse the transaction)
      let runningBal = {};

      // Initialize with null to detect missing history
      TRACKED_ASSETS.forEach(a => runningBal[a] = null);

      // Scan for first occurrences to set opening balances
      for (const asset of TRACKED_ASSETS) {
        // Find first entry involving this asset
        const first = entries.find(e => {
          const a = (e.asset || "").toUpperCase();
          return a.includes(asset) || (asset === "XRP" && a === "XXRP") || (asset === "GBP" && a === "ZGBP") || (asset === "EUR" && a === "ZEUR");
        });

        if (first) {
          // Found a transaction. Opening balance is Balance BEFORE this transaction.
          // Note: amount is positive for deposits, negative for withdrawals/trades-out.
          // Balance = Prev + Amount  =>  Prev = Balance - Amount
          runningBal[asset] = first.balance - first.amount;
        } else {
          runningBal[asset] = 0; // Asset not seen in period, assume 0
        }
      }

      const openingBalRow = {
        date: formatTimestamp(startTs),
        time: "00:00:00",
        type: "Balance",
        details: "Opening Balance",
        balances: { ...runningBal }, // Snapshot
        amounts: {},
        fees: {}
      };

      // 3. Process Transactions (Merge Trades & Update Balances)
      bankRecords = [];
      bankRecords.push(openingBalRow);

      let i = 0;
      while (i < entries.length) {
        const e = entries[i];
        const next = (i + 1 < entries.length) ? entries[i + 1] : null;

        // Check for Mergeable Trade
        // Same refid, same time, both are trades
        let isTradeMerge = false;

        if (e.type === 'trade' && next && next.type === 'trade' && e.refid === next.refid) {
          isTradeMerge = true;
        }

        const row = {
          date: formatTimestamp(e.time),
          time: formatTime(e.time),
          type: isTradeMerge ? "trade" : (e.type || "transaction"),
          details: "",
          balances: {},
          amounts: {},
          fees: {},
          // V2.84: Store metadata for Summary generation
          refid: e.refid,
          _raw: e
        };

        // Helper to process one entry into the row
        const processEntry = (entry) => {
          let asset = (entry.asset || "").toUpperCase();
          // Normalize
          if (asset.includes("XRP") || asset === "XXRP") asset = "XRP";
          else if (asset.includes("USDT")) asset = "USDT";
          else if (asset.includes("GBP") || asset === "ZGBP") asset = "GBP";
          else if (asset.includes("EUR") || asset === "ZEUR") asset = "EUR";
          else return; // Ignore non-tracked assets if any

          // Update Running Balance from Authoritative Ledger Data
          runningBal[asset] = entry.balance;

          // Fill Row Data
          row.amounts[asset] = entry.amount;
          // Fix: Accumulate fees, don't overwrite (in case both legs pay in same asset)
          row.fees[asset] = (row.fees[asset] || 0) + Math.abs(entry.fee);
        };

        if (isTradeMerge) {
          // Process Both
          processEntry(e);
          processEntry(next);

          // Determine Description e.g. "Buy USDT / Sell GBP"
          const bought = (e.amount > 0 ? e : next);
          const sold = (e.amount < 0 ? e : next);

          // Fix v2.77: Safer asset normalization (don't blindly strip X)
          const norm = (a) => {
            a = (a || "").toUpperCase();
            if (a.includes("XRP") || a === "XXRP") return "XRP";
            if (a.includes("USDT")) return "USDT";
            if (a.includes("GBP") || a === "ZGBP") return "GBP";
            if (a.includes("EUR") || a === "ZEUR") return "EUR";
            if (a.includes("USD") || a === "ZUSD") return "USD";
            return a;
          };

          let bAsset = norm(bought.asset);
          let sAsset = norm(sold.asset);

          // v3.045-19.10 Improve Trade Valuation for Reconciliation
          // If one leg is GBP, store that GBP magnitude as the explicit value for the other leg.
          // This overrides the "Daily Rate" estimation which causes large variance.
          if (!row.gbpValues) row.gbpValues = {};

          if (bAsset === "GBP" && sAsset !== "GBP") {
            // We bought GBP, Sold Crypto/Fiat. 
            // Value of Sold Asset = Amount of GBP Bought.
            row.gbpValues[sAsset] = Math.abs(bought.amount);
          } else if (sAsset === "GBP" && bAsset !== "GBP") {
            // We sold GBP, Bought Crypto/Fiat.
            // Value of Bought Asset = Amount of GBP Sold.
            row.gbpValues[bAsset] = Math.abs(sold.amount);
          } else if (bAsset === "EUR" && sAsset !== "EUR") {
            // Bought EUR, Sold Crypto. Value of Sold Crypto = EUR Val * Daily EURGBP.
            const dObj = new Date(e.time * 1000);
            const dStr = dObj.toISOString().split("T")[0];
            const dayRates = (cacheData && cacheData.ratesCache) ? cacheData.ratesCache[dStr] : null;
            const rate = (dayRates && dayRates.EURGBP) ? dayRates.EURGBP : 0;
            if (rate > 0) {
              row.gbpValues[sAsset] = Math.abs(bought.amount) * rate;
            }
          } else if (sAsset === "EUR" && bAsset !== "EUR") {
            // Sold EUR, Bought Crypto. Value of Bought Crypto = EUR Val * Daily EURGBP.
            const dObj = new Date(e.time * 1000);
            const dStr = dObj.toISOString().split("T")[0];
            const dayRates = (cacheData && cacheData.ratesCache) ? cacheData.ratesCache[dStr] : null;
            const rate = (dayRates && dayRates.EURGBP) ? dayRates.EURGBP : 0;
            if (rate > 0) {
              row.gbpValues[bAsset] = Math.abs(sold.amount) * rate;
            }
          } else {
            // v3.045-19.44: Crypto-to-Crypto Anchor (USDT / XRP)
            // If trading USDT <-> XRP, use USDT as the Anchor for valuation to ensure Net Trade = 0.
            // Otherwise variance occurs due to mismatched daily rates.
            let anchorAsset = null;
            let anchorAmount = 0;
            let targetAsset = null;

            if (bAsset === "USDT") { anchorAsset = "USDT"; anchorAmount = Math.abs(bought.amount); targetAsset = sAsset; }
            else if (sAsset === "USDT") { anchorAsset = "USDT"; anchorAmount = Math.abs(sold.amount); targetAsset = bAsset; }
            else if (bAsset === "XRP") { anchorAsset = "XRP"; anchorAmount = Math.abs(bought.amount); targetAsset = sAsset; } // Weak anchor but better than nothing
            else if (sAsset === "XRP") { anchorAsset = "XRP"; anchorAmount = Math.abs(sold.amount); targetAsset = bAsset; }

            if (anchorAsset && targetAsset) {
              const dObj = new Date(e.time * 1000);
              const dStr = dObj.toISOString().split("T")[0];
              const dayRates = (cacheData && cacheData.ratesCache) ? cacheData.ratesCache[dStr] : null;

              let rate = 0;
              if (anchorAsset === "USDT") rate = (dayRates ? dayRates.USDTGBP : 0);
              else if (anchorAsset === "XRP") rate = (dayRates ? dayRates.XRPGBP : 0);

              if (rate > 0) {
                const tradeGbp = anchorAmount * rate;
                // Set BOTH to the same GBP magnitude
                row.gbpValues[anchorAsset] = tradeGbp;
                row.gbpValues[targetAsset] = tradeGbp;

                // Also update Last Trade Rate for the Target (Cost Basis update)
                // e.g. Sold USDT (Anchor), Bought XRP (Target). 
                // Cost of XRP = tradeGbp.
                // Amount of XRP = bought.amount.
                if (bAsset === targetAsset && Math.abs(bought.amount) > 0) {
                  lastTradeRates[targetAsset] = tradeGbp / Math.abs(bought.amount);
                }
              }
            }
          }

          row.details = `Buy ${bAsset} / Sell ${sAsset}`;
          i += 2; // Skip next
        } else {
          // Single Entry (Deposit, Withdrawal, or Unmatched Trade)
          processEntry(e);

          let detail = ""; // Initialize default

          if (e.type === 'withdrawal' || e.type === 'deposit') {
            // Try to get recipient name from address book logic
            const normalizedAsset = (e.asset.includes("XRP") || e.asset === "XXRP") ? "XRP" : (e.asset.includes("USDT") ? "USDT" : e.asset);

            // v2.95 Legacy Cache Lookup REMOVED in v3.045-19.43 to strictly follow Phase II First Principles.
            // We now rely solely on Persistent Cost Basis (Option B) or Daily Rates.
            let foundGbp = 0;

            // v3.045-19.12 Fix: "Lookback" Logic for Withdrawals
            // If we just bought this crypto (Trade), use the explicit GBP value from that Trade
            // instead of failing to find a rate.
            // v3.045-19.14b Robust Lookback: Always try to link to a preceding Trade first
            // This overrides any cached values which might be based on inaccurate daily rates.
            // We search backwards for the last TRADE of this asset.
            if (Math.abs(e.amount) > 0) {
              // This handles cases where a FEE or other small transaction sits between the Trade and the Withdrawal.
              if (bankRecords.length > 0) {
                // Search backwards up to 5 records or until time gap is too large
                for (let k = bankRecords.length - 1; k >= 0; k--) {
                  const prevRow = bankRecords[k];
                  const timeDiff = (e.time - (prevRow._raw ? prevRow._raw.time : 0));

                  // Stop if we go back too far in time (> 90 mins)
                  if (timeDiff > 5400) break;
                  // Stop if we go back too many rows (e.g. 10) to avoid performance hit
                  if ((bankRecords.length - k) > 10) break;

                  if (prevRow.type === "trade") {
                    const prevAmt = prevRow.amounts[normalizedAsset];
                    // Check if this trade involved BUYING the asset we are withdrawing
                    if (prevAmt > 0) { // Positive amount = Bought/Received
                      // Check if this trade has a known GBP value
                      if (prevRow.gbpValues && prevRow.gbpValues[normalizedAsset]) {
                        const tradeGbpVal = prevRow.gbpValues[normalizedAsset];
                        const impliedRate = tradeGbpVal / prevAmt;
                        const currAmt = Math.abs(e.amount);

                        foundGbp = currAmt * impliedRate;

                        console.log(`[Recon Trace] Withdrawal ${normalizedAsset} (${currAmt}) linked to Trade @ ${prevRow.time}`);
                        console.log(` -> Trade: Bought ${prevAmt} for ¬£${tradeGbpVal.toFixed(2)} (Rate: ${impliedRate.toFixed(4)})`);
                        console.log(` -> Valuation: ${currAmt} * ${impliedRate.toFixed(4)} = ¬£${foundGbp.toFixed(2)}`);

                        break; // Stop searching once found
                      }
                    }
                  }
                }
              }
            }

            // Fallback: Calculate from Rates if still missing
            if (!foundGbp && Math.abs(e.amount) > 0) {
              const dObj = new Date(e.time * 1000);
              const dStr = dObj.toISOString().split('T')[0];
              const dayRates = cacheData.ratesCache[dStr];
              if (dayRates) {
                let rate = 0;
                if (normalizedAsset === "USDT") rate = dayRates.USDTGBP || 0;
                else if (normalizedAsset === "XRP") rate = dayRates.XRPGBP || 0;
                else if (normalizedAsset === "EUR") rate = dayRates.EURGBP || 0;
                if (rate > 0) foundGbp = (Math.abs(e.amount) * rate).toFixed(2);
              }
            }

            // Store queryable GBP in row
            if (!row.gbpValues) row.gbpValues = {};
            if (foundGbp) row.gbpValues[normalizedAsset] = parseFloat(foundGbp);

            // Default Detail
            detail = (e.type === 'withdrawal') ? `Withdrawal` : `Deposit`;

            // Enriched Logic: First 2 words of recipient
            let recipient = null;

            
              // v4.00-03 Objective D: ensure fiat deposits have bank recipient label for propagation
              if (w.type === "deposit" && (!recipient || recipient === "Unknown")) {
                const _fa = (asset || "").replace(/^Z/, "");
                if ((_fa === "GBP" || _fa === "EUR") && bankLabelByAsset && bankLabelByAsset[_fa]) {
                  recipient = bankLabelByAsset[_fa];
                }
              }
// 1. History Lookup
            const historyMatch = cacheData.withdrawalHistory.find(h => h.refid === e.refid);
            if (historyMatch) {
              const addr = historyMatch.info || historyMatch.address;
              const addrMatch = cacheData.krakenAddresses.find(a => a.address === addr);
              if (addrMatch) recipient = addrMatch.key + ((addrMatch.asset === 'GBP' || addrMatch.asset === 'EUR') ? ' (' + addrMatch.asset + ')' : '');
              else if (addr) recipient = addr;
            }

            if (recipient) {
              // Take first 2 words
              const _m = recipient.match(/\s*\((GBP|EUR)\)\s*$/);
              const _suf = _m ? " (" + _m[1] + ")" : "";
              const _base = recipient.replace(/\s*\((GBP|EUR)\)\s*$/, "");
              const words = _base.split(/\s+/).slice(0, 2).join(" ") + _suf;
              // Clean common suffixes if needed, or just trust words
              detail = `${words}`;

              // v3.028: Fix "Withdrawal (EUR)" showing instead of name
              // Use the detected name as the primary detail
              row.details = detail;

            } else if (e.info && e.info !== "Withdrawal" && e.info !== "Deposit") {
              // v3.017: Fallback to ledger info if no address match (e.g. "Revolut Ltd")
              detail = e.info;
            }

            // Fix: Override for Revolut GBP
            // v3.030: User requested NO hardcoding of bank names.
            // Keeping dynamic logic only.
            // if (detail === "Revolut Ltd") { detail = "Revolut Business"; }

            // Append Asset (cleaned)
            let cleanAsset = normalizedAsset.replace("ZEUR", "EUR").replace("ZGBP", "GBP").replace("ZUSD", "USD");

            // v3.028: Make sure we don't double append
            if (!detail.includes("(" + cleanAsset + ")")) {
              detail += ` (${cleanAsset})`;
            }

            row.details = detail;
            // v3.045-19.35: Persist detected recipient for Summary Report
            if (recipient) row.recipient = recipient;
            // Also helpful: Save the raw info if needed
            if (e.info) row.rawInfo = e.info;

          } else {
            // Use e.type or fallback. If type is missing, use "Transfer"
            const typeLabel = e.type || "Transfer";
            row.details = `${typeLabel} (${e.asset})`;

            // Fix: Ensure Balance rows have correct labels if somehow falling here
            if (e.type === 'balance') row.details = "Balance Adjustment";
          }
          i += 1;
        }

        // Copy current state of running balances to row
        row.balances = { ...runningBal };
        bankRecords.push(row);
      }

      // 4. Closing Balance Row
      const closingBalRow = {
        date: formatTimestamp(endTs),
        time: "23:59:59",
        type: "Balance",
        details: "Closing Balance",
        balances: { ...runningBal },
        amounts: {},
        fees: {}
      };
      bankRecords.push(closingBalRow);

      // 5. Render
      // Save to Persistence
      localStorage.setItem("kraken_bank_staging", JSON.stringify(bankRecords));

      renderBankTable();

      // Update button state (Toggle behavior)
      const div = document.getElementById("bankReportArea");
      div.style.display = "block"; // Auto-show after generate

      // V2.84: Generate Summary immediately from these records to ensure consistency
      // v3.025: Decoupled to avoid "Frankenstein" behavior (Summary opening with Statement)
      // v3.045-18: Reactivated for Phase II (Strict Dependency)
      generateStatementSummary(bankRecords);
    }

    // Toggle function (Same approach as toggleReportViewer)
    async function toggleBankReport() {
      const div = document.getElementById("bankReportArea");
      const isHidden = (div.style.display === "none");

      if (isHidden) {
        // Generate & Show
        const btn = document.getElementById("btn_bank_statement");
        const originalText = btn.textContent;
        btn.textContent = "Generating...";
        btn.disabled = true;

        // Yield to allow UI update
        await new Promise(r => setTimeout(r, 50));

        try {
          // This function exists globally and populates cacheData.bankRecords then calls renderBankTable()
          await generateBankReport();
        } catch (e) {
          alert("Error generating statement: " + e.message);
        } finally {
          btn.textContent = originalText;
          btn.disabled = false;
        }
      } else {
        // Hide
        div.style.display = "none";
      }
    }

    // v2.99: Table Filter Logic
    function filterBankReport() {
      const typeInput = document.getElementById("typeFilterInput");
      const descInput = document.getElementById("descFilterInput");

      const typeFilter = typeInput ? typeInput.value.toUpperCase() : "";
      const descFilter = descInput ? descInput.value.toUpperCase() : "";

      const table = document.getElementById("bankStmtTable");
      if (!table) return;

      const trs = table.getElementsByTagName("tr");
      // Start from 1 to skip header? Actually header has ID row maybe? 
      // The header row containing inputs is row 0. Data starts at row 1.
      // Wait, the new header structure puts inputs in the header. 
      // Let's assume data rows are in <tbody>.
      const tbody = table.getElementsByTagName("tbody")[0];
      if (!tbody) return;

      const rows = tbody.getElementsByTagName("tr");

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        // Columns: 0=Date, 1=Time, 2=Type, 3=Balance(old?), 4=Desc... 
        // Need to match Render Logic.
        // Render Logic (Line 2850+):
        // td0: Date
        // td1: Time
        // td2: Type
        // td3: Balance (Debit/Credit logic?) - Wait, let's check render order.

        // Let's grab text content by index, safer.
        // Columns: 0=Date, 1=Time, 2=Type(dep/wd/trade), 3=Desc(Details), 4=GBP(Debit), 5=GBP(Credit)...
        // Correct Render Mapping (renderBankTable):
        // td0: Date
        // td1: Time
        // td2: Type (class 'type-col')
        // td3: Description (class 'desc-col') <-- This is index 3!

        const cells = row.getElementsByTagName("td");
        if (cells.length < 4) continue;

        const typeTxt = cells[2].textContent || "";
        // v2.93 Fix: Description is at index 3, not 5
        const descTxt = cells[3].textContent || "";

        const typeMatch = typeTxt.toUpperCase().indexOf(typeFilter) > -1;
        const descMatch = descTxt.toUpperCase().indexOf(descFilter) > -1;

        if (typeMatch && descMatch) {
          row.style.display = "";
        } else {
          row.style.display = "none";
        }
      }
    }

    // ===========================================
    // STATEMENT SUMMARY REPORT (v2.50)
    // ===========================================
    let summaryRecords = { crypto: [], fiat: [], deposits: [], fees: [] };
    let depositTotals = {}; // v4.00-02: per-recipient (with GBP/EUR suffix) deposit totals for Haricom bank accounts


    function toggleSummaryReport() {
      const div = document.getElementById("summaryReportArea");
      const isHidden = (div.style.display === "none");
      if (isHidden) {
        // v3.027: Prefer bankRecords if available so Summary matches the Report
        if (typeof bankRecords !== "undefined" && bankRecords.length > 0) {
          generateStatementSummary(bankRecords);
        } else {
          __checkAndResetSummaryState();
          generateStatementSummary();
        }
      } else {
        div.style.display = "none";
      }
    }

    // V2.84: Accepts 'customRecords' (e.g. bankRecords) to ensure Summary matches Statement Table

    async function generateStatementSummary(customRecords) {
      const sDateVal = document.getElementById("startDate").value;
      const eDateVal = document.getElementById("endDate").value;

      // Phase II Rebuild: Strict Dependency on Bank Records (Statement Rows)
      // We expect 'customRecords' to be passed from generateBankReport.
      // If not, we try to use the global 'bankRecords'.
      // if neither is available or empty, we show a message or return.

      let sourceData = customRecords;
      if (!sourceData && typeof bankRecords !== "undefined" && bankRecords.length > 0) {
        sourceData = bankRecords;
      }

      if (!sourceData || sourceData.length === 0) {
        // v3.045-18: We no longer fallback to legacy cacheData. 
        // The Statement must be generated first.
        const div = document.getElementById("summaryReportArea");
        div.style.display = "block";
        div.innerHTML = '<div style="padding:20px; text-align:center; color:#c0392b;">Please generate the Kraken Statement first.</div>';
        return;
      }

      logTrace(`Generating Summary from ${sourceData.length} Statement Rows (Strict Mode)`);

      const startTs = new Date(sDateVal).getTime() / 1000;
      const endTs = new Date(eDateVal).getTime() / 1000 + 86399;

      // Aggregation Containers
      // Structures match renderSummaryTable expectation
      const cryptoTotals = {}; // { recipient: { USDT: 0, XRP: 0, USDT_GBP: 0, XRP_GBP: 0 } }
      const fMap = {};         // { recipient: { GBP: 0, EUR: 0, EUR_GBP: 0 } }

      // Global reset
      depositTotals = {};
      const depositGbpTotals = { GBP: 0, EUR: 0 };

      const feeTotals = { GBP: 0, EUR: 0, USDT: 0, XRP: 0 };
      const feeGbpTotals = { GBP: 0, EUR: 0, USDT: 0, XRP: 0 };
      // v3.045-18.3: Track Net Trades for Reconciliation
      const tradeTotals = { GBP: 0, EUR: 0, USDT: 0, XRP: 0 };
      const tradeGbpTotals = { GBP: 0, EUR: 0, USDT: 0, XRP: 0 };

      // Helper to try and find a daily rate for a timestamp
      const getDailyRate = (asset, timestamp) => {
        if (!timestamp || !cacheData || !cacheData.ratesCache) return null;
        const dObj = new Date(timestamp * 1000);
        const dStr = dObj.toISOString().split("T")[0];
        const dayRates = cacheData.ratesCache[dStr];
        if (!dayRates) return null;

        if (asset === "EUR" && dayRates.EURGBP) return dayRates.EURGBP;
        if (asset === "USDT" && dayRates.USDTGBP) return dayRates.USDTGBP;
        if (asset === "XRP" && dayRates.XRPGBP) return dayRates.XRPGBP;
        return null;
      };

      for (const item of sourceData) {
        // item is a bankRecord { date, time, type, details, amounts: {}, fees: {}, balances: {}, _raw: e, gbpValues: {} }

        // Exclude Trades from Summary (as per instruction "Trades excluded from Summary")
        // bankRecords types are typically lowercase ("trade") or Title Case from merge ("Trade")
        // Check type insensitive
        const lType = (item.type || "").toLowerCase();
        const isTrade = (lType === "trade");

        // Skip Balance rows (Opening/Closing) for flow aggregation
        if (lType.includes("balance")) continue;

        const rawTime = (item._raw && item._raw.time) ? item._raw.time : null;

        // --- 1. RECIPIENT IDENTIFICATION ---
        let recipient = item.details || "Unknown";

        // v3.045-19.40: Smart Name Extraction
        // If details is just "Withdrawal" (common for Bank Transfers), try to use the raw address label if available
        // logic: if (recipient === "Withdrawal" && item.addressLabel) recipient = item.addressLabel;
        // However, item.details usually COMES from the address label in processLedger.
        // Let's refine the cleanup to ensure "Revolut Ltd" etc comes through.

        // Cleanup: remove parenthetical assets e.g. " (USDT)"
        recipient = recipient.replace(/\((?!GBP\b|EUR\b)[^)]*\)/, "").trim();

        // Cleanup: remove known asset keywords if they appear floating
        recipient = recipient.replace(/\s*(XRP|USDT|TRC20|ERC20|BTC|ETH)\s*/gi, "").trim();

        // v3.045-19.40: Enforce "First Two Words" rule for better formatting
        // This fixes "Revolut Business" showing as just "Withdrawal" if the logic previously failed.
        const _m2 = recipient.match(/\s*\((GBP|EUR)\)\s*$/);
        const _suf2 = _m2 ? " (" + _m2[1] + ")" : "";
        const _base2 = recipient.replace(/\s*\((GBP|EUR)\)\s*$/, "");
        const words = _base2.split(/\s+/);
        if (words.length > 2) {
          recipient = words.slice(0, 2).join(" ") + _suf2;
        } else {
          recipient = _base2.trim() + _suf2;
        }

        // Specific Fix: If it's still just "Withdrawal" and we have a specific known bank pattern, or if it was overridden??
        // actually, the user says "derived from the label on the address table". 
        // In processLedger, we set row.details. If it was "Withdrawal", it means no address match was found OR the label was "Withdrawal".
        // Use a fallback if still generic? No, the issue is likely that "Revolut Business" was > 2 words or handled wrong.
        // Just ensuring the 2-word slice happens cleanly is likely the fix, or we need to check if 'Withdrawal' can be improved.
        if (recipient.toLowerCase() === "withdrawal" && item._raw && item._raw.info) {
          // Fallback to raw info if details is generic
          let rawInfo = item._raw.info;
          if (rawInfo) {
            const rawWords = rawInfo.split(/\s+/);
            if (rawWords.length >= 1) recipient = rawWords.slice(0, 2).join(" ");
          }
        }

        // --- 2. PROCESS AMOUNTS ---
        for (const [asset, val] of Object.entries(item.amounts)) {
          if (!val || val === 0) continue;

          // v3.045-18.3: Track Net Trade Flows for Reconciliation
          if (isTrade) {
            // Accumulate Signed Trade Amount for Reconciliation Calculation
            if (!tradeTotals[asset]) tradeTotals[asset] = 0;
            tradeTotals[asset] += val;

            // Also calculate GBP equivalent for the reconciliation line
            let gbpEq = 0;
            // Use item.gbpValues if available, else daily rate
            if (item.gbpValues && item.gbpValues[asset]) {
              // item.gbpValues are explicitly calculated positive magnitudes usually.
              // We need the signed flow.
              // If val is negative (Sold), gbp flow is negative.
              const sign = val < 0 ? -1 : 1;
              gbpEq = item.gbpValues[asset] * sign;
            } else {
              const r = getDailyRate(asset, rawTime);
              if (r) gbpEq = val * r;
            }
            if (gbpEq) {
              if (!tradeGbpTotals[asset]) tradeGbpTotals[asset] = 0;
              tradeGbpTotals[asset] += gbpEq;
            }

            // Do NOT process as Deposit/Withdrawal for the Summary Table
            continue;
          }

          const absVal = Math.abs(val);

          if (lType === "deposit" && val > 0) {
            // DEPOSIT
            if (asset === "GBP" || asset === "EUR") {
              const _dKey = recipient + ((asset === "GBP" || asset === "EUR") ? " (" + asset + ")" : "");
              if (!depositTotals[_dKey]) depositTotals[_dKey] = { GBP: 0, EUR: 0, EUR_GBP: 0 };
              depositTotals[_dKey][asset] += absVal;

              // EUR Deposit -> GBP Equivalent
              if (asset === "EUR") {
                let gbpEq = 0;
                // Prefer pre-calculated row value if available
                if (item.gbpValues && item.gbpValues.EUR) {
                  gbpEq = item.gbpValues.EUR;
                } else {
                  // Calc using daily rate
                  const r = getDailyRate("EUR", rawTime);
                  if (r) gbpEq = absVal * r;
                }
                if (gbpEq) depositGbpTotals.EUR += gbpEq;
                if (_dKey && depositTotals[_dKey]) depositTotals[_dKey].EUR_GBP += gbpEq;
              }
            }

          } else if (lType === "withdrawal" && val < 0) {
            // WITHDRAWAL
            if (asset === "USDT" || asset === "XRP") {
              // CRYPTO EXPENSE
              if (!cryptoTotals[recipient]) cryptoTotals[recipient] = { USDT: 0, XRP: 0, USDT_GBP: 0, XRP_GBP: 0 };

              cryptoTotals[recipient][asset] += absVal;

              // Calc GBP Eq
              let gbpEq = 0;
              if (item.gbpValues && item.gbpValues[asset]) {
                gbpEq = item.gbpValues[asset];
              } else {
                const r = getDailyRate(asset, rawTime);
                if (r) gbpEq = absVal * r;
              }

              if (asset === "USDT") cryptoTotals[recipient].USDT_GBP += gbpEq;
              if (asset === "XRP") cryptoTotals[recipient].XRP_GBP += gbpEq;

            } else if (asset === "GBP" || asset === "EUR") {
              // FIAT EXPENSE
              const _rKey = recipient + ((asset === "GBP" || asset === "EUR") ? " (" + asset + ")" : "");
              if (!fMap[_rKey]) fMap[_rKey] = { GBP: 0, EUR: 0, EUR_GBP: 0 };

              fMap[_rKey][asset] += absVal;

              if (asset === "EUR") {
                let gbpEq = 0;
                if (item.gbpValues && item.gbpValues.EUR) {
                  gbpEq = item.gbpValues.EUR;
                } else {
                  const r = getDailyRate("EUR", rawTime);
                  if (r) gbpEq = absVal * r;
                }
                if (gbpEq) fMap[_rKey].EUR_GBP += gbpEq;
              }
            }
          } else {
            // CATCH-ALL: Any other transaction type (Spend, Margin, Transfer, etc)
            // Treat as "Net Trade Activity" to ensure Closing Balance reconciles.
            // Duplicate logic from isTrade block
            if (!tradeTotals[asset]) tradeTotals[asset] = 0;
            tradeTotals[asset] += val;

            let gbpEq = 0;
            if (item.gbpValues && item.gbpValues[asset]) {
              const sign = val < 0 ? -1 : 1;
              gbpEq = item.gbpValues[asset] * sign;
            } else {
              const r = getDailyRate(asset, rawTime);
              if (r) gbpEq = val * r;
            }
            if (gbpEq) {
              if (!tradeGbpTotals[asset]) tradeGbpTotals[asset] = 0;
              tradeGbpTotals[asset] += gbpEq;
            }
          }
        } // end amounts loop

        // --- 3. PROCESS FEES ---
        // Fees are positive in bankRecords (extracted from ledger fee).
        // They represent a cost.
        // v3.045-18.4: Normalize fee assets (ZEUR->EUR, ZGBP->GBP)
        for (const [rawFAsset, fVal] of Object.entries(item.fees)) {
          if (!fVal || fVal <= 0) continue;

          let fAsset = rawFAsset;
          // Normalization
          if (fAsset === "ZEUR" || fAsset === "EUR.HOLD") fAsset = "EUR";
          else if (fAsset === "ZGBP" || fAsset === "GBP.HOLD") fAsset = "GBP";
          else if (fAsset === "ZUSD" || fAsset === "USD.HOLD") fAsset = "USDT"; // Or USD? Summary uses USDT for USD-peg usually, but let's stick to base. 
          // Actually, feeTotals are initialized for GBP, EUR, USDT, XRP.
          // If fee is in XXRP, map to XRP.
          if (fAsset === "XXRP") fAsset = "XRP";
          if (fAsset === "USDT") fAsset = "USDT"; // already correct

          // Accumulate
          if (feeTotals[fAsset] !== undefined) {
            feeTotals[fAsset] += fVal;

            // GBP Equivalent for Fee
            if (fAsset !== "GBP") {
              let gbpEq = 0;
              // Fees might not have explicit gbpValues in the row object (usually amounts do).
              // So reliable fallback is daily rate.
              const r = getDailyRate(fAsset, rawTime);
              if (r) gbpEq = fVal * r;

              if (gbpEq) feeGbpTotals[fAsset] += gbpEq;
            }
          }
        }
      } // end row loop

      // Sort and Store
      const cryptoRows = Object.keys(cryptoTotals).map(r => ({ recipient: r, ...cryptoTotals[r] })).sort((a, b) => a.recipient.localeCompare(b.recipient));
      const fiatRows = Object.keys(fMap).map(r => ({ recipient: r, ...fMap[r] })).sort((a, b) => a.recipient.localeCompare(b.recipient));

      const depositRows = Object.keys(depositTotals)
        .map(r => ({ recipient: r, ...depositTotals[r] }))
        .sort((a, b) => a.recipient.localeCompare(b.recipient));

      const feeRows = [
        { asset: "GBP", total: feeTotals.GBP, gbpEq: null },
        { asset: "EUR", total: feeTotals.EUR, gbpEq: feeGbpTotals.EUR },
        { asset: "USDT", total: feeTotals.USDT, gbpEq: feeGbpTotals.USDT },
        { asset: "XRP", total: feeTotals.XRP, gbpEq: feeGbpTotals.XRP }
      ];

      // v3.045-18.3: Add Trade Rows for Reconciliation
      const tradeRows = [
        { asset: "GBP", total: tradeTotals.GBP, gbpEq: null },
        { asset: "EUR", total: tradeTotals.EUR, gbpEq: tradeGbpTotals.EUR },
        { asset: "USDT", total: tradeTotals.USDT, gbpEq: tradeGbpTotals.USDT },
        { asset: "XRP", total: tradeTotals.XRP, gbpEq: tradeGbpTotals.XRP }
      ];



      // v3.045-19.31: Calculate Opening Balances HERE (moved from renderSummaryTable)
      let openingBalances = null;
      if (Array.isArray(sourceData) && sourceData.length > 0) {
        for (let i = 0; i < sourceData.length; i++) {
          const r = sourceData[i];
          if (r && (r.details === "Opening Balance" || r.type === "Balance")) {
            if (r.details === "Opening Balance" && r.balances) { openingBalances = r.balances; break; }
          }
        }
      }

      // Rates for OB Calculation
      const startDateStr = document.getElementById("startDate").value;
      const _rateKeys = (cacheData && cacheData.ratesCache) ? Object.keys(cacheData.ratesCache).filter(k => /^\d{4}-\d{2}-\d{2}$/.test(k)).sort() : [];
      let startRateKey = null;
      if (startDateStr && _rateKeys.length) {
        for (let i = 0; i < _rateKeys.length; i++) { if (_rateKeys[i] >= startDateStr) { startRateKey = _rateKeys[i]; break; } }
        if (!startRateKey) { for (let i = _rateKeys.length - 1; i >= 0; i--) { if (_rateKeys[i] <= startDateStr) { startRateKey = _rateKeys[i]; break; } } }
      }
      if (!startRateKey) startRateKey = startDateStr || null;
      let startRates = (startRateKey && cacheData && cacheData.ratesCache) ? (cacheData.ratesCache[startRateKey] || {}) : {};
      let startUSDTGBP = (startRates && typeof startRates.USDTGBP === "number") ? startRates.USDTGBP : null;
      let startXRPGBP = (startRates && typeof startRates.XRPGBP === "number") ? startRates.XRPGBP : null;
      let startEURGBP = (startRates && typeof startRates.EURGBP === "number") ? startRates.EURGBP : ((startRates && typeof startRates.USDTGBP === "number" && typeof startRates.USDTEUR === "number" && startRates.USDTEUR !== 0) ? (startRates.USDTGBP / startRates.USDTEUR) : null);

      const _ob = (openingBalances && typeof openingBalances === "object") ? openingBalances : {};
      const _obGBP = (isFinite(Number(_ob.GBP)) ? Number(_ob.GBP) : 0);
      const _obEUR = (isFinite(Number(_ob.EUR)) ? Number(_ob.EUR) : 0);
      const _obUSDT = (isFinite(Number(_ob.USDT)) ? Number(_ob.USDT) : 0);
      const _obXRP = (isFinite(Number(_ob.XRP)) ? Number(_ob.XRP) : 0);

      const _obEURgbp = (_obEUR && startEURGBP != null) ? (_obEUR * startEURGBP) : 0;
      const _obUSDTgbp = (_obUSDT && startUSDTGBP != null) ? (_obUSDT * startUSDTGBP) : 0;
      const _obXRPgbp = (_obXRP && startXRPGBP != null) ? (_obXRP * startXRPGBP) : 0;

      // Populate global summary records
      summaryRecords = {
        crypto: cryptoRows,
        fiat: fiatRows,
        deposits: depositRows,
        fees: feeRows,
        trades: tradeRows,
        openingBalances: {
          GBP: _obGBP,
          EUR: _obEUR,
          EUR_GBP: _obEURgbp,
          USDT: _obUSDT,
          USDT_GBP: _obUSDTgbp,
          XRP: _obXRP,
          XRP_GBP: _obXRPgbp
        }
      };

      // Persist
      localStorage.setItem("kraken_summary_staging_v3.045-18", JSON.stringify(summaryRecords));

      await renderSummaryTable();
    }

    async function renderSummaryTable() {
      const div = document.getElementById("summaryReportArea");
      div.style.display = "block";

      // Check if empty (using new structure keys)
      // For deposits, we must check if total > 0 because length is always 2 (presets)
      // Show Always
      const isEmpty = false;

      // Opening Balance snapshot + GBP-basis equivalents (initialized early to avoid TDZ)
      let openingBalances = null;
      let openGBP = 0;
      let openEUR = 0;
      let openUSDT = 0;
      let openXRP = 0;

      // v3.045-19.34: Hoisted Rate Logic (Consolidated)
      // Determine start-of-period FX rates
      let startDateStr = (() => {
        try {
          const v = document.getElementById("startDate").value;
          if (!v) return null;
          return v;
        } catch (e) { return null; }
      })();

      const _rateKeys = (cacheData && cacheData.ratesCache) ? Object.keys(cacheData.ratesCache).filter(k => /^\d{4}-\d{2}-\d{2}$/.test(k)).sort() : [];
      let startRateKey = null;
      if (startDateStr && _rateKeys.length) {
        for (let i = 0; i < _rateKeys.length; i++) { if (_rateKeys[i] >= startDateStr) { startRateKey = _rateKeys[i]; break; } }
        if (!startRateKey) { for (let i = _rateKeys.length - 1; i >= 0; i--) { if (_rateKeys[i] <= startDateStr) { startRateKey = _rateKeys[i]; break; } } }
      }
      if (!startRateKey) startRateKey = startDateStr || null;
      let startRates = (startRateKey && cacheData && cacheData.ratesCache) ? (cacheData.ratesCache[startRateKey] || {}) : {};
      let startUSDTGBP = (startRates && typeof startRates.USDTGBP === "number") ? startRates.USDTGBP : null;
      let startXRPGBP = (startRates && typeof startRates.XRPGBP === "number") ? startRates.XRPGBP : null;
      let startEURGBP = (startRates && typeof startRates.EURGBP === "number") ? startRates.EURGBP : ((startRates && typeof startRates.USDTGBP === "number" && typeof startRates.USDTEUR === "number" && startRates.USDTEUR !== 0) ? (startRates.USDTGBP / startRates.USDTEUR) : null);

      // Determine end-of-period FX rates
      let endDateStr = (() => {
        try {
          const v = document.getElementById("endDate").value;
          if (!v) return null;
          return new Date(v).toISOString().split("T")[0];
        } catch (e) { return null; }
      })();

      const endUnix = endDateStr ? Math.floor(new Date(endDateStr + "T12:00:00Z").getTime() / 1000) : null;

      // Ensure end-date FX rates exist (closing balances need end-date conversion)
      if (endDateStr && endUnix && cacheData && cacheData.ratesCache && !cacheData.ratesCache[endDateStr]) {
        const [usdtEnd, xrpEnd, eurEnd] = await Promise.all([
          getKrakenRate('USDT', endUnix),
          getKrakenRate('XRP', endUnix),
          getKrakenRate('EUR', endUnix)
        ]);
        cacheData.ratesCache[endDateStr] = {
          USDTGBP: (usdtEnd && typeof usdtEnd.gbpRate === 'number') ? usdtEnd.gbpRate : null,
          XRPGBP: (xrpEnd && typeof xrpEnd.gbpRate === 'number') ? xrpEnd.gbpRate : null,
          EURGBP: (eurEnd && typeof eurEnd.gbpRate === 'number') ? eurEnd.gbpRate : null
        };
        saveCacheToLocalStorage();
      }

      let endRates = (endDateStr && cacheData && cacheData.ratesCache) ? (cacheData.ratesCache[endDateStr] || {}) : {};
      let endUSDTGBP = (endRates && typeof endRates.USDTGBP === "number") ? endRates.USDTGBP : null;
      let endXRPGBP = (endRates && typeof endRates.XRPGBP === "number") ? endRates.XRPGBP : null;
      let endEURGBP = (endRates && typeof endRates.EURGBP === "number") ? endRates.EURGBP : null;

      // Local amount formatters for Statement Summary sections (avoid undefined global refs)
      const fmtGBPAmount = (n) => {
        const v = (n == null || n === "" || isNaN(n)) ? 0 : Number(n);
        return v.toFixed(2);
      };
      const fmtAmount = (n, decimals = 4) => {
        const v = (n == null || n === "" || isNaN(n)) ? 0 : Number(n);
        return v.toFixed(decimals);
      };

      // --- Container (Centered) ---
      let html = '<div style="max-width:1000px; margin:0 auto; box-shadow:0 1px 4px rgba(0,0,0,0.1); background:#fff; border-radius:4px; overflow:hidden; border:1px solid #ddd;">';

      // Main Title Bar (Blue)
      html += '<div onclick="toggleSummaryReport()" style="cursor:pointer; background:#2980b9; color:#fff; padding:8px 15px; font-size:0.8rem; font-weight:bold; display:flex; justify-content:space-between; align-items:center;" title="Click to close report">';
      html += '<span>Statement Summary</span>';
      if (!isEmpty) {
        html += '<span style="display:flex; gap:6px; align-items:center;"><button onclick="event.stopPropagation(); printKrakenStatement()" title="Print / Save Kraken Statement PDF" style="padding:2px 8px; background:#fff; color:#000; border:none; border-radius:3px; font-size:0.65rem; font-weight:600; cursor:pointer;">&#x1F5B6; Statement PDF</button><button onclick="event.stopPropagation(); printStatementSummary()" title="Print / Save PDF" style="padding:2px 8px; background:#fff; color:#000; border:none; border-radius:3px; font-size:0.65rem; font-weight:600; cursor:pointer;">&#x1F5B6; Statement Summary PDF</button><button onclick="event.stopPropagation(); copySummaryReport()" title="Copy Table" style="padding:2px 8px; background:#fff; color:#000; border:none; border-radius:3px; font-size:0.65rem; font-weight:600; cursor:pointer;">&#x2398; Copy Tables</button></span>';
      }
      html += '</div>';

      if (isEmpty) {
        html += '<div style="padding:20px; text-align:center; color:#7f8c8d; font-size:0.75rem;">No summary data generated.</div>';
        html += '</div>'; // Close container
        div.innerHTML = html;
        if (div.scrollIntoView) div.scrollIntoView({ behavior: "smooth" });
        return;
      }

      html += '<div style="padding:15px;">'; // Padding for content

      // --- 1. CRYPTO TABLE ---
      html += '<div style="background:#8e44ad; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0;">Withdrawals to Recipients  USDT | XRP</div>';
      html += '<div style="overflow-x:auto;">';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:20px; border:1px solid #ddd; table-layout:fixed;">';
      html += '<thead style="background:#f9f9f9;"><tr>';
      html += '<th rowspan="2" style="padding:4px; border:1px solid #ddd; text-align:left; vertical-align:middle; width:20%;">Recipient</th>';
      html += '<th colspan="2" style="padding:4px; border:1px solid #ddd; text-align:center;">USDT Withdrawal</th>';
      html += '<th colspan="2" style="padding:4px; border:1px solid #ddd; text-align:center;">XRP Withdrawal</th>';
      html += '</tr><tr>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">USDT</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">GBP Equivalent</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">XRP Amount</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right; font-size:0.65rem;">GBP Equivalent</th>';
      html += '</tr></thead><tbody>';

      if (summaryRecords.crypto && summaryRecords.crypto.length > 0) {
        for (const r of summaryRecords.crypto) {
          html += '<tr>';
          html += `<td style="padding:5px; border:1px solid #ddd; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${escHtml(r.recipient)}">${escHtml(r.recipient)}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right;">${r.USDT > 0 ? r.USDT.toFixed(4) : "-"}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right; color:#000; font-weight:bold;">${r.USDT_GBP > 0 ? r.USDT_GBP.toFixed(2) : "-"}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right;">${r.XRP > 0 ? r.XRP.toFixed(4) : "-"}</td>`;
          html += `<td style="padding:5px; border:1px solid #ddd; text-align:right; color:#000; font-weight:bold;">${r.XRP_GBP > 0 ? r.XRP_GBP.toFixed(2) : "-"}</td>`;
          html += '</tr>';
        }
      } else {
        html += '<tr><td colspan="5" style="padding:15px; text-align:center; color:#7f8c8d; font-style:italic;">No withdrawals found for this period.</td></tr>';
      }
      html += '</tbody></table></div>';

      // --- 2. FIAT TABLE ---
      html += '<div style="background:#27ae60; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0;">Withdrawals to Haricom Bank Accounts  GBP | EUR</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:20px; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Haricom Bank Account</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">EUR</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP Equivalent (of EUR)</th>'; // New Column
      html += '</tr></thead><tbody>';

      const fiatRecipients = summaryRecords.fiat || [];
      if (fiatRecipients.length === 0) {
        html += '<tr><td colspan="4" style="text-align:center; padding:10px; font-style:italic; color:#7f8c8d;">No withdrawals found for this period.</td></tr>';
      } else {
        for (const r of fiatRecipients) {
          const gbpShow = (r.GBP && r.GBP > 0) ? r.GBP.toFixed(2) : "-";
          const eurShow = (r.EUR && r.EUR > 0) ? r.EUR.toFixed(2) : "-";
          // GBP Equivalent for EUR
          const eqShow = (r.EUR && r.EUR > 0) ? (r.EUR_GBP ? r.EUR_GBP.toFixed(2) : "0.00") : "n/a";

          const gbpStyle = (r.GBP && r.GBP > 0) ? "font-weight:bold; color:#000;" : "";
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:left;">${escHtml(r.recipient)}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${gbpStyle}">${gbpShow}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right;">${eurShow}</td>`;
          const eqStyle = (r.EUR && r.EUR > 0) ? "font-weight:bold; color:#000;" : "color:#7f8c8d;";
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${eqStyle}">${eqShow}</td>`;
          html += '</tr>';
        }
      }
      html += '</tbody></table>';

      // v3.045-19.31: Data now pre-calculated in generateStatementSummary
      const obs = summaryRecords.openingBalances || {};
      const _obGBP = obs.GBP || 0;
      const _obEUR = obs.EUR || 0;
      const _obUSDT = obs.USDT || 0;
      const _obXRP = obs.XRP || 0;
      const _obEURgbp = obs.EUR_GBP || 0;
      const _obUSDTgbp = obs.USDT_GBP || 0;
      const _obXRPgbp = obs.XRP_GBP || 0;

      // Link for Reconciliation Calculation (User Request: Sequence Consistency)
      openGBP = _obGBP;
      openEUR = _obEURgbp; // Reconciliation table uses GBP Equivalent for EUR column
      openUSDT = _obUSDTgbp; // Reconciliation table uses GBP Equivalent for USDT column
      openXRP = _obXRPgbp; // Reconciliation table uses GBP Equivalent for XRP column




      // --- OPENING BALANCES ---
      html += '<div style="background:#2980b9; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-top:14px; margin-bottom:0;">Opening Balances  GBP | EUR | USDT | XRP</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:0; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Asset</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">Balance</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP Equivalent</th>';
      html += '</tr></thead><tbody>';

      const _addOBRow = (asset, bal, gbpEq, isGBPRow) => {
        // v3.045-19.40: User requested specific decimal conventions:
        // GBP/EUR: 2 decimals
        // USDT/XRP: 4 decimals
        const decimals = (asset === "GBP" || asset === "EUR") ? 2 : 4;
        const balShow = (bal == null) ? "0.00" : Number(bal).toFixed(decimals);
        const eqShow = fmtGBPAmount(gbpEq);
        const eqStyle = (gbpEq && Math.abs(gbpEq) > 0) ? "font-weight:bold; color:#000;" : "color:#7f8c8d;";
        html += '<tr>';
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:left;">${asset}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right;">${balShow}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${eqStyle}">${eqShow}</td>`;
        html += '</tr>';
      };

      _addOBRow('GBP', _obGBP, _obGBP, true);
      _addOBRow('EUR', _obEUR, _obEURgbp, false);
      _addOBRow('USDT', _obUSDT, _obUSDTgbp, false);
      _addOBRow('XRP', _obXRP, _obXRPgbp, false);

      html += '</tbody></table>';


      // -- RE-IMPLEMENTING DEPOSITS SECTION TO BE ALWAYS VISIBLE --
      html += '<div style="background:#27ae60; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0; margin-top:20px;">Deposits from Haricom Bank Accounts  GBP | EUR</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:20px; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Currency</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">Total Amount</th><th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP Equivalent</th>';
      html += '</tr></thead><tbody>';
      const _hasDeposits = (summaryRecords.deposits || []).some(r => (Number(r.total) || 0) !== 0);
      if (!_hasDeposits) {
        html += '<tr><td colspan="3" style="padding:8px; border:1px solid #ddd; text-align:center; color:#666; font-style:italic;">No deposits found for this period.</td></tr>';
      }
      for (const r of (summaryRecords.deposits || [])) {
        if (!_hasDeposits) break;
        const asset = r.asset;
        const total = parseFloat(r.total || 0);
        const totalShow = total.toFixed(2);

        let gbpEqShow = "-";
        if (asset === "GBP") {
          gbpEqShow = "n/a";
        } else if (asset === "EUR") {
          const eq = (typeof r.gbpEq === "number") ? r.gbpEq : parseFloat(r.gbpEq || 0);
          gbpEqShow = (eq || total === 0) ? (eq || 0).toFixed(2) : "0.00";
        }

        const totalStyle = (asset === "GBP") ? "font-weight:bold;" : "";
        const eqStyle = (asset === "EUR") ? "font-weight:bold; color:#000;" : "color:#7f8c8d;";

        html += '<tr>';
        html += `<td style="padding:4px; border:1px solid #ddd;">${asset}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${totalStyle}">${totalShow}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${eqStyle}">${gbpEqShow}</td>`;
        html += '</tr>';
      }
      html += '</tbody></table>';


      // --- 4. FEES SECTION (New V3.003) ---
      // v3.010: Changed color to Dark Slate (#2c3e50) for better accessibility (Red-Green distinction) and avoiding warning associations
      html += '<div style="background:#2c3e50; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-bottom:0;">Fees  GBP | EUR | USDT | XRP</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:0; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Currency</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">Total Amount</th><th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP Equivalent</th>';
      html += '</tr></thead><tbody>';

      // v3.011: Fee Display Logic with "-" for no records and proper decimals

      const renderFeeRow = (asset, total) => {
        // Heuristic: If total is 0, check if we had any activity for this asset.
        let activity = false;
        if (asset === "GBP" || asset === "EUR") {
          if (depositTotals[asset] > 0) activity = true;
          if (summaryRecords.fiat) summaryRecords.fiat.forEach(r => { if (r[asset] > 0) activity = true; });
        } else {
          if (summaryRecords.crypto) summaryRecords.crypto.forEach(r => { if (r[asset] > 0) activity = true; });
        }

        if (!activity && total === 0) return "-";

        const decimals = (asset === "GBP" || asset === "EUR") ? 2 : 4;
        return total.toFixed(decimals);
      };

      const renderFeeGbpEq = (asset, gbpEq, total) => {
        if (asset === "GBP") return "n/a";

        // If no activity and total is 0, show "-" (same intent as renderFeeRow)
        let activity = false;
        if (asset === "EUR") {
          if (depositTotals[asset] > 0) activity = true;
          if (summaryRecords.fiat) summaryRecords.fiat.forEach(r => { if (r[asset] > 0) activity = true; });
        } else {
          if (summaryRecords.crypto) summaryRecords.crypto.forEach(r => { if (r[asset] > 0) activity = true; });
        }
        if (!activity && total === 0) return "-";

        if (gbpEq == null) return "-";
        return gbpEq.toFixed(2);
      };

      if (summaryRecords.fees && summaryRecords.fees.length > 0) {
        for (const r of summaryRecords.fees) {
          html += '<tr>';
          html += `<td style="padding:4px; border:1px solid #ddd;">${r.asset}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${r.asset === "GBP" ? "font-weight:bold;" : ""}">${renderFeeRow(r.asset, r.total)}</td>`;
          html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${r.asset !== "GBP" ? "font-weight:bold; color:#000;" : "color:#7f8c8d;"}">${renderFeeGbpEq(r.asset, r.gbpEq, r.total)}</td>`;
          html += '</tr>';
        }
      }
      html += '</tbody></table>';


      // --- 5. CLOSING BALANCES (GBP | EUR | USDT | XRP) ---
      // Uses the Statement row "Closing Balance" as source of truth (same data used to render the statement table)
      let closingBalances = null;
      if (Array.isArray(bankRecords) && bankRecords.length > 0) {
        for (let i = bankRecords.length - 1; i >= 0; i--) {
          const r = bankRecords[i];
          if (r && (r.details === "Closing Balance" || r.type === "Balance")) {
            if (r.balances) { closingBalances = r.balances; break; }
          }
        }
      }

      // [Moved to top of function]

      // Populate opening balances (GBP basis) using opening snapshot + end-of-period FX rates (consistent with closing balance GBP equivalents)
      // [Logic Moved to Top of Function using summaryRecords]
      // Legacy redundant block removed to prevent overwrite
      // if (openingBalances) { ... }


      // Compute missing end-rates (closing balances should rarely show '-')
      if (endUnix) {
        if (!endEURGBP) {
          const r = await getKrakenRate("EUR", endUnix);
          endEURGBP = (r && typeof r.gbpRate === "number") ? r.gbpRate : startEURGBP; // Fallback to start rate
        }
        if (!endUSDTGBP) {
          const r = await getKrakenRate("USDT", endUnix);
          endUSDTGBP = (r && typeof r.gbpRate === "number") ? r.gbpRate : startUSDTGBP;
        }
        if (!endXRPGBP) {
          const r = await getKrakenRate("XRP", endUnix);
          endXRPGBP = (r && typeof r.gbpRate === "number") ? r.gbpRate : startXRPGBP;
        }
      }

      const fmtBal = (asset, v) => {
        if (v === null || v === undefined) return "-";
        const n = parseFloat(v);
        if (!isFinite(n)) return "-";
        const d = (asset === "GBP" || asset === "EUR") ? 2 : 4;
        return n.toFixed(d);
      };

      const fmtGbpEq = (asset, v) => {
        if (asset === "GBP") return "n/a";
        if (v === null || v === undefined) return "-";
        const n = parseFloat(v);
        if (!isFinite(n)) return "-";
        return n.toFixed(2);
      };

      html += '<div style="background:#2980b9; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-top:14px; margin-bottom:0;">Closing Balances  GBP | EUR | USDT | XRP</div>';
      html += '<table style="width:100%; border-collapse:collapse; margin-bottom:0; border:1px solid #ddd;">';
      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left;">Asset</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">Balance</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP Equivalent</th>';
      html += '</tr></thead><tbody>';

      let closingGBPVal = 0;


      let closingEURGbpEq = 0;


      let closingUSDTGbpEq = 0;


      let closingXRPGbpEq = 0;



      const assetsCB = ["GBP", "EUR", "USDT", "XRP"];
      for (const a of assetsCB) {
        const bal = (closingBalances && closingBalances[a] !== undefined) ? closingBalances[a] : null;

        let gbpEq = null;
        if (a === "GBP") {
          gbpEq = "n/a";
        } else if (bal !== null) {
          const balNum = parseFloat(bal);
          if (balNum === 0) {
            gbpEq = 0;
          } else if (a === "EUR") {
            gbpEq = endEURGBP ? (balNum * endEURGBP) : null;
          } else if (a === "USDT") {
            gbpEq = endUSDTGBP ? (balNum * endUSDTGBP) : null;
          } else if (a === "XRP") {
            gbpEq = endXRPGBP ? (balNum * endXRPGBP) : null;
          }
        }

        // Accumulate GBP-basis closing totals for reconciliation (local to renderSummaryTable)
        if (a === "GBP") {
          const _n = parseFloat(bal);
          closingGBPVal = (bal !== null && bal !== undefined && isFinite(_n)) ? _n : 0;
        } else if (a === "EUR") {
          const _n = parseFloat(gbpEq);
          closingEURGbpEq = (gbpEq !== null && gbpEq !== undefined && gbpEq !== "n/a" && isFinite(_n)) ? _n : 0;
        } else if (a === "USDT") {
          const _n = parseFloat(gbpEq);
          closingUSDTGbpEq = (gbpEq !== null && gbpEq !== undefined && gbpEq !== "n/a" && isFinite(_n)) ? _n : 0;
        } else if (a === "XRP") {
          const _n = parseFloat(gbpEq);
          closingXRPGbpEq = (gbpEq !== null && gbpEq !== undefined && gbpEq !== "n/a" && isFinite(_n)) ? _n : 0;
        }

        html += '<tr>';
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:left;">${a}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${a === "GBP" ? "font-weight:bold; color:#000;" : "color:#000;"}">${fmtBal(a, bal)}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${a !== "GBP" ? "font-weight:bold; color:#000;" : "color:#7f8c8d;"}">${fmtGbpEq(a, gbpEq)}</td>`;
        html += '</tr>';
      }

      html += '</tbody></table>';

      // --- 6. RECONCILIATION DIFFERENCE (GBP BASIS) ---
      // Computed from already-rendered Statement Summary values (no hard-coding)
      const _n2 = (v) => {
        const n = parseFloat(v);
        if (!isFinite(n)) return 0;
        // Avoid -0.00 display edge cases downstream
        return (Math.abs(n) < 0.0000001) ? 0 : n;
      };
      const _fmt2 = (n) => {
        const v = _n2(n);
        return v.toFixed(2);
      };

      // A) Opening balance (from statement "Opening Balance" snapshot section if available; otherwise 0)

      // B) Deposits from Haricom Bank Accounts (GBP + EUR->GBP equivalent)
      let depGBP = 0;
      let depEUR = 0;
      if (Array.isArray(summaryRecords.deposits)) {
        for (const r of summaryRecords.deposits) {
          if (!r) continue;
          if (r.asset === "GBP") depGBP += _n2(r.total);
          if (r.asset === "EUR") depEUR += _n2(r.gbpEq);
        }
      }

      // C) Withdrawals to Recipients (USDT/XRP withdrawals GBP equivalent)
      let wRecUSDT = 0;
      let wRecXRP = 0;
      if (Array.isArray(summaryRecords.crypto)) {
        for (const r of summaryRecords.crypto) {
          if (!r) continue;
          wRecUSDT += _n2(r.USDT_GBP);
          wRecXRP += _n2(r.XRP_GBP);
        }
      }
      wRecUSDT = -wRecUSDT;
      wRecXRP = -wRecXRP;

      // D) Withdrawals to Haricom Bank Accounts (GBP withdrawals + EUR->GBP equivalent)
      let wBankGBP = 0;
      let wBankEUR = 0;
      if (Array.isArray(summaryRecords.fiat)) {
        for (const r of summaryRecords.fiat) {
          if (!r) continue;
          wBankGBP += _n2(r.GBP);
          wBankEUR += _n2(r.EUR_GBP);
        }
      }
      wBankGBP = -wBankGBP;
      wBankEUR = -wBankEUR;

      // E) Fees (Negative)
      let feeGBP = 0, feeEUR = 0, feeUSDT = 0, feeXRP = 0;
      if (summaryRecords.fees) {
        for (const r of summaryRecords.fees) {
          if (r.asset === "GBP") feeGBP += _n2(r.total);
          else if (r.asset === "EUR") feeEUR += _n2(r.gbpEq);
          else if (r.asset === "USDT") feeUSDT += _n2(r.gbpEq);
          else if (r.asset === "XRP") feeXRP += _n2(r.gbpEq);
        }
      }
      feeGBP = -feeGBP;
      feeEUR = -feeEUR;
      feeUSDT = -feeUSDT;
      feeXRP = -feeXRP;

      // F) Net Trade Activity (v3.045-18.3)
      // Usually zero sum globally, but per asset it represents conversion in/out.
      // IMPORTANT: We need the GBP Equivalent impact for the table columns.
      // For GBP column, it's the raw GBP flow.
      // For EUR column (GBP Eq), it's the GBP Equivalent of the EUR flow.
      // For Crypto columns, it's the GBP Eq of the Crypto flow.

      let tradeGBP = 0, tradeEUR = 0, tradeUSDT = 0, tradeXRP = 0; // These are GBP Equivalent values

      if (summaryRecords.trades) {
        for (const r of summaryRecords.trades) {
          // For GBP asset, the value itself is GBP.
          if (r.asset === "GBP") tradeGBP += _n2(r.total);
          // For others, use gbpEq
          else if (r.asset === "EUR") tradeEUR += _n2(r.gbpEq);
          else if (r.asset === "USDT") tradeUSDT += _n2(r.gbpEq);
          else if (r.asset === "XRP") tradeXRP += _n2(r.gbpEq);
        }
      }

      // G) Closing balances (GBP basis) from the already-rendered Closing Balances section
      const actGBP = _n2(closingGBPVal);
      const actEUR = _n2(closingEURGbpEq);
      const actUSDT = _n2(closingUSDTGbpEq);
      const actXRP = _n2(closingXRPGbpEq);

      // Calculated closing (GBP basis) = sum of signed rows 
      // Formula: Open + Deposits - Withdrawals - Fees + Net Trades
      const expGBP = openGBP + depGBP + wBankGBP + feeGBP + tradeGBP;
      const expEUR = openEUR + depEUR + wBankEUR + feeEUR + tradeEUR;
      const expUSDT = openUSDT + wRecUSDT + feeUSDT + tradeUSDT;
      const expXRP = openXRP + wRecXRP + feeXRP + tradeXRP; // wRecXRP is 0 usually if empty? No, wRecXRP is negative withdrawal.

      const expTotal = expGBP + expEUR + expUSDT + expXRP;
      const actTotal = actGBP + actEUR + actUSDT + actXRP;

      const diffGBP = expGBP - actGBP;
      const diffEUR = expEUR - actEUR;
      const diffUSDT = expUSDT - actUSDT;
      const diffXRP = expXRP - actXRP;
      const diffTotal = expTotal - actTotal;

      const _rowTotal = (a, b, c, d) => _n2(a) + _n2(b) + _n2(c) + _n2(d);

      html += '<div style="background:#2980b9; color:#fff; padding:5px 10px; font-size:0.7rem; font-weight:bold; border-radius:4px 4px 0 0; margin-top:14px; margin-bottom:0; page-break-before:always; break-before:page;">Reconciliation Difference  GBP | EUR | USDT | XRP</div>';

      // Scrollable Container for Reconciliation Table
      html += '<div style="overflow-x:auto; border:1px solid #ddd; border-top:none;">';
      html += '<table style="width:100%; min-width:600px; border-collapse:collapse; margin-bottom:0; page-break-inside:avoid; break-inside:avoid;">';

      html += '<thead><tr style="background:#f2f2f2;">';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:left; position:sticky; left:0; background:#f2f2f2; z-index:5;">Item</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">GBP</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">EUR (GBP Eq)</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">USDT (GBP Eq)</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">XRP (GBP Eq)</th>';
      html += '<th style="padding:4px; border:1px solid #ddd; text-align:right;">Total (GBP)</th>';
      html += '</tr></thead><tbody>';

      const _addReconRow = (label, gbp, eur, usdt, xrp, isTotalRow) => {
        const total = _rowTotal(gbp, eur, usdt, xrp);
        const lblStyle = isTotalRow ? "font-weight:bold;" : "";
        const numStyle = isTotalRow ? "font-weight:bold; color:#000;" : "color:#000;";
        const stickyStyle = "position:sticky; left:0; background:#fff; z-index:20; border-right:1px solid #ddd;";

        const _fmtRecon = (v) => {
          if (v === "n/a") return '<span style="color:#7f8c8d; font-weight:normal;">n/a</span>';
          return _fmt2(v);
        };

        html += '<tr>';
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:left; ${lblStyle} ${stickyStyle}">${label}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${numStyle}">${_fmtRecon(gbp)}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${numStyle}">${_fmtRecon(eur)}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${numStyle}">${_fmtRecon(usdt)}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${numStyle}">${_fmtRecon(xrp)}</td>`;
        html += `<td style="padding:4px; border:1px solid #ddd; text-align:right; ${numStyle}">${_fmt2(total)}</td>`;
        html += '</tr>';
      };

      _addReconRow('Opening Balance', openGBP, openEUR, openUSDT, openXRP, false);
      _addReconRow('Deposits from bank accounts', depGBP, depEUR, "n/a", "n/a", false);
      _addReconRow('Withdrawals to recipients', "n/a", "n/a", wRecUSDT, wRecXRP, false);
      _addReconRow('Withdrawals to bank accounts', wBankGBP, wBankEUR, "n/a", "n/a", false);
      _addReconRow('Fees', feeGBP, feeEUR, feeUSDT, feeXRP, false);
      _addReconRow('Net Trade Activity', tradeGBP, tradeEUR, tradeUSDT, tradeXRP, false);
      _addReconRow('Calculated Closing', expGBP, expEUR, expUSDT, expXRP, true);
      _addReconRow('Actual Closing', actGBP, actEUR, actUSDT, actXRP, true);
      _addReconRow('Reconciliation Difference', diffGBP, diffEUR, diffUSDT, diffXRP, true);

      html += '</tbody></table></div>';

      // v3.045-18.7: Calculate Total Volume for FX Variance Context
      // Volume = Sum of absolute values of all flows (Deposits + Withdrawals + Fees + Trades)
      // We use the GBP equivalents we calculated for the table.
      const volDep = Math.abs(depGBP) + Math.abs(depEUR);
      const volWRec = Math.abs(wRecUSDT) + Math.abs(wRecXRP);
      const volWBank = Math.abs(wBankGBP) + Math.abs(wBankEUR);
      const volFees = Math.abs(feeGBP) + Math.abs(feeEUR) + Math.abs(feeUSDT) + Math.abs(feeXRP);
      const volTrades = Math.abs(tradeGBP) + Math.abs(tradeEUR) + Math.abs(tradeUSDT) + Math.abs(tradeXRP);

      // v3.045-18.10: Calculate "Total Traded Value" (Unique Trades, not doubled)
      // Iterate global cache to sum trade values, deduplicating by RefID (since Ledger has 2 entries per trade)
      let uniqueTradeVolume = 0;
      const seenRefIds = new Set();

      if (cacheData && cacheData.withdrawalCache) {
        for (const r of cacheData.withdrawalCache) {
          if (r.type === 'trade') {
            if (!seenRefIds.has(r.refid)) {
              seenRefIds.add(r.refid);
              // Add the GBP value of this trade side
              // We assume the value is symmetric roughly, so taking the first one is fine.
              const val = (r.gbpValues && r.gbpValues.amount) ? parseFloat(r.gbpValues.amount) : 0;
              uniqueTradeVolume += val;
            }
          }
        }
      }

      const totalVolume = uniqueTradeVolume;
      const diffAbs = Math.abs(diffTotal);
      const diffPct = totalVolume > 0 ? ((diffAbs / totalVolume) * 100).toFixed(3) : "0.000";

      html += `<div style="font-size:0.75rem; color:#555; margin-top:5px;">
        A reconciliation difference of GBP ${_fmt2(diffTotal)} exists. 
        This is attributed to FX variance and exchange rate fluctuations over the reporting period.
        <br>Note: A positive value means calculated > actual; a negative value means calculated < actual.
      </div>`;




      html += '</div></div>'; // Close padding div, Close container div
      div.innerHTML = html;
      if (div.scrollIntoView) div.scrollIntoView({ behavior: "smooth" });
    }

    function renderBankTable() {
      const div = document.getElementById("bankReportArea");
      // Don't force display:block here, just update content. 
      updateGlobalRecordCounts();

      let html = '<table id="bankStmtTable" style="min-width:100%; width:auto; border-collapse:collapse;"><thead><tr>';

      // Fixed Columns (Rowspan 2 for vertical centering)
      const hStyle = "border:1px solid #ddd; padding:8px; vertical-align:middle; background:#f9f9f9;";
      html += `<th rowspan="2" class="w-bank-datetime" style="${hStyle}">Date</th>`;
      html += `<th rowspan="2" class="w-bank-datetime" style="${hStyle}">Time</th>`;
      html += `<th rowspan="2" class="w-type" style="${hStyle}">
        Type<br/>
        <input type="text" id="typeFilterInput" placeholder="Filter..." 
        onkeyup="filterBankReport()" onclick="event.stopPropagation()">
      </th>`;
      html += `<th rowspan="2" class="w-bank-details" style="${hStyle}">
        Description<br/>
        <input type="text" id="descFilterInput" placeholder="Filter..." 
        onkeyup="filterBankReport()" onclick="event.stopPropagation()">
      </th>`;

      // Asset Columns (Dynamic)
      // Asset Columns (Dynamic)
      TRACKED_ASSETS.forEach(asset => {
        let cleanAsset = asset;
        if (asset === "ZEUR") cleanAsset = "EUR";
        if (asset === "ZGBP") cleanAsset = "GBP";
        if (asset === "XXRP") cleanAsset = "XRP";

        html += `<th colspan="4" class="section-border-left" style="text-align:center; border-bottom:none; background:#f9f9f9;">${cleanAsset}</th>`;
      });
      html += '</tr><tr>';

      // Sub-headers (Amounts)
      TRACKED_ASSETS.forEach(asset => {
        html += `<th class="section-border-left" style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Debit</th>`;
        html += `<th style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Credit</th>`;
        html += `<th style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Fee</th>`;
        html += `<th style="text-align:right; font-size:0.55rem; background:#f9f9f9;">Balance</th>`;
      });
      html += '</tr></thead><tbody>';

      if (bankRecords.length === 0) {
        html += `<tr><td colspan="${4 + (TRACKED_ASSETS.length * 4)}" style="text-align:center; padding:10px;">No bank statement generated. Select dates and click the button.</td></tr>`;
      } else {
        for (const r of bankRecords) {
          // Rule: Only bold the Closing Balance (or Opening?) - User said "remove bold from balances"
          // but likely meant the columns. 
          // Previous code: isBalRow ? "background:#f2f2f2; font-weight:bold;" : ""
          // We will keep bold for the ROW if it is a Balance row (Opening/Closing) for emphasis,
          // OR remove it entirely if that was the request. 
          // "Remove bold for balances, only use bold for the total below".
          // So Opening/Closing rows can be bold (Totals), but the regular rows should not have bold balance columns.
          // Regular rows didn't have bold columns before, only the Balance ROWs were bold.
          // IF "balance" refers to the column itself? 
          // Let's assume the Row Style "font-weight:bold" affects the whole row.
          const isBalRow = r.type.includes("Balance");
          const rowStyle = isBalRow ? "background:#f2f2f2; font-weight:bold;" : "";

          // Apply Z-strip to description if it contains (ZEUR) etc.
          let desc = escHtml(r.details);
          desc = desc.replace("(ZEUR)", "(EUR)").replace("(ZGBP)", "(GBP)").replace("(ZUSD)", "(USD)");

          html += `<tr style="${rowStyle}">`;
          html += `<td class="w-bank-datetime" style="padding:4px; border-bottom:1px solid #eee;">${r.date}</td>`;
          html += `<td class="w-bank-datetime" style="padding:4px; border-bottom:1px solid #eee;">${r.time}</td>`;
          html += `<td class="w-type" style="padding:4px; border-bottom:1px solid #eee;">${r.type}</td>`;
          html += `<td class="w-bank-details" style="padding:4px; border-bottom:1px solid #eee;">${desc}</td>`;

          TRACKED_ASSETS.forEach(asset => {
            const amt = r.amounts[asset];
            const fee = r.fees[asset];
            const bal = r.balances[asset];

            const dec = (asset === "USDT" || asset === "XRP") ? 4 : 2;

            // Split Debit/Credit
            // Debit: Negative amount (withdrawals/sends/trades out). Show as Positive.
            // Credit: Positive amount (deposits/trades in). Show as Positive.
            const showDeb = (amt !== undefined && amt < 0) ? Math.abs(amt).toFixed(dec) : "";
            const showCred = (amt !== undefined && amt > 0) ? Math.abs(amt).toFixed(dec) : "";

            const showFee = (fee !== undefined && fee > 0) ? fee.toFixed(dec) : "";
            const showBal = (bal !== undefined) ? bal.toFixed(dec) : "0.00";

            // Ensure individual cells aren't bold unless row is
            html += `<td class="w-bank-val section-border-left" style="padding:4px; border-bottom:1px solid #eee; color:#c0392b;">${showDeb}</td>`;
            html += `<td class="w-bank-val" style="padding:4px; border-bottom:1px solid #eee; color:#000;">${showCred}</td>`;
            html += `<td class="w-bank-val" style="padding:4px; border-bottom:1px solid #eee; color:#7f8c8d;">${showFee}</td>`;
            html += `<td class="w-bank-bal" style="padding:4px; border-bottom:1px solid #eee;">${showBal}</td>`;
          });
          html += `</tr>`;
        }
      }

      html += '</tbody></table>';
      div.innerHTML = html;
    }

    // Copy Functions
    function copyBankReport() {
      if (!bankRecords || bankRecords.length === 0) { alert("No data to copy."); return; }
      const div = document.getElementById("bankReportArea");
      copyNodeText(div);
    }

    function copySummaryReport() {
      if (typeof summaryRecords === "undefined") return;

      const hasData = (summaryRecords.crypto && (summaryRecords.crypto.length > 0 || summaryRecords.fiat.length > 0 || summaryRecords.deposits.length > 0));
      if (!hasData) { alert("No data to copy."); return; }

      const div = document.getElementById("summaryReportArea");
      copyNodeText(div);
    }

    // Helper: Convert YYYY-MM-DD to "DD Month YYYY" (e.g. 01 September 2025)
    function formatDateForPDF(isoDate) {
      if (!isoDate) return "";
      const d = new Date(isoDate);
      if (isNaN(d.getTime())) return isoDate;
      const day = d.getDate().toString().padStart(2, '0');
      const month = d.toLocaleString('en-GB', { month: 'long' });
      const year = d.getFullYear();
      return `${day} ${month} ${year}`;
    }


    // v3.043-2: Print / Save Statement Summary as PDF (browser print-to-PDF)
    function printStatementSummary() {
      const src = document.getElementById("summaryReportArea");
      if (!src || src.style.display === "none") { alert("Statement Summary is not displayed."); return; }

      // Hardcoded title to avoid "Generating..." text leaking from buttons
      const start = document.getElementById("startDate")?.value || "";
      const end = document.getElementById("endDate")?.value || "";
      stmtLabel = `Kraken Statement Summary ${start} to ${end}`;

      // Clone and strip interactive controls
      const tmp = document.createElement("div");
      tmp.innerHTML = src.innerHTML;
      tmp.querySelectorAll("button").forEach(b => b.remove());

      // Prefer the content area (tables) rather than the clickable container header
      const content = tmp.querySelector('div[style*="padding:15px"]');
      const tablesHtml = content ? content.innerHTML : tmp.innerHTML;

      const titleLine = "Kraken Statement Summary";
      const dateRangeLine = `${formatDateForPDF(start)} - ${formatDateForPDF(end)}`;

      const w = window.open("", "_blank");
      if (!w) { alert("Popup blocked. Allow popups to print."); return; }

      w.document.open();
      w.document.write(`<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>${stmtLabel}</title>
<style>
  @page { margin: 12mm; }
  * { box-sizing: border-box; }
  body { font-family: Arial, Helvetica, sans-serif; color:#000; margin:0; }
  .hdr { text-align: center; margin-bottom: 20px; }
  .hdr .t1 { font-size: 22px; font-weight: 700; margin-bottom: 8px; }
  .hdr .t2 { font-size: 14px; font-weight: 700; color:#333; }
  
  /* Remove on-screen subheaders if copied */
  .subhdr { display: none; }
  
  table { width: 100% !important; border-collapse: collapse; table-layout: fixed; }
  th, td { border: 1px solid #ddd; padding: 5px; font-size: 11px; vertical-align: top; }
  th { background: #f9f9f9; font-weight: 700; }
  .section-title { font-size: 12px; font-weight: 700; color:#fff; padding: 6px 10px; border-radius: 4px 4px 0 0; margin: 12px 0 0; }
  .wrap { overflow: visible !important; }
  /* Preserve colors in print */
  body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
</style>
</head>
<body>
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
    <div style="font-size:16px; font-weight:bold; color:#333;">Kraken Reports</div>
    <div style="font-size:12px; color:#666;">${APP_VERSION}</div>
  </div>
  <div class="hdr">
    <div class="t1">${titleLine}</div>
    <div class="t2">${dateRangeLine}</div>
  </div>
  <div class="wrap">${tablesHtml}</div>
</body>
</html>`);
      w.document.close();
      w.focus();
      setTimeout(() => { w.print(); }, 250);
    }

    function printKrakenStatement() {
      // Ensure the bank statement report is generated for the current date range
      try {
        if (typeof generateBankReport === "function") {
          generateBankReport();
        }
      } catch (e) {
        // proceed to print whatever is present
      }

      const src = document.querySelector("#bankReportArea");
      if (!src || !src.innerHTML || src.innerHTML.trim().length < 20) {
        alert("Kraken Statement is empty. Click 'Kraken Statement (Select Dates)' first, then try again.");
        return;
      }

      const clone = src.cloneNode(true);

      // Force the statement section to be expanded in the clone (if collapsed by CSS)
      clone.style.display = "block";

      const start = document.getElementById("startDate")?.value || "";
      const end = document.getElementById("endDate")?.value || "";

      const pdfTitle = `Kraken Statement ${start} to ${end}`; // For filename
      const pdfHeaderDate = `${formatDateForPDF(start)} - ${formatDateForPDF(end)}`;

      const w = window.open("", "_blank");
      w.document.open();
      w.document.write(`
    <html>
      <head>
        <title>${pdfTitle}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 18px; }
          .hdr { text-align: center; margin-bottom: 25px; }
          .hdr .t1 { font-size: 22px; font-weight: 700; margin-bottom: 8px; }
          .hdr .t2 { font-size: 14px; font-weight: 700; color:#333; }
          
          /* Hide any on-screen headers that might be cloned */
          .subhdr, .report-header, h1, h2, h3 { display: none; }
          
          table { width: 100%; border-collapse: collapse; margin: 10px 0 18px 0; }
          th, td { border: 1px solid #ddd; padding: 6px 8px; font-size: 12px; vertical-align: top; }
          th { background: #f2f2f2; }
          .section-title { margin: 16px 0 8px 0; font-weight: 700; }
          /* Page breaking helpers for long tables */
          thead { display: table-header-group; }
          tfoot { display: table-footer-group; }
          tr { page-break-inside: avoid; }
          .page-break { page-break-before: always; }
          @media print {
            button { display: none; }
            a { color: inherit; text-decoration: none; }
          }
        </style>
      </head>
      <body>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
          <div style="font-size:16px; font-weight:bold; color:#333;">Kraken Reports</div>
          <div style="font-size:12px; color:#666;">${APP_VERSION}</div>
        </div>
        <div class="hdr">
          <div class="t1">Kraken Statement</div>
          <div class="t2">${pdfHeaderDate}</div>
        </div>
        <!-- Original PDF Subtitle logic removed -->
      </body>
    </html>
  `);
      w.document.body.appendChild(clone);
      w.document.close();
      w.focus();
      setTimeout(() => {
        w.print();
        setTimeout(() => w.close(), 250);
      }, 150);
    }


    function filterDetails(query) {
      const filter = query.toUpperCase();
      const area = document.getElementById("bankReportArea");
      if (!area) return;

      const rows = area.getElementsByTagName("tr");
      // Skip headers (first 2 rows usually, checking th vs td)
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = row.getElementsByTagName("td");
        if (cells.length > 3) {
          // Description is usually index 3 (Date, Time, Type, Desc...)
          // Using class 'w-bank-details' is safer? row.querySelector(".w-bank-details")
          const descCell = row.querySelector(".w-bank-details");
          if (descCell) {
            const txt = descCell.textContent || descCell.innerText;
            if (txt.toUpperCase().indexOf(filter) > -1) {
              row.style.display = "";
            } else {
              row.style.display = "none";
            }
          }
        }
      }
    }

    function copyNodeText(node) {
      if (!node) return;
      const selection = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(node);
      selection.removeAllRanges();
      selection.addRange(range);

      try {
        document.execCommand('copy');
        alert("Table copied to clipboard!");
      } catch (e) {
        alert("Failed to copy.");
      }
      selection.removeAllRanges();
    }

    // ---------- Boot ----------
    async function waitFor(cond, timeoutMs) {
      const t0 = Date.now();
      return new Promise((resolve, reject) => {
        const tick = () => {
          if (cond()) return resolve(true);
          if (Date.now() - t0 > timeoutMs) return reject(new Error("Timeout"));
          setTimeout(tick, 50);
        };
        tick();
      });
    }

    async function boot() {
      // Load saved staging
      const savedStaging = localStorage.getItem("kraken_staging");
      if (savedStaging) {
        try {
          stagingRecords = JSON.parse(savedStaging);
        } catch (e) { }
      }

      // Load saved Bank Staging
      const savedBank = localStorage.getItem("kraken_bank_staging");
      if (savedBank) {
        try {
          bankRecords = JSON.parse(savedBank);
          // We do not auto-render or auto-show, but data is ready.
        } catch (e) { }
      }

      // Load saved Summary Staging
      const savedSummary = localStorage.getItem("kraken_summary_staging_v3.045-18");
      if (savedSummary) {
        try {
          summaryRecords = JSON.parse(savedSummary);
        } catch (e) { }
      }

      // Load cached data from localStorage (so Generate Report works without re-pulling)
      const savedWithdrawals = localStorage.getItem("kraken_v2_withdrawals");
      const savedAddresses = localStorage.getItem("kraken_v2_addresses");
      const savedHistory = localStorage.getItem("kraken_v2_history");
      const savedRates = localStorage.getItem("kraken_v2_rates_" + APP_VERSION);
      if (savedWithdrawals) cacheData.withdrawals = JSON.parse(savedWithdrawals);
      if (savedAddresses) cacheData.krakenAddresses = JSON.parse(savedAddresses);
      if (savedHistory) cacheData.withdrawalHistory = JSON.parse(savedHistory);
      if (savedRates) cacheData.ratesCache = JSON.parse(savedRates);

      renderPreview();
      updateStatusCounts();

      // Auto-load API credentials from localStorage
      const savedKey = localStorage.getItem("kraken_api_key");
      const savedPrivate = localStorage.getItem("kraken_private_key");
      const savedProxyType = localStorage.getItem("kraken_cors_proxy_type");
      const savedProxy = localStorage.getItem("kraken_cors_proxy");
      const savedGasUrl = localStorage.getItem("kraken_gas_proxy_url");
      const savedWithdrawKey = localStorage.getItem("kraken_withdraw_api_key");
      const savedWithdrawPrivate = localStorage.getItem("kraken_withdraw_private_key");
      const savedSheetId = localStorage.getItem("kraken_sheet_id");

      // Force update of date-dependent buttons on boot (in case of browser autofill)
      setTimeout(() => updateBankButtonLabel(), 500);
      if (savedKey) document.getElementById("krakenApiKey").value = savedKey;
      if (savedPrivate) document.getElementById("krakenPrivateKey").value = savedPrivate;

      if (savedProxyType) {
        document.getElementById("corsProxySelect").value = savedProxyType;
      } else {
        // Default to GAS if nothing saved
        document.getElementById("corsProxySelect").value = "gas";
      }

      if (savedGasUrl) document.getElementById("gasProxyUrl").value = savedGasUrl;
      if (savedProxy && savedProxy !== "custom") {
        // Legacy handling or specific url
      }
      if (savedProxyType === "custom" && savedProxy) {
        document.getElementById("corsProxy").value = savedProxy;
      }

      // Initialize UI visibility based on values
      handleProxyChange();

      if (savedWithdrawKey) document.getElementById("withdrawApiKey").value = savedWithdrawKey;
      if (savedWithdrawPrivate) document.getElementById("withdrawPrivateKey").value = savedWithdrawPrivate;
      if (savedSheetId) document.getElementById("googleSheetId").value = savedSheetId;

      try {
        await waitFor(() => typeof gapi !== "undefined", 8000);
        gapiLoaded();
      } catch (_) {
        logTrace("GAPI not available.");
      }

      try {
        await waitFor(() => typeof google !== "undefined" && google.accounts && google.accounts.oauth2, 8000);
        gisLoaded();
      } catch (_) {
        logTrace("GIS not available.");
      }

      logTrace(APP_VERSION + " Ready. Set date range, then click 'Fetch & Generate Report'.");
    }

    window.addEventListener("load", boot);
  </script>
</body>

</html>